{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JSON for Modern C++","text":""},{"location":"api/json/","title":"nlohmann::json","text":"<pre><code>using json = basic_json&lt;&gt;;\n</code></pre> <p>This type is the default specialization of the basic_json class which uses the standard template types.</p>"},{"location":"api/json/#examples","title":"Examples","text":"Example <p>The example below demonstrates how to use the type <code>nlohmann::json</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j =\n    {\n        {\"pi\", 3.141},\n        {\"happy\", true},\n        {\"name\", \"Niels\"},\n        {\"nothing\", nullptr},\n        {\n            \"answer\", {\n                {\"everything\", 42}\n            }\n        },\n        {\"list\", {1, 0, 2}},\n        {\n            \"object\", {\n                {\"currency\", \"USD\"},\n                {\"value\", 42.99}\n            }\n        }\n    };\n\n    // add new values\n    j[\"new\"][\"key\"][\"value\"] = {\"another\", \"list\"};\n\n    // count elements\n    auto s = j.size();\n    j[\"size\"] = s;\n\n    // pretty print with indent of 4 spaces\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"answer\": {\n        \"everything\": 42\n    },\n    \"happy\": true,\n    \"list\": [\n        1,\n        0,\n        2\n    ],\n    \"name\": \"Niels\",\n    \"new\": {\n        \"key\": {\n            \"value\": [\n                \"another\",\n                \"list\"\n            ]\n        }\n    },\n    \"nothing\": null,\n    \"object\": {\n        \"currency\": \"USD\",\n        \"value\": 42.99\n    },\n    \"pi\": 3.141,\n    \"size\": 8\n}\n</code></pre>"},{"location":"api/json/#version-history","title":"Version history","text":"<p>Since version 1.0.0.</p>"},{"location":"api/operator_gtgt/","title":"nlohmann::operator&gt;&gt;(basic_json)","text":"<pre><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; i, basic_json&amp; j);\n</code></pre> <p>Deserializes an input stream to a JSON value.</p>"},{"location":"api/operator_gtgt/#parameters","title":"Parameters","text":"<code>i</code> (in, out) input stream to read a serialized JSON value from <code>j</code> (in, out) JSON value to write the deserialized input to"},{"location":"api/operator_gtgt/#return-value","title":"Return value","text":"<p>the stream <code>i</code></p>"},{"location":"api/operator_gtgt/#exceptions","title":"Exceptions","text":"<ul> <li>Throws <code>parse_error.101</code> in case of an unexpected token.</li> <li>Throws <code>parse_error.102</code> if <code>to_unicode</code> fails or surrogate error.</li> <li>Throws <code>parse_error.103</code> if <code>to_unicode</code> fails.</li> </ul>"},{"location":"api/operator_gtgt/#complexity","title":"Complexity","text":"<p>Linear in the length of the input. The parser is a predictive LL(1) parser.</p>"},{"location":"api/operator_gtgt/#notes","title":"Notes","text":"<p>A UTF-8 byte order mark is silently ignored.</p> <p>Deprecation</p> <p>This function replaces function <code>std::istream&amp; operator&lt;&lt;(basic_json&amp; j, std::istream&amp; i)</code> which has been deprecated in version 3.0.0. It will be removed in version 4.0.0. Please replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>.</p>"},{"location":"api/operator_gtgt/#examples","title":"Examples","text":"Example <p>The example below shows how a JSON value is constructed by reading a serialization from a stream.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create stream with serialized JSON\n    std::stringstream ss;\n    ss &lt;&lt; R\"({\n        \"number\": 23,\n        \"string\": \"Hello, world!\",\n        \"array\": [1, 2, 3, 4, 5],\n        \"boolean\": false,\n        \"null\": null\n    })\";\n\n    // create JSON value and read the serialization from the stream\n    json j;\n    ss &gt;&gt; j;\n\n    // serialize JSON\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"array\": [\n    1,\n    2,\n    3,\n    4,\n    5\n  ],\n  \"boolean\": false,\n  \"null\": null,\n  \"number\": 23,\n  \"string\": \"Hello, world!\"\n}\n</code></pre>"},{"location":"api/operator_gtgt/#see-also","title":"See also","text":"<ul> <li>accept - check if the input is valid JSON</li> <li>parse - deserialize from a compatible input</li> </ul>"},{"location":"api/operator_gtgt/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0. Deprecated in version 3.0.0.</li> </ul>"},{"location":"api/operator_literal_json/","title":"nlohmann::operator\"\"_json","text":"<pre><code>json operator \"\"_json(const char* s, std::size_t n);\njson operator \"\"_json(const char8_t* s, std::size_t n);  // since C++20\n</code></pre> <p>This operator implements a user-defined string literal for JSON objects. It can be used by adding <code>_json</code> to a string literal and returns a <code>json</code> object if no parse error occurred.</p> <p>It is recommended to bring the operator into scope using any of the following lines: <pre><code>using nlohmann::literals::operator \"\"_json;\nusing namespace nlohmann::literals;\nusing namespace nlohmann::json_literals;\nusing namespace nlohmann::literals::json_literals;\nusing namespace nlohmann;\n</code></pre></p> <p>This is suggested to ease migration to the next major version release of the library. See <code>JSON_USE_GLOBAL_UDLS</code> for details.</p>"},{"location":"api/operator_literal_json/#parameters","title":"Parameters","text":"<code>s</code> (in) a string representation of a JSON object <code>n</code> (in) length of string <code>s</code>"},{"location":"api/operator_literal_json/#return-value","title":"Return value","text":"<p><code>json</code> value parsed from <code>s</code></p>"},{"location":"api/operator_literal_json/#exceptions","title":"Exceptions","text":"<p>The function can throw anything that <code>parse(s, s+n)</code> would throw.</p>"},{"location":"api/operator_literal_json/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/operator_literal_json/#examples","title":"Examples","text":"Example <p>The following code shows how to create JSON values from string literals.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    json j = R\"( {\"hello\": \"world\", \"answer\": 42} )\"_json;\n\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"answer\": 42,\n  \"hello\": \"world\"\n}\n</code></pre>"},{"location":"api/operator_literal_json/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Moved to namespace <code>nlohmann::literals::json_literals</code> in 3.11.0.</li> <li>Added <code>char8_t*</code> overload in 3.12.1.</li> </ul>"},{"location":"api/operator_literal_json_pointer/","title":"nlohmann::operator\"\"_json_pointer","text":"<pre><code>json_pointer operator \"\"_json_pointer(const char* s, std::size_t n);\njson_pointer operator \"\"_json_pointer(const char8_t* s, std::size_t n);  // since C++20\n</code></pre> <p>This operator implements a user-defined string literal for JSON Pointers. It can be used by adding <code>_json_pointer</code> to a string literal and returns a <code>json_pointer</code> object if no parse error occurred.</p> <p>It is recommended to bring the operator into scope using any of the following lines: <pre><code>using nlohmann::literals::operator \"\"_json_pointer;\nusing namespace nlohmann::literals;\nusing namespace nlohmann::json_literals;\nusing namespace nlohmann::literals::json_literals;\nusing namespace nlohmann;\n</code></pre> This is suggested to ease migration to the next major version release of the library. See <code>JSON_USE_GLOBAL_UDLS</code> for details.</p>"},{"location":"api/operator_literal_json_pointer/#parameters","title":"Parameters","text":"<code>s</code> (in) a string representation of a JSON Pointer <code>n</code> (in) length of string <code>s</code>"},{"location":"api/operator_literal_json_pointer/#return-value","title":"Return value","text":"<p><code>json_pointer</code> value parsed from <code>s</code></p>"},{"location":"api/operator_literal_json_pointer/#exceptions","title":"Exceptions","text":"<p>The function can throw anything that <code>json_pointer::json_pointer</code> would throw.</p>"},{"location":"api/operator_literal_json_pointer/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/operator_literal_json_pointer/#examples","title":"Examples","text":"Example <p>The following code shows how to create JSON Pointers from string literals.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    json j = R\"( {\"hello\": \"world\", \"answer\": 42} )\"_json;\n    auto val = j[\"/hello\"_json_pointer];\n\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; val &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>\"world\"\n</code></pre>"},{"location":"api/operator_literal_json_pointer/#see-also","title":"See also","text":"<ul> <li>json_pointer - type to represent JSON Pointers</li> </ul>"},{"location":"api/operator_literal_json_pointer/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> <li>Moved to namespace <code>nlohmann::literals::json_literals</code> in 3.11.0.</li> <li>Added <code>char8_t*</code> overload in 3.12.1.</li> </ul>"},{"location":"api/operator_ltlt/","title":"nlohmann::operator&lt;&lt;(basic_json), nlohmann::operator&lt;&lt;(json_pointer)","text":"<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const basic_json&amp; j);      // (1)\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const json_pointer&amp; ptr);  // (2)\n</code></pre> <ol> <li>Serialize the given JSON value <code>j</code> to the output stream <code>o</code>. The JSON value will be serialized using the    <code>dump</code> member function.<ul> <li>The indentation of the output can be controlled with the member variable <code>width</code> of the output stream <code>o</code>. For   instance, using the manipulator <code>std::setw(4)</code> on <code>o</code> sets the indentation level to <code>4</code> and the serialization   result is the same as calling <code>dump(4)</code>.</li> <li>The indentation character can be controlled with the member variable <code>fill</code> of the output stream <code>o</code>.   For instance, the manipulator <code>std::setfill('\\\\t')</code> sets indentation to use a tab character rather than the   default space character.</li> </ul> </li> <li>Write a string representation of the given JSON pointer <code>ptr</code> to the output stream <code>o</code>. The string representation is    obtained using the <code>to_string</code> member function.</li> </ol>"},{"location":"api/operator_ltlt/#parameters","title":"Parameters","text":"<code>o</code> (in, out) stream to write to <code>j</code> (in) JSON value to serialize <code>ptr</code> (in) JSON pointer to write"},{"location":"api/operator_ltlt/#return-value","title":"Return value","text":"<p>the stream <code>o</code></p>"},{"location":"api/operator_ltlt/#exceptions","title":"Exceptions","text":"<ol> <li>Throws <code>type_error.316</code> if a string stored inside the JSON    value is not UTF-8 encoded. Note that unlike the <code>dump</code> member functions, no <code>error_handler</code>    can be set.</li> <li>None.</li> </ol>"},{"location":"api/operator_ltlt/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/operator_ltlt/#notes","title":"Notes","text":"<p>Deprecation</p> <p>Function  <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const basic_json&amp; j)</code> replaces function <code>std::ostream&amp; operator&gt;&gt;(const basic_json&amp; j, std::ostream&amp; o)</code> which has been deprecated in version 3.0.0. It will be removed in version 4.0.0. Please replace calls like <code>j &gt;&gt; o;</code> with <code>o &lt;&lt; j;</code>.</p>"},{"location":"api/operator_ltlt/#examples","title":"Examples","text":"Example: (1) serialize JSON value to stream <p>The example below shows the serialization with different parameters to <code>width</code> to adjust the indentation level.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n\n    // serialize without indentation\n    std::cout &lt;&lt; j_object &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; j_array &lt;&lt; \"\\n\\n\";\n\n    // serialize with indentation\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_object &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j_array &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; std::setw(1) &lt;&lt; std::setfill('\\t') &lt;&lt; j_object &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\n\n[1,2,4,8,16]\n\n{\n    \"one\": 1,\n    \"two\": 2\n}\n\n[\n  1,\n  2,\n  4,\n  8,\n  16\n]\n\n{\n    \"one\": 1,\n    \"two\": 2\n}\n</code></pre> Example: (2) write JSON pointer to stream <p>The example below shows how to write a JSON pointer to a stream.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON pointer\n    json::json_pointer ptr(\"/foo/bar/baz\");\n\n    // write string representation to stream\n    std::cout &lt;&lt; ptr &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>/foo/bar/baz\n</code></pre>"},{"location":"api/operator_ltlt/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Added support for indentation character and deprecated    <code>std::ostream&amp; operator&gt;&gt;(const basic_json&amp; j, std::ostream&amp; o)</code> in version 3.0.0.</li> <li>Added in version 3.11.0.</li> </ol>"},{"location":"api/ordered_json/","title":"nlohmann::ordered_json","text":"<pre><code>using ordered_json = basic_json&lt;ordered_map&gt;;\n</code></pre> <p>This type preserves the insertion order of object keys.</p>"},{"location":"api/ordered_json/#iterator-invalidation","title":"Iterator invalidation","text":"<p>The type is based on <code>ordered_map</code> which in turn uses a <code>std::vector</code> to store object elements. Therefore, adding object elements can yield a reallocation in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated. Also, any iterator or reference after the insertion point will point to the same index, which is now a different value.</p>"},{"location":"api/ordered_json/#examples","title":"Examples","text":"Example <p>The example below demonstrates how <code>ordered_json</code> preserves the insertion order of object keys.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing ordered_json = nlohmann::ordered_json;\n\nint main()\n{\n    ordered_json j;\n    j[\"one\"] = 1;\n    j[\"two\"] = 2;\n    j[\"three\"] = 3;\n\n    std::cout &lt;&lt; j.dump(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"one\": 1,\n  \"two\": 2,\n  \"three\": 3\n}\n</code></pre>"},{"location":"api/ordered_json/#see-also","title":"See also","text":"<ul> <li>ordered_map</li> <li>Object Order</li> </ul>"},{"location":"api/ordered_json/#version-history","title":"Version history","text":"<p>Since version 3.9.0.</p>"},{"location":"api/ordered_map/","title":"nlohmann::ordered_map","text":"<pre><code>template&lt;class Key, class T, class IgnoredLess = std::less&lt;Key&gt;,\n         class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;\nstruct ordered_map : std::vector&lt;std::pair&lt;const Key, T&gt;, Allocator&gt;;\n</code></pre> <p>A minimal map-like container that preserves insertion order for use within <code>nlohmann::ordered_json</code> (<code>nlohmann::basic_json&lt;ordered_map&gt;</code>).</p>"},{"location":"api/ordered_map/#template-parameters","title":"Template parameters","text":"<code>Key</code> key type <code>T</code> mapped type <code>IgnoredLess</code> comparison function (ignored and only added to ensure compatibility with <code>std::map</code>) <code>Allocator</code> allocator type"},{"location":"api/ordered_map/#iterator-invalidation","title":"Iterator invalidation","text":"<p>The type uses a <code>std::vector</code> to store object elements. Therefore, adding elements can yield a reallocation in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated.</p>"},{"location":"api/ordered_map/#member-types","title":"Member types","text":"<ul> <li>key_type - key type (<code>Key</code>)</li> <li>mapped_type - mapped type (<code>T</code>)</li> <li>Container - base container type (<code>std::vector&lt;std::pair&lt;const Key, T&gt;, Allocator&gt;</code>)</li> <li>iterator</li> <li>const_iterator</li> <li>size_type</li> <li>value_type</li> <li>key_compare - key comparison function <pre><code>std::equal_to&lt;Key&gt;  // until C++14\n\nstd::equal_to&lt;&gt;     // since C++14\n</code></pre></li> </ul>"},{"location":"api/ordered_map/#member-functions","title":"Member functions","text":"<ul> <li>(constructor)</li> <li>(destructor)</li> <li>emplace</li> <li>operator[]</li> <li>at</li> <li>erase</li> <li>count</li> <li>find</li> <li>insert</li> </ul>"},{"location":"api/ordered_map/#examples","title":"Examples","text":"Example <p>The example shows the different behavior of <code>std::map</code> and <code>nlohmann::ordered_map</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// simple output function\ntemplate&lt;typename Map&gt;\nvoid output(const char* prefix, const Map&amp; m)\n{\n    std::cout &lt;&lt; prefix &lt;&lt; \" = { \";\n    for (auto&amp; element : m)\n    {\n        std::cout &lt;&lt; element.first &lt;&lt; \":\" &lt;&lt; element.second &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"}\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    // create and fill two maps\n    nlohmann::ordered_map&lt;std::string, std::string&gt; m_ordered;\n    m_ordered[\"one\"] = \"eins\";\n    m_ordered[\"two\"] = \"zwei\";\n    m_ordered[\"three\"] = \"drei\";\n\n    std::map&lt;std::string, std::string&gt; m_std;\n    m_std[\"one\"] = \"eins\";\n    m_std[\"two\"] = \"zwei\";\n    m_std[\"three\"] = \"drei\";\n\n    // output: m_ordered is ordered by insertion order, m_std is ordered by key\n    output(\"m_ordered\", m_ordered);\n    output(\"m_std\", m_std);\n\n    // erase and re-add \"one\" key\n    m_ordered.erase(\"one\");\n    m_ordered[\"one\"] = \"eins\";\n\n    m_std.erase(\"one\");\n    m_std[\"one\"] = \"eins\";\n\n    // output: m_ordered shows newly added key at the end; m_std is again ordered by key\n    output(\"m_ordered\", m_ordered);\n    output(\"m_std\", m_std);\n}\n</code></pre> <p>Output:</p> <pre><code>m_ordered = { one:eins two:zwei three:drei }\nm_std = { one:eins three:drei two:zwei }\nm_ordered = { two:zwei three:drei one:eins }\nm_std = { one:eins three:drei two:zwei }\n</code></pre>"},{"location":"api/ordered_map/#see-also","title":"See also","text":"<ul> <li>ordered_json</li> </ul>"},{"location":"api/ordered_map/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.9.0 to implement <code>nlohmann::ordered_json</code>.</li> <li>Added key_compare member in version 3.11.0.</li> </ul>"},{"location":"api/adl_serializer/","title":"nlohmann::adl_serializer","text":"<pre><code>template&lt;typename, typename&gt;\nstruct adl_serializer;\n</code></pre> <p>Serializer that uses ADL (Argument-Dependent Lookup) to choose <code>to_json</code>/<code>from_json</code> functions from the types' namespaces.</p> <p>It is implemented similarly to</p> <pre><code>template&lt;typename ValueType&gt;\nstruct adl_serializer {\n    template&lt;typename BasicJsonType&gt;\n    static void to_json(BasicJsonType&amp; j, const T&amp; value) {\n        // calls the \"to_json\" method in T's namespace\n    }\n\n    template&lt;typename BasicJsonType&gt;\n    static void from_json(const BasicJsonType&amp; j, T&amp; value) {\n        // same thing, but with the \"from_json\" method\n    }\n};\n</code></pre>"},{"location":"api/adl_serializer/#member-functions","title":"Member functions","text":"<ul> <li>from_json - convert a JSON value to any value type</li> <li>to_json - convert any value type to a JSON value</li> </ul>"},{"location":"api/adl_serializer/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.1.0.</li> </ul>"},{"location":"api/adl_serializer/from_json/","title":"nlohmann::adl_serializer::from_json","text":"<pre><code>// (1)\ntemplate&lt;typename BasicJsonType, typename TargetType = ValueType&gt;\nstatic auto from_json(BasicJsonType &amp;&amp; j, TargetType&amp; val) noexcept(\n    noexcept(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val)))\n-&gt; decltype(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), val), void())\n\n// (2)\ntemplate&lt;typename BasicJsonType, typename TargetType = ValueType&gt;\nstatic auto from_json(BasicJsonType &amp;&amp; j) noexcept(\nnoexcept(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {})))\n-&gt; decltype(::nlohmann::from_json(std::forward&lt;BasicJsonType&gt;(j), detail::identity_tag&lt;TargetType&gt; {}))\n</code></pre> <p>This function is usually called by the <code>get()</code> function of the basic_json class (either explicitly or via the conversion operators).</p> <ol> <li>This function is chosen for default-constructible value types.</li> <li>This function is chosen for value types which are not default-constructible.</li> </ol>"},{"location":"api/adl_serializer/from_json/#parameters","title":"Parameters","text":"<code>j</code> (in) JSON value to read from <code>val</code> (out) value to write to"},{"location":"api/adl_serializer/from_json/#return-value","title":"Return value","text":"<p>Copy of the JSON value, converted to <code>ValueType</code></p>"},{"location":"api/adl_serializer/from_json/#examples","title":"Examples","text":"Example: (1) Default-constructible type <p>The example below shows how a <code>from_json</code> function can be implemented for a user-defined type. This function is called by the <code>adl_serializer</code> when <code>template get&lt;ns::person&gt;()</code> is called.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nnamespace ns\n{\n// a simple struct to model a person\nstruct person\n{\n    std::string name;\n    std::string address;\n    int age;\n};\n} // namespace ns\n\nnamespace ns\n{\nvoid from_json(const json&amp; j, person&amp; p)\n{\n    j.at(\"name\").get_to(p.name);\n    j.at(\"address\").get_to(p.address);\n    j.at(\"age\").get_to(p.age);\n}\n} // namespace ns\n\nint main()\n{\n    json j;\n    j[\"name\"] = \"Ned Flanders\";\n    j[\"address\"] = \"744 Evergreen Terrace\";\n    j[\"age\"] = 60;\n\n    auto p = j.template get&lt;ns::person&gt;();\n\n    std::cout &lt;&lt; p.name &lt;&lt; \" (\" &lt;&lt; p.age &lt;&lt; \") lives in \" &lt;&lt; p.address &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>Ned Flanders (60) lives in 744 Evergreen Terrace\n</code></pre> Example: (2) Non-default-constructible type <p>The example below shows how a <code>from_json</code> is implemented as part of a specialization of the <code>adl_serializer</code> to realize the conversion of a non-default-constructible type.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nnamespace ns\n{\n// a simple struct to model a person (not default constructible)\nstruct person\n{\n    person(std::string n, std::string a, int aa)\n        : name(std::move(n)), address(std::move(a)), age(aa)\n    {}\n\n    std::string name;\n    std::string address;\n    int age;\n};\n} // namespace ns\n\nnamespace nlohmann\n{\ntemplate &lt;&gt;\nstruct adl_serializer&lt;ns::person&gt;\n{\n    static ns::person from_json(const json&amp; j)\n    {\n        return {j.at(\"name\"), j.at(\"address\"), j.at(\"age\")};\n    }\n\n    // Here's the catch! You must provide a to_json method! Otherwise, you\n    // will not be able to convert person to json, since you fully\n    // specialized adl_serializer on that type\n    static void to_json(json&amp; j, ns::person p)\n    {\n        j[\"name\"] = p.name;\n        j[\"address\"] = p.address;\n        j[\"age\"] = p.age;\n    }\n};\n} // namespace nlohmann\n\nint main()\n{\n    json j;\n    j[\"name\"] = \"Ned Flanders\";\n    j[\"address\"] = \"744 Evergreen Terrace\";\n    j[\"age\"] = 60;\n\n    auto p = j.template get&lt;ns::person&gt;();\n\n    std::cout &lt;&lt; p.name &lt;&lt; \" (\" &lt;&lt; p.age &lt;&lt; \") lives in \" &lt;&lt; p.address &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>Ned Flanders (60) lives in 744 Evergreen Terrace\n</code></pre>"},{"location":"api/adl_serializer/from_json/#see-also","title":"See also","text":"<ul> <li>to_json</li> </ul>"},{"location":"api/adl_serializer/from_json/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.1.0.</li> </ul>"},{"location":"api/adl_serializer/to_json/","title":"nlohmann::adl_serializer::to_json","text":"<pre><code>template&lt;typename BasicJsonType, typename TargetType = ValueType&gt;\nstatic auto to_json(BasicJsonType&amp; j, TargetType &amp;&amp; val) noexcept(\n    noexcept(::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val))))\n-&gt; decltype(::nlohmann::to_json(j, std::forward&lt;TargetType&gt;(val)), void())\n</code></pre> <p>This function is usually called by the constructors of the basic_json class.</p>"},{"location":"api/adl_serializer/to_json/#parameters","title":"Parameters","text":"<code>j</code> (out) JSON value to write to <code>val</code> (in) value to read from"},{"location":"api/adl_serializer/to_json/#examples","title":"Examples","text":"Example <p>The example below shows how a <code>to_json</code> function can be implemented for a user-defined type. This function is called by the <code>adl_serializer</code> when the constructor <code>basic_json(ns::person)</code> is called.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nnamespace ns\n{\n// a simple struct to model a person\nstruct person\n{\n    std::string name;\n    std::string address;\n    int age;\n};\n} // namespace ns\n\nnamespace ns\n{\nvoid to_json(json&amp; j, const person&amp; p)\n{\n    j = json{ {\"name\", p.name}, {\"address\", p.address}, {\"age\", p.age} };\n}\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    json j = p;\n\n    std::cout &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\n</code></pre>"},{"location":"api/adl_serializer/to_json/#see-also","title":"See also","text":"<ul> <li>from_json</li> </ul>"},{"location":"api/adl_serializer/to_json/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.1.0.</li> </ul>"},{"location":"api/basic_json/","title":"nlohmann::basic_json","text":"<p>Defined in header <code>&lt;nlohmann/json.hpp&gt;</code></p> <pre><code>template&lt;\n    template&lt;typename U, typename V, typename... Args&gt; class ObjectType = std::map,\n    template&lt;typename U, typename... Args&gt; class ArrayType = std::vector,\n    class StringType = std::string,\n    class BooleanType = bool,\n    class NumberIntegerType = std::int64_t,\n    class NumberUnsignedType = std::uint64_t,\n    class NumberFloatType = double,\n    template&lt;typename U&gt; class AllocatorType = std::allocator,\n    template&lt;typename T, typename SFINAE = void&gt; class JSONSerializer = adl_serializer,\n    class BinaryType = std::vector&lt;std::uint8_t&gt;,\n    class CustomBaseClass = void\n&gt;\nclass basic_json;\n</code></pre>"},{"location":"api/basic_json/#template-parameters","title":"Template parameters","text":"Template parameter Description Derived type <code>ObjectType</code> type for JSON objects <code>object_t</code> <code>ArrayType</code> type for JSON arrays <code>array_t</code> <code>StringType</code> type for JSON strings and object keys <code>string_t</code> <code>BooleanType</code> type for JSON booleans <code>boolean_t</code> <code>NumberIntegerType</code> type for JSON integer numbers <code>number_integer_t</code> <code>NumberUnsignedType</code> type for JSON unsigned integer numbers <code>number_unsigned_t</code> <code>NumberFloatType</code> type for JSON floating-point numbers <code>number_float_t</code> <code>AllocatorType</code> type of the allocator to use <code>JSONSerializer</code> the serializer to resolve internal calls to <code>to_json()</code> and <code>from_json()</code> <code>json_serializer</code> <code>BinaryType</code> type for binary arrays <code>binary_t</code> <code>CustomBaseClass</code> extension point for user code <code>json_base_class_t</code>"},{"location":"api/basic_json/#specializations","title":"Specializations","text":"<ul> <li>json - default specialization</li> <li>ordered_json - a specialization that maintains the insertion order of object keys</li> </ul>"},{"location":"api/basic_json/#iterator-invalidation","title":"Iterator invalidation","text":"<p>All operations that add values to an array (<code>push_back</code> , <code>operator+=</code>, <code>emplace_back</code>, <code>insert</code>, and <code>operator[]</code> for a non-existing index) can yield a reallocation, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated.</p> <p>For <code>ordered_json</code>, also all operations that add a value to an object (<code>push_back</code>, <code>operator+=</code>, <code>emplace</code>, <code>insert</code>, <code>update</code>, and <code>operator[]</code> for a non-existing key) can yield a reallocation, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated.</p>"},{"location":"api/basic_json/#requirements","title":"Requirements","text":"<p>The class satisfies the following concept requirements:</p>"},{"location":"api/basic_json/#basic","title":"Basic","text":"<ul> <li>DefaultConstructible: JSON values can be   default-constructed. The result will be a JSON null value.</li> <li>MoveConstructible: A JSON value can be constructed   from an rvalue argument.</li> <li>CopyConstructible: A JSON value can be   copy-constructed from an lvalue expression.</li> <li>MoveAssignable: A JSON value can be assigned from an   rvalue argument.</li> <li>CopyAssignable: A JSON value can be copy-assigned from   an lvalue expression.</li> <li>Destructible: JSON values can be destructed.</li> </ul>"},{"location":"api/basic_json/#layout","title":"Layout","text":"<ul> <li>StandardLayoutType: JSON values have   standard layout: All non-static data   members are private and standard layout types, the class has no virtual functions or (virtual) base classes.</li> </ul>"},{"location":"api/basic_json/#library-wide","title":"Library-wide","text":"<ul> <li>EqualityComparable: JSON values can be compared with   <code>==</code>, see <code>operator==</code>.</li> <li>LessThanComparable: JSON values can be compared with   <code>&lt;</code>, see <code>operator&lt;</code>.</li> <li>Swappable: Any JSON lvalue or rvalue of can be swapped with   any lvalue or rvalue of other compatible types, using unqualified function <code>swap</code>.</li> <li>NullablePointer: JSON values can be compared against   <code>std::nullptr_t</code> objects which are used to model the <code>null</code> value.</li> </ul>"},{"location":"api/basic_json/#container","title":"Container","text":"<ul> <li>Container: JSON values can be used like STL containers and   provide iterator access.</li> <li>ReversibleContainer: JSON values can be used like   STL containers and provide reverse iterator access.</li> </ul>"},{"location":"api/basic_json/#member-types","title":"Member types","text":"<ul> <li>adl_serializer - the default serializer</li> <li>value_t - the JSON type enumeration</li> <li>json_pointer - JSON Pointer implementation</li> <li>json_serializer - type of the serializer to for conversions from/to JSON</li> <li>error_handler_t - type to choose behavior on decoding errors</li> <li>cbor_tag_handler_t - type to choose how to handle CBOR tags</li> <li>initializer_list_t - type for initializer lists of <code>basic_json</code> values</li> <li>input_format_t - type to choose the format to parse</li> <li>json_sax_t - type for SAX events</li> </ul>"},{"location":"api/basic_json/#exceptions","title":"Exceptions","text":"<ul> <li>exception - general exception of the <code>basic_json</code> class<ul> <li>parse_error - exception indicating a parse error</li> <li>invalid_iterator - exception indicating errors with iterators</li> <li>type_error - exception indicating executing a member function with a wrong type</li> <li>out_of_range - exception indicating access out of the defined range</li> <li>other_error - exception indicating other library errors</li> </ul> </li> </ul>"},{"location":"api/basic_json/#container-types","title":"Container types","text":"Type Definition <code>value_type</code> <code>basic_json</code> <code>reference</code> <code>value_type&amp;</code> <code>const_reference</code> <code>const value_type&amp;</code> <code>difference_type</code> <code>std::ptrdiff_t</code> <code>size_type</code> <code>std::size_t</code> <code>allocator_type</code> <code>AllocatorType&lt;basic_json&gt;</code> <code>pointer</code> <code>std::allocator_traits&lt;allocator_type&gt;::pointer</code> <code>const_pointer</code> <code>std::allocator_traits&lt;allocator_type&gt;::const_pointer</code> <code>iterator</code> LegacyBidirectionalIterator <code>const_iterator</code> constant LegacyBidirectionalIterator <code>reverse_iterator</code> reverse iterator, derived from <code>iterator</code> <code>const_reverse_iterator</code> reverse iterator, derived from <code>const_iterator</code> <code>iteration_proxy</code> helper type for <code>items</code> function"},{"location":"api/basic_json/#json-value-data-types","title":"JSON value data types","text":"<ul> <li>array_t - type for arrays</li> <li>binary_t - type for binary arrays</li> <li>boolean_t - type for booleans</li> <li>default_object_comparator_t - default comparator for objects</li> <li>number_float_t - type for numbers (floating-point)</li> <li>number_integer_t - type for numbers (integer)</li> <li>number_unsigned_t - type for numbers (unsigned)</li> <li>object_comparator_t - comparator for objects</li> <li>object_t - type for objects</li> <li>string_t - type for strings</li> </ul>"},{"location":"api/basic_json/#parser-callback","title":"Parser callback","text":"<ul> <li>parse_event_t - parser event types</li> <li>parser_callback_t - per-element parser callback type</li> </ul>"},{"location":"api/basic_json/#member-functions","title":"Member functions","text":"<ul> <li>(constructor)</li> <li>(destructor)</li> <li>operator= - copy assignment</li> <li>array (static) - explicitly create an array</li> <li>binary (static) - explicitly create a binary array</li> <li>object (static) - explicitly create an object</li> </ul>"},{"location":"api/basic_json/#object-inspection","title":"Object inspection","text":"<p>Functions to inspect the type of a JSON value.</p> <ul> <li>type - return the type of the JSON value</li> <li>operator value_t - return the type of the JSON value</li> <li>type_name - return the type as string</li> <li>is_primitive - return whether the type is primitive</li> <li>is_structured - return whether the type is structured</li> <li>is_null - return whether the value is null</li> <li>is_boolean - return whether the value is a boolean</li> <li>is_number - return whether the value is a number</li> <li>is_number_integer - return whether the value is an integer number</li> <li>is_number_unsigned - return whether the value is an unsigned integer number</li> <li>is_number_float - return whether the value is a floating-point number</li> <li>is_object - return whether the value is an object</li> <li>is_array - return whether the value is an array</li> <li>is_string - return whether the value is a string</li> <li>is_binary - return whether the value is a binary array</li> <li>is_discarded - return whether the value is discarded</li> </ul> <p>Optional functions to access the diagnostic positions.</p> <ul> <li>start_pos - return the start position of the value</li> <li>end_pos - return the one past the end position of the value</li> </ul>"},{"location":"api/basic_json/#value-access","title":"Value access","text":"<p>Direct access to the stored value of a JSON value.</p> <ul> <li>get - get a value</li> <li>get_to - get a value and write it to a destination</li> <li>get_ptr - get a pointer value</li> <li>get_ref - get a reference value</li> <li>operator ValueType - get a value</li> <li>get_binary - get a binary value</li> </ul>"},{"location":"api/basic_json/#element-access","title":"Element access","text":"<p>Access to the JSON value</p> <ul> <li>at - access specified element with bounds checking</li> <li>operator[] - access specified element</li> <li>value - access specified object element with default value</li> <li>front - access the first element</li> <li>back - access the last element</li> </ul>"},{"location":"api/basic_json/#lookup","title":"Lookup","text":"<ul> <li>find - find an element in a JSON object</li> <li>count - returns the number of occurrences of a key in a JSON object</li> <li>contains - check the existence of an element in a JSON object</li> </ul>"},{"location":"api/basic_json/#iterators","title":"Iterators","text":"<ul> <li>begin - returns an iterator to the first element</li> <li>cbegin - returns a const iterator to the first element</li> <li>end - returns an iterator to one past the last element</li> <li>cend - returns a const iterator to one past the last element</li> <li>rbegin - returns an iterator to the reverse-beginning</li> <li>rend - returns an iterator to the reverse-end</li> <li>crbegin - returns a const iterator to the reverse-beginning</li> <li>crend - returns a const iterator to the reverse-end</li> <li>items - wrapper to access iterator member functions in range-based for</li> </ul>"},{"location":"api/basic_json/#capacity","title":"Capacity","text":"<ul> <li>empty - checks whether the container is empty</li> <li>size - returns the number of elements</li> <li>max_size - returns the maximum possible number of elements</li> </ul>"},{"location":"api/basic_json/#modifiers","title":"Modifiers","text":"<ul> <li>clear - clears the contents</li> <li>push_back - add a value to an array/object</li> <li>operator+= - add a value to an array/object</li> <li>emplace_back - add a value to an array</li> <li>emplace - add a value to an object if a key does not exist</li> <li>erase - remove elements</li> <li>insert - inserts elements</li> <li>update - updates a JSON object from another object, overwriting existing keys </li> <li>swap - exchanges the values</li> </ul>"},{"location":"api/basic_json/#lexicographical-comparison-operators","title":"Lexicographical comparison operators","text":"<ul> <li>operator== - comparison: equal</li> <li>operator!= - comparison: not equal</li> <li>operator&lt; - comparison: less than</li> <li>operator&gt; - comparison: greater than</li> <li>operator&lt;= - comparison: less than or equal</li> <li>operator&gt;= - comparison: greater than or equal</li> <li>operator&lt;=&gt; - comparison: 3-way</li> </ul>"},{"location":"api/basic_json/#serialization-dumping","title":"Serialization / Dumping","text":"<ul> <li>dump - serialization</li> </ul>"},{"location":"api/basic_json/#deserialization-parsing","title":"Deserialization / Parsing","text":"<ul> <li>parse (static) - deserialize from a compatible input</li> <li>accept (static) - check if the input is valid JSON</li> <li>sax_parse (static) - generate SAX events</li> </ul>"},{"location":"api/basic_json/#json-pointer-functions","title":"JSON Pointer functions","text":"<ul> <li>flatten - return flattened JSON value</li> <li>unflatten - unflatten a previously flattened JSON value</li> </ul>"},{"location":"api/basic_json/#json-patch-functions","title":"JSON Patch functions","text":"<ul> <li>patch - applies a JSON patch</li> <li>patch_inplace - applies a JSON patch in place</li> <li>diff (static) - creates a diff as a JSON patch</li> </ul>"},{"location":"api/basic_json/#json-merge-patch-functions","title":"JSON Merge Patch functions","text":"<ul> <li>merge_patch - applies a JSON Merge Patch</li> </ul>"},{"location":"api/basic_json/#static-functions","title":"Static functions","text":"<ul> <li>meta - returns version information on the library</li> <li>get_allocator - returns the allocator associated with the container</li> </ul>"},{"location":"api/basic_json/#binary-formats","title":"Binary formats","text":"<ul> <li>from_bjdata (static) - create a JSON value from an input in BJData format</li> <li>from_bson (static) - create a JSON value from an input in BSON format</li> <li>from_cbor (static) - create a JSON value from an input in CBOR format</li> <li>from_msgpack (static) - create a JSON value from an input in MessagePack format</li> <li>from_ubjson (static) - create a JSON value from an input in UBJSON format</li> <li>to_bjdata (static) - create a BJData serialization of a given JSON value</li> <li>to_bson (static) - create a BSON serialization of a given JSON value</li> <li>to_cbor (static) - create a CBOR serialization of a given JSON value</li> <li>to_msgpack (static) - create a MessagePack serialization of a given JSON value</li> <li>to_ubjson (static) - create a UBJSON serialization of a given JSON value</li> </ul>"},{"location":"api/basic_json/#non-member-functions","title":"Non-member functions","text":"<ul> <li>operator&lt;&lt;(std::ostream&amp;) - serialize to stream</li> <li>operator&gt;&gt;(std::istream&amp;) - deserialize from stream</li> <li>to_string - user-defined <code>to_string</code> function for JSON values</li> </ul>"},{"location":"api/basic_json/#literals","title":"Literals","text":"<ul> <li>operator\"\"_json - user-defined string literal for JSON values</li> </ul>"},{"location":"api/basic_json/#helper-classes","title":"Helper classes","text":"<ul> <li>std::hash&lt;basic_json&gt; - return a hash value for a JSON object</li> <li>std::swap&lt;basic_json&gt; - exchanges the values of two JSON objects</li> </ul>"},{"location":"api/basic_json/#examples","title":"Examples","text":"Example <p>The example shows how the library is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j =\n    {\n        {\"pi\", 3.141},\n        {\"happy\", true},\n        {\"name\", \"Niels\"},\n        {\"nothing\", nullptr},\n        {\n            \"answer\", {\n                {\"everything\", 42}\n            }\n        },\n        {\"list\", {1, 0, 2}},\n        {\n            \"object\", {\n                {\"currency\", \"USD\"},\n                {\"value\", 42.99}\n            }\n        }\n    };\n\n    // add new values\n    j[\"new\"][\"key\"][\"value\"] = {\"another\", \"list\"};\n\n    // count elements\n    auto s = j.size();\n    j[\"size\"] = s;\n\n    // pretty print with indent of 4 spaces\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"answer\": {\n        \"everything\": 42\n    },\n    \"happy\": true,\n    \"list\": [\n        1,\n        0,\n        2\n    ],\n    \"name\": \"Niels\",\n    \"new\": {\n        \"key\": {\n            \"value\": [\n                \"another\",\n                \"list\"\n            ]\n        }\n    },\n    \"nothing\": null,\n    \"object\": {\n        \"currency\": \"USD\",\n        \"value\": 42.99\n    },\n    \"pi\": 3.141,\n    \"size\": 8\n}\n</code></pre>"},{"location":"api/basic_json/#see-also","title":"See also","text":"<ul> <li>RFC 8259: The JavaScript Object Notation (JSON) Data Interchange Format</li> </ul>"},{"location":"api/basic_json/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/accept/","title":"nlohmann::basic_json::accept","text":"<pre><code>// (1)\ntemplate&lt;typename InputType&gt;\nstatic bool accept(InputType&amp;&amp; i,\n                   const bool ignore_comments = false,\n                   const bool ignore_trailing_commas = false);\n\n// (2)\ntemplate&lt;typename IteratorType&gt;\nstatic bool accept(IteratorType first, IteratorType last,\n                   const bool ignore_comments = false,\n                   const bool ignore_trailing_commas = false);\n</code></pre> <p>Checks whether the input is valid JSON.</p> <ol> <li>Reads from a compatible input.</li> <li> <p>Reads from a pair of character iterators</p> <p>The value_type of the iterator must be an integral type with a size of 1, 2, or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16, and UTF-32.</p> </li> </ol> <p>Unlike the <code>parse()</code> function, this function neither throws an exception in case of invalid JSON input (i.e., a parse error) nor creates diagnostic information.</p>"},{"location":"api/basic_json/accept/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer (throws if null)</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters (throws if null)</li> <li>a <code>std::string</code></li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of iterators.</li> </ul> <code>IteratorType</code> <p>a compatible iterator type, for instance.</p> <ul> <li>a pair of <code>std::string::iterator</code> or <code>std::vector&lt;std::uint8_t&gt;::iterator</code></li> <li>a pair of pointers such as <code>ptr</code> and <code>ptr + len</code></li> </ul>"},{"location":"api/basic_json/accept/#parameters","title":"Parameters","text":"<code>i</code> (in) Input to parse from. <code>ignore_comments</code> (in) whether comments should be ignored and treated like whitespace (<code>true</code>) or yield a parse error (<code>false</code>); (optional, <code>false</code> by default) <code>ignore_trailing_commas</code> (in) whether trailing commas in arrays or objects should be ignored and treated like whitespace (<code>true</code>) or yield a parse error (<code>false</code>); (optional, <code>false</code> by default) <code>first</code> (in) iterator to the start of the character range <code>last</code> (in) iterator to the end of the character range"},{"location":"api/basic_json/accept/#return-value","title":"Return value","text":"<p>Whether the input is valid JSON.</p>"},{"location":"api/basic_json/accept/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/accept/#exceptions","title":"Exceptions","text":"<p>Throws <code>parse_error.101</code> in case of an empty input like a null <code>FILE*</code> or <code>char*</code> pointer.</p>"},{"location":"api/basic_json/accept/#complexity","title":"Complexity","text":"<p>Linear in the length of the input. The parser is a predictive LL(1) parser.</p>"},{"location":"api/basic_json/accept/#notes","title":"Notes","text":"<p>A UTF-8 byte order mark is silently ignored.</p>"},{"location":"api/basic_json/accept/#examples","title":"Examples","text":"Example <p>The example below demonstrates the <code>accept()</code> function reading from a string.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a valid JSON text\n    auto valid_text = R\"(\n    {\n        \"numbers\": [1, 2, 3]\n    }\n    )\";\n\n    // an invalid JSON text\n    auto invalid_text = R\"(\n    {\n        \"strings\": [\"extra\", \"comma\", ]\n    }\n    )\";\n\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; json::accept(valid_text) &lt;&lt; ' '\n              &lt;&lt; json::accept(invalid_text) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true false\n</code></pre>"},{"location":"api/basic_json/accept/#see-also","title":"See also","text":"<ul> <li>parse - deserialize from a compatible input</li> <li>operator&gt;&gt; - deserialize from stream</li> </ul>"},{"location":"api/basic_json/accept/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.0.0.</li> <li>Ignoring comments via <code>ignore_comments</code> added in version 3.9.0.</li> <li>Changed runtime assertion in case of <code>FILE*</code> null pointers to exception in version 3.12.0.</li> <li>Added <code>ignore_trailing_commas</code> in version 3.12.1.</li> </ul> <p>Deprecation</p> <p>Overload (2) replaces calls to <code>accept</code> with a pair of iterators as their first parameter which has been deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like <code>accept({ptr, ptr+len}, ...);</code> with <code>accept(ptr, ptr+len, ...);</code>.</p> <p>You should be warned by your compiler with a <code>-Wdeprecated-declarations</code> warning if you are using a deprecated function.</p>"},{"location":"api/basic_json/array/","title":"nlohmann::basic_json::array","text":"<pre><code>static basic_json array(initializer_list_t init = {});\n</code></pre> <p>Creates a JSON array value from a given initializer list. That is, given a list of values <code>a, b, c</code>, creates the JSON value <code>[a, b, c]</code>. If the initializer list is empty, the empty array <code>[]</code> is created.</p>"},{"location":"api/basic_json/array/#parameters","title":"Parameters","text":"<code>init</code> (in) initializer list with JSON values to create an array from (optional)"},{"location":"api/basic_json/array/#return-value","title":"Return value","text":"<p>JSON array value</p>"},{"location":"api/basic_json/array/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/array/#complexity","title":"Complexity","text":"<p>Linear in the size of <code>init</code>.</p>"},{"location":"api/basic_json/array/#notes","title":"Notes","text":"<p>This function is only needed to express two edge cases that cannot be realized with the initializer list constructor (<code>basic_json(initializer_list_t, bool, value_t)</code>). These cases are:</p> <ol> <li>creating an array whose elements are all pairs whose first element is a string -- in this case, the initializer list    constructor would create an object, taking the first elements as keys</li> <li>creating an empty array -- passing the empty initializer list to the initializer list constructor yields an empty    object</li> </ol>"},{"location":"api/basic_json/array/#examples","title":"Examples","text":"Example <p>The following code shows an example for the <code>array</code> function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON arrays\n    json j_no_init_list = json::array();\n    json j_empty_init_list = json::array({});\n    json j_nonempty_init_list = json::array({1, 2, 3, 4});\n    json j_list_of_pairs = json::array({ {\"one\", 1}, {\"two\", 2} });\n\n    // serialize the JSON arrays\n    std::cout &lt;&lt; j_no_init_list &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_empty_init_list &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_nonempty_init_list &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_list_of_pairs &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[]\n[]\n[1,2,3,4]\n[[\"one\",1],[\"two\",2]]\n</code></pre>"},{"location":"api/basic_json/array/#see-also","title":"See also","text":"<ul> <li><code>basic_json(initializer_list_t)</code> - create a JSON value from an initializer list</li> <li><code>object</code> - create a JSON object value from an initializer list</li> </ul>"},{"location":"api/basic_json/array/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/array_t/","title":"nlohmann::basic_json::array_t","text":"<pre><code>using array_t = ArrayType&lt;basic_json, AllocatorType&lt;basic_json&gt;&gt;;\n</code></pre> <p>The type used to store JSON arrays.</p> <p>RFC 8259 describes JSON arrays as follows:</p> <p>An array is an ordered sequence of zero or more values.</p> <p>To store objects in C++, a type is defined by the template parameters explained below.</p>"},{"location":"api/basic_json/array_t/#template-parameters","title":"Template parameters","text":"<code>ArrayType</code> container type to store arrays (e.g., <code>std::vector</code> or <code>std::list</code>) <code>AllocatorType</code> the allocator to use for objects (e.g., <code>std::allocator</code>)"},{"location":"api/basic_json/array_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/array_t/#default-type","title":"Default type","text":"<p>With the default values for <code>ArrayType</code> (<code>std::vector</code>) and <code>AllocatorType</code> (<code>std::allocator</code>), the default value for <code>array_t</code> is:</p> <pre><code>std::vector&lt;\n  basic_json, // value_type\n  std::allocator&lt;basic_json&gt; // allocator_type\n&gt;\n</code></pre>"},{"location":"api/basic_json/array_t/#limits","title":"Limits","text":"<p>RFC 8259 specifies:</p> <p>An implementation may set limits on the maximum depth of nesting.</p> <p>In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <code>max_size</code> function of a JSON array.</p>"},{"location":"api/basic_json/array_t/#storage","title":"Storage","text":"<p>Arrays are stored as pointers in a <code>basic_json</code> type. That is, for any access to array values, a pointer of type <code>array_t*</code> must be dereferenced.</p>"},{"location":"api/basic_json/array_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>array_t</code> is by default, a typedef to <code>std::vector&lt;nlohmann::json&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;std::vector&lt;json&gt;, json::array_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/array_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/at/","title":"nlohmann::basic_json::at","text":"<pre><code>// (1)\nreference at(size_type idx);\nconst_reference at(size_type idx) const;\n\n// (2)\nreference at(const typename object_t::key_type&amp; key);\nconst_reference at(const typename object_t::key_type&amp; key) const;\n\n// (3)\ntemplate&lt;typename KeyType&gt;\nreference at(KeyType&amp;&amp; key);\ntemplate&lt;typename KeyType&gt;\nconst_reference at(KeyType&amp;&amp; key) const;\n\n// (4)\nreference at(const json_pointer&amp; ptr);\nconst_reference at(const json_pointer&amp; ptr) const;\n</code></pre> <ol> <li>Returns a reference to the array element at specified location <code>idx</code>, with bounds checking.</li> <li>Returns a reference to the object element with specified key <code>key</code>, with bounds checking.</li> <li>See 2. This overload is only available if <code>KeyType</code> is comparable with <code>typename object_t::key_type</code> and    <code>typename object_comparator_t::is_transparent</code> denotes a type.</li> <li>Returns a reference to the element at specified JSON pointer <code>ptr</code>, with bounds checking.</li> </ol>"},{"location":"api/basic_json/at/#template-parameters","title":"Template parameters","text":"<code>KeyType</code> A type for an object key other than <code>json_pointer</code> that is comparable with <code>string_t</code> using  <code>object_comparator_t</code>. This can also be a string view (C++17)."},{"location":"api/basic_json/at/#parameters","title":"Parameters","text":"<code>idx</code> (in) index of the element to access <code>key</code> (in) object key of the elements to access <code>ptr</code> (in) JSON pointer to the desired element"},{"location":"api/basic_json/at/#return-value","title":"Return value","text":"<ol> <li>reference to the element at index <code>idx</code></li> <li>reference to the element at key <code>key</code></li> <li>reference to the element at key <code>key</code></li> <li>reference to the element pointed to by <code>ptr</code></li> </ol>"},{"location":"api/basic_json/at/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/at/#exceptions","title":"Exceptions","text":"<ol> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.304</code> if the JSON value is not an array;   in this case, calling <code>at</code> with an index makes no sense. See the example below.</li> <li>Throws <code>out_of_range.401</code> if the index <code>idx</code> is out of   range of the array; that is, <code>idx &gt;= size()</code>. See the example below.</li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.304</code> if the JSON value is not an object;   in this case, calling <code>at</code> with a key makes no sense. See the example below.</li> <li>Throws <code>out_of_range.403</code> if the key <code>key</code> is not   stored in the object; that is, <code>find(key) == end()</code>. See the example below.</li> </ul> </li> <li>See 2.</li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>parse_error.106</code> if an array index in the passed   JSON pointer <code>ptr</code> begins with '0'. See the example below.</li> <li>Throws <code>parse_error.109</code> if an array index in the passed   JSON pointer <code>ptr</code> is not a number. See the example below.</li> <li>Throws <code>out_of_range.401</code> if an array index in the passed   JSON pointer <code>ptr</code> is out of range. See the example below.</li> <li>Throws <code>out_of_range.402</code> if the array index '-' is used   in the passed JSON pointer <code>ptr</code>. As <code>at</code> provides checked access (and no elements are implicitly inserted), the   index '-' is always invalid. See the example below.</li> <li>Throws <code>out_of_range.403</code> if the JSON pointer describes a   key of an object which cannot be found. See the example below.</li> <li>Throws <code>out_of_range.404</code> if the JSON pointer <code>ptr</code> can   not be resolved. See the example below.</li> </ul> </li> </ol>"},{"location":"api/basic_json/at/#complexity","title":"Complexity","text":"<ol> <li>Constant.</li> <li>Logarithmic in the size of the container.</li> <li>Logarithmic in the size of the container.</li> <li>Logarithmic in the size of the container.</li> </ol>"},{"location":"api/basic_json/at/#examples","title":"Examples","text":"Example: (1) access specified array element with bounds checking <p>The example below shows how array elements can be read and written using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON array\n    json array = {\"first\", \"2nd\", \"third\", \"fourth\"};\n\n    // output element at index 2 (third element)\n    std::cout &lt;&lt; array.at(2) &lt;&lt; '\\n';\n\n    // change element at index 1 (second element) to \"second\"\n    array.at(1) = \"second\";\n\n    // output changed array\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n\n    // exception type_error.304\n    try\n    {\n        // use at() on a non-array type\n        json str = \"I am a string\";\n        str.at(0) = \"Another string\";\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // exception out_of_range.401\n    try\n    {\n        // try to write beyond the array limit\n        array.at(5) = \"sixth\";\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"third\"\n[\"first\",\"second\",\"third\",\"fourth\"]\n[json.exception.type_error.304] cannot use at() with string\n[json.exception.out_of_range.401] array index 5 is out of range\n</code></pre> Example: (1) access specified array element with bounds checking <p>The example below shows how array elements can be read using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON array\n    const json array = {\"first\", \"2nd\", \"third\", \"fourth\"};\n\n    // output element at index 2 (third element)\n    std::cout &lt;&lt; array.at(2) &lt;&lt; '\\n';\n\n    // exception type_error.304\n    try\n    {\n        // use at() on a non-array type\n        const json str = \"I am a string\";\n        std::cout &lt;&lt; str.at(0) &lt;&lt; '\\n';\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // exception out_of_range.401\n    try\n    {\n        // try to read beyond the array limit\n        std::cout &lt;&lt; array.at(5) &lt;&lt; '\\n';\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"third\"\n[json.exception.type_error.304] cannot use at() with string\n[json.exception.out_of_range.401] array index 5 is out of range\n</code></pre> Example: (2) access specified object element with bounds checking <p>The example below shows how object elements can be read and written using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON object\n    json object =\n    {\n        {\"the good\", \"il buono\"},\n        {\"the bad\", \"il cattivo\"},\n        {\"the ugly\", \"il brutto\"}\n    };\n\n    // output element with key \"the ugly\"\n    std::cout &lt;&lt; object.at(\"the ugly\") &lt;&lt; '\\n';\n\n    // change element with key \"the bad\"\n    object.at(\"the bad\") = \"il cattivo\";\n\n    // output changed array\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n\n    // exception type_error.304\n    try\n    {\n        // use at() on a non-object type\n        json str = \"I am a string\";\n        str.at(\"the good\") = \"Another string\";\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // exception out_of_range.401\n    try\n    {\n        // try to write at a nonexisting key\n        object.at(\"the fast\") = \"il rapido\";\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"il brutto\"\n{\"the bad\":\"il cattivo\",\"the good\":\"il buono\",\"the ugly\":\"il brutto\"}\n[json.exception.type_error.304] cannot use at() with string\n[json.exception.out_of_range.403] key 'the fast' not found\n</code></pre> Example: (2) access specified object element with bounds checking <p>The example below shows how object elements can be read using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON object\n    const json object =\n    {\n        {\"the good\", \"il buono\"},\n        {\"the bad\", \"il cattivo\"},\n        {\"the ugly\", \"il brutto\"}\n    };\n\n    // output element with key \"the ugly\"\n    std::cout &lt;&lt; object.at(\"the ugly\") &lt;&lt; '\\n';\n\n    // exception type_error.304\n    try\n    {\n        // use at() on a non-object type\n        const json str = \"I am a string\";\n        std::cout &lt;&lt; str.at(\"the good\") &lt;&lt; '\\n';\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // exception out_of_range.401\n    try\n    {\n        // try to read from a nonexisting key\n        std::cout &lt;&lt; object.at(\"the fast\") &lt;&lt; '\\n';\n    }\n    catch (const json::out_of_range)\n    {\n        std::cout &lt;&lt; \"out of range\" &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"il brutto\"\n[json.exception.type_error.304] cannot use at() with string\nout of range\n</code></pre> Example: (3) access specified object element using string_view with bounds checking <p>The example below shows how object elements can be read and written using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON object\n    json object =\n    {\n        {\"the good\", \"il buono\"},\n        {\"the bad\", \"il cattivo\"},\n        {\"the ugly\", \"il brutto\"}\n    };\n\n    // output element with key \"the ugly\" using string_view\n    std::cout &lt;&lt; object.at(\"the ugly\"sv) &lt;&lt; '\\n';\n\n    // change element with key \"the bad\" using string_view\n    object.at(\"the bad\"sv) = \"il cattivo\";\n\n    // output changed array\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n\n    // exception type_error.304\n    try\n    {\n        // use at() with string_view on a non-object type\n        json str = \"I am a string\";\n        str.at(\"the good\"sv) = \"Another string\";\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // exception out_of_range.401\n    try\n    {\n        // try to write at a nonexisting key using string_view\n        object.at(\"the fast\"sv) = \"il rapido\";\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"il brutto\"\n{\"the bad\":\"il cattivo\",\"the good\":\"il buono\",\"the ugly\":\"il brutto\"}\n[json.exception.type_error.304] cannot use at() with string\n[json.exception.out_of_range.403] key 'the fast' not found\n</code></pre> Example: (3) access specified object element using string_view with bounds checking <p>The example below shows how object elements can be read using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON object\n    const json object =\n    {\n        {\"the good\", \"il buono\"},\n        {\"the bad\", \"il cattivo\"},\n        {\"the ugly\", \"il brutto\"}\n    };\n\n    // output element with key \"the ugly\" using string_view\n    std::cout &lt;&lt; object.at(\"the ugly\"sv) &lt;&lt; '\\n';\n\n    // exception type_error.304\n    try\n    {\n        // use at() with string_view on a non-object type\n        const json str = \"I am a string\";\n        std::cout &lt;&lt; str.at(\"the good\"sv) &lt;&lt; '\\n';\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // exception out_of_range.401\n    try\n    {\n        // try to read from a nonexisting key using string_view\n        std::cout &lt;&lt; object.at(\"the fast\"sv) &lt;&lt; '\\n';\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; \"out of range\" &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"il brutto\"\n[json.exception.type_error.304] cannot use at() with string\nout of range\n</code></pre> Example: (4) access specified element via JSON Pointer <p>The example below shows how object elements can be read and written using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j =\n    {\n        {\"number\", 1}, {\"string\", \"foo\"}, {\"array\", {1, 2}}\n    };\n\n    // read-only access\n\n    // output element with JSON pointer \"/number\"\n    std::cout &lt;&lt; j.at(\"/number\"_json_pointer) &lt;&lt; '\\n';\n    // output element with JSON pointer \"/string\"\n    std::cout &lt;&lt; j.at(\"/string\"_json_pointer) &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array\"\n    std::cout &lt;&lt; j.at(\"/array\"_json_pointer) &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array/1\"\n    std::cout &lt;&lt; j.at(\"/array/1\"_json_pointer) &lt;&lt; '\\n';\n\n    // writing access\n\n    // change the string\n    j.at(\"/string\"_json_pointer) = \"bar\";\n    // output the changed string\n    std::cout &lt;&lt; j[\"string\"] &lt;&lt; '\\n';\n\n    // change an array element\n    j.at(\"/array/1\"_json_pointer) = 21;\n    // output the changed array\n    std::cout &lt;&lt; j[\"array\"] &lt;&lt; '\\n';\n\n    // out_of_range.106\n    try\n    {\n        // try to use an array index with leading '0'\n        json::reference ref = j.at(\"/array/01\"_json_pointer);\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.109\n    try\n    {\n        // try to use an array index that is not a number\n        json::reference ref = j.at(\"/array/one\"_json_pointer);\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.401\n    try\n    {\n        // try to use an invalid array index\n        json::reference ref = j.at(\"/array/4\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.402\n    try\n    {\n        // try to use the array index '-'\n        json::reference ref = j.at(\"/array/-\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.403\n    try\n    {\n        // try to use a JSON pointer to a nonexistent object key\n        json::const_reference ref = j.at(\"/foo\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.404\n    try\n    {\n        // try to use a JSON pointer that cannot be resolved\n        json::reference ref = j.at(\"/number/foo\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1\n\"foo\"\n[1,2]\n2\n\"bar\"\n[1,21]\n[json.exception.parse_error.106] parse error: array index '01' must not begin with '0'\n[json.exception.parse_error.109] parse error: array index 'one' is not a number\n[json.exception.out_of_range.401] array index 4 is out of range\n[json.exception.out_of_range.402] array index '-' (2) is out of range\n[json.exception.out_of_range.403] key 'foo' not found\n[json.exception.out_of_range.404] unresolved reference token 'foo'\n</code></pre> Example: (4) access specified element via JSON Pointer <p>The example below shows how object elements can be read using <code>at()</code>. It also demonstrates the different exceptions that can be thrown.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    const json j =\n    {\n        {\"number\", 1}, {\"string\", \"foo\"}, {\"array\", {1, 2}}\n    };\n\n    // read-only access\n\n    // output element with JSON pointer \"/number\"\n    std::cout &lt;&lt; j.at(\"/number\"_json_pointer) &lt;&lt; '\\n';\n    // output element with JSON pointer \"/string\"\n    std::cout &lt;&lt; j.at(\"/string\"_json_pointer) &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array\"\n    std::cout &lt;&lt; j.at(\"/array\"_json_pointer) &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array/1\"\n    std::cout &lt;&lt; j.at(\"/array/1\"_json_pointer) &lt;&lt; '\\n';\n\n    // out_of_range.109\n    try\n    {\n        // try to use an array index that is not a number\n        json::const_reference ref = j.at(\"/array/one\"_json_pointer);\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.401\n    try\n    {\n        // try to use an invalid array index\n        json::const_reference ref = j.at(\"/array/4\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.402\n    try\n    {\n        // try to use the array index '-'\n        json::const_reference ref = j.at(\"/array/-\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.403\n    try\n    {\n        // try to use a JSON pointer to a nonexistent object key\n        json::const_reference ref = j.at(\"/foo\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // out_of_range.404\n    try\n    {\n        // try to use a JSON pointer that cannot be resolved\n        json::const_reference ref = j.at(\"/number/foo\"_json_pointer);\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1\n\"foo\"\n[1,2]\n2\n[json.exception.parse_error.109] parse error: array index 'one' is not a number\n[json.exception.out_of_range.401] array index 4 is out of range\n[json.exception.out_of_range.402] array index '-' (2) is out of range\n[json.exception.out_of_range.403] key 'foo' not found\n[json.exception.out_of_range.404] unresolved reference token 'foo'\n</code></pre>"},{"location":"api/basic_json/at/#see-also","title":"See also","text":"<ul> <li>documentation on checked access</li> <li><code>operator[]</code> for unchecked access by reference</li> <li><code>value</code> for access with default value</li> </ul>"},{"location":"api/basic_json/at/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0.</li> <li>Added in version 1.0.0.</li> <li>Added in version 3.11.0.</li> <li>Added in version 2.0.0.</li> </ol>"},{"location":"api/basic_json/back/","title":"nlohmann::basic_json::back","text":"<pre><code>reference back();\n\nconst_reference back() const;\n</code></pre> <p>Returns a reference to the last element in the container. For a JSON container <code>c</code>, the expression <code>c.back()</code> is equivalent to</p> <pre><code>auto tmp = c.end();\n--tmp;\nreturn *tmp;\n</code></pre>"},{"location":"api/basic_json/back/#return-value","title":"Return value","text":"<p>In the case of a structured type (array or object), a reference to the last element is returned. In the case of number, string, boolean, or binary values, a reference to the value is returned.</p>"},{"location":"api/basic_json/back/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/back/#exceptions","title":"Exceptions","text":"<p>If the JSON value is <code>null</code>, exception <code>invalid_iterator.214</code> is thrown.</p>"},{"location":"api/basic_json/back/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/back/#notes","title":"Notes","text":"<p>Precondition</p> <p>The array or object must not be empty. Calling <code>back</code> on an empty array or object yields undefined behavior.</p>"},{"location":"api/basic_json/back/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>back()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_object_empty(json::value_t::object);\n    json j_array = {1, 2, 4, 8, 16};\n    json j_array_empty(json::value_t::array);\n    json j_string = \"Hello, world\";\n\n    // call back()\n    std::cout &lt;&lt; j_boolean.back() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.back() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.back() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.back() &lt;&lt; '\\n';\n    //std::cout &lt;&lt; j_object_empty.back() &lt;&lt; '\\n';  // undefined behavior\n    std::cout &lt;&lt; j_array.back() &lt;&lt; '\\n';\n    //std::cout &lt;&lt; j_array_empty.back() &lt;&lt; '\\n';   // undefined behavior\n    std::cout &lt;&lt; j_string.back() &lt;&lt; '\\n';\n\n    // back() called on a null value\n    try\n    {\n        json j_null;\n        j_null.back();\n    }\n    catch (const json::invalid_iterator&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>true\n17\n23.42\n2\n16\n\"Hello, world\"\n[json.exception.invalid_iterator.214] cannot get value\n</code></pre>"},{"location":"api/basic_json/back/#see-also","title":"See also","text":"<ul> <li>front to access the first element</li> </ul>"},{"location":"api/basic_json/back/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Adjusted code to return reference to binary values in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/basic_json/","title":"nlohmann::basic_json::basic_json","text":"<pre><code>// (1)\nbasic_json(const value_t v);\n\n// (2)\nbasic_json(std::nullptr_t = nullptr) noexcept;\n\n// (3)\ntemplate&lt;typename CompatibleType&gt;\nbasic_json(CompatibleType&amp;&amp; val) noexcept(noexcept(\n           JSONSerializer&lt;U&gt;::to_json(std::declval&lt;basic_json_t&amp;&gt;(),\n                                      std::forward&lt;CompatibleType&gt;(val))));\n\n// (4)\ntemplate&lt;typename BasicJsonType&gt;\nbasic_json(const BasicJsonType&amp; val);\n\n// (5)\nbasic_json(initializer_list_t init,\n           bool type_deduction = true,\n           value_t manual_type = value_t::array);\n\n// (6)\nbasic_json(size_type cnt, const basic_json&amp; val);\n\n// (7)\nbasic_json(iterator first, iterator last);\nbasic_json(const_iterator first, const_iterator last);\n\n// (8)\nbasic_json(const basic_json&amp; other);\n\n// (9)\nbasic_json(basic_json&amp;&amp; other) noexcept;\n</code></pre> <ol> <li> <p>Create an empty JSON value with a given type. The value will be default initialized with an empty value which depends    on the type:</p> Value type initial value null <code>null</code> boolean <code>false</code> string <code>\"\"</code> number <code>0</code> object <code>{}</code> array <code>[]</code> binary empty array <p>The postcondition of this constructor can be restored by calling <code>clear()</code>.</p> </li> <li> <p>Create a <code>null</code> JSON value. It either takes a null pointer as parameter (explicitly creating <code>null</code>)    or no parameter (implicitly creating <code>null</code>). The passed null pointer itself is not read -- it is only used to    choose the right constructor.</p> </li> <li> <p>This is a \"catch all\" constructor for all compatible JSON types; that is, types for which a <code>to_json()</code> method    exists. The constructor forwards the parameter <code>val</code> to that method (to <code>json_serializer&lt;U&gt;::to_json</code> method with    <code>U = uncvref_t&lt;CompatibleType&gt;</code>, to be exact).</p> <p>Template type <code>CompatibleType</code> includes, but is not limited to, the following types:</p> <ul> <li>arrays: <code>array_t</code> and all kinds of compatible containers such as <code>std::vector</code>, <code>std::deque</code>,  <code>std::list</code>, <code>std::forward_list</code>, <code>std::array</code>, <code>std::valarray</code>, <code>std::set</code>, <code>std::unordered_set</code>, <code>std::multiset</code>,  and <code>std::unordered_multiset</code> with a <code>value_type</code> from which a <code>basic_json</code> value can be constructed.</li> <li>objects: <code>object_t</code> and all kinds of compatible associative containers such as <code>std::map</code>,  <code>std::unordered_map</code>, <code>std::multimap</code>, and <code>std::unordered_multimap</code> with a <code>key_type</code> compatible to <code>string_t</code>  and a <code>value_type</code> from which a <code>basic_json</code> value can be constructed.</li> <li>strings: <code>string_t</code>, string literals, and all compatible string containers can be used.</li> <li>numbers: <code>number_integer_t</code>, <code>number_unsigned_t</code>,  <code>number_float_t</code>, and all convertible number types such as <code>int</code>, <code>size_t</code>, <code>int64_t</code>, <code>float</code>  or <code>double</code> can be used.</li> <li>boolean: <code>boolean_t</code> / <code>bool</code> can be used.</li> <li>binary: <code>binary_t</code> / <code>std::vector&lt;uint8_t&gt;</code> may be used; unfortunately because string literals cannot be  distinguished from binary character arrays by the C++ type system, all types compatible with <code>const char*</code> will be  directed to the string constructor instead. This is both for backwards compatibility and due to the fact that a  binary type is not a standard JSON type.</li> </ul> <p>See the examples below.</p> </li> <li> <p>This is a constructor for existing <code>basic_json</code> types. It does not hijack copy/move constructors, since the parameter    has different template arguments than the current ones.</p> <p>The constructor tries to convert the internal <code>m_value</code> of the parameter.</p> </li> <li> <p>Creates a JSON value of type array or object from the passed initializer list <code>init</code>. In case <code>type_deduction</code> is    <code>true</code> (default), the type of the JSON value to be created is deducted from the initializer list <code>init</code>    according to the following rules:</p> <ol> <li>If the list is empty, an empty JSON object value <code>{}</code> is created.</li> <li>If the list consists of pairs whose first element is a string, a JSON object value is created where the first   elements of the pairs are treated as keys and the second elements are as values.</li> <li>In all other cases, an array is created.</li> </ol> <p>The rules aim to create the best fit between a C++ initializer list and JSON values. The rationale is as follows:</p> <ol> <li>The empty initializer list is written as <code>{}</code> which is exactly an empty JSON object.</li> <li>C++ has no way of describing mapped types other than to list a list of pairs. As JSON requires that keys must be    of type string, rule 2 is the weakest constraint one can pose on initializer lists to interpret them as an    object.</li> <li>In all other cases, the initializer list could not be interpreted as a JSON object type, so interpreting it as a    JSON array type is safe.</li> </ol> <p>With the rules described above, the following JSON values cannot be expressed by an initializer list:</p> <ul> <li>the empty array (<code>[]</code>): use <code>array(initializer_list_t)</code> with an empty initializer list in this case</li> <li>arrays whose elements satisfy rule 2: use <code>array(initializer_list_t)</code> with the same initializer list in this case</li> </ul> <p>Function <code>array()</code> and <code>object()</code> force array and object creation from initializer lists, respectively.</p> </li> <li> <p>Constructs a JSON array value by creating <code>cnt</code> copies of a passed value. In case <code>cnt</code> is <code>0</code>, an empty array is    created.</p> </li> <li> <p>Constructs the JSON value with the contents of the range <code>[first, last)</code>. The semantics depend on the different    types a JSON value can have:</p> <ul> <li>In case of a <code>null</code> type, invalid_iterator.206   is thrown.</li> <li>In case of other primitive types (number, boolean, or string), <code>first</code> must be <code>begin()</code> and <code>last</code> must be   <code>end()</code>. In this case, the value is copied. Otherwise,   <code>invalid_iterator.204</code> is thrown.</li> <li>In case of structured types (array, object), the constructor behaves as similar versions for <code>std::vector</code> or   <code>std::map</code>; that is, a JSON array or object is constructed from the values in the range.</li> </ul> </li> <li> <p>Creates a copy of a given JSON value.</p> </li> <li> <p>Move constructor. Constructs a JSON value with the contents of the given value <code>other</code> using move semantics. It    \"steals\" the resources from <code>other</code> and leaves it as JSON <code>null</code> value.</p> </li> </ol>"},{"location":"api/basic_json/basic_json/#template-parameters","title":"Template parameters","text":"<code>CompatibleType</code> <p>a type such that:</p> <ul> <li><code>CompatibleType</code> is not derived from <code>std::istream</code>,</li> <li><code>CompatibleType</code> is not <code>basic_json</code> (to avoid hijacking copy/move constructors),</li> <li><code>CompatibleType</code> is not a different <code>basic_json</code> type (i.e. with different template arguments)</li> <li><code>CompatibleType</code> is not a <code>basic_json</code> nested type (e.g., <code>json_pointer</code>, <code>iterator</code>, etc.)</li> <li><code>json_serializer&lt;U&gt;</code> (with <code>U = uncvref_t&lt;CompatibleType&gt;</code>) has a <code>to_json(basic_json_t&amp;, CompatibleType&amp;&amp;)</code>    method</li> </ul> <code>BasicJsonType</code>: <p>a type such that:</p> <ul> <li><code>BasicJsonType</code> is a <code>basic_json</code> type.</li> <li><code>BasicJsonType</code> has different template arguments than <code>basic_json_t</code>.</li> </ul> <code>U</code>: <code>uncvref_t&lt;CompatibleType&gt;</code>"},{"location":"api/basic_json/basic_json/#parameters","title":"Parameters","text":"<code>v</code> (in) the type of the value to create <code>val</code> (in) the value to be forwarded to the respective constructor <code>init</code> (in) initializer list with JSON values <code>type_deduction</code> (in) internal parameter; when set to <code>true</code>, the type of the JSON value is deducted from the initializer list <code>init</code>; when set to <code>false</code>, the type provided via <code>manual_type</code> is forced. This mode is used by the functions <code>array(initializer_list_t)</code> and <code>object(initializer_list_t)</code>. <code>manual_type</code> (in) internal parameter; when <code>type_deduction</code> is set to <code>false</code>, the created JSON value will use the provided type (only <code>value_t::array</code> and <code>value_t::object</code> are valid); when <code>type_deduction</code> is set to <code>true</code>, this parameter has no effect <code>cnt</code> (in) the number of JSON copies of <code>val</code> to create <code>first</code> (in) the beginning of the range to copy from (included) <code>last</code> (in) the end of the range to copy from (excluded) <code>other</code> (in) the JSON value to copy/move"},{"location":"api/basic_json/basic_json/#exception-safety","title":"Exception safety","text":"<ol> <li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li> <li>No-throw guarantee: this constructor never throws exceptions.</li> <li>Depends on the called constructor. For types directly supported by the library (i.e., all types for which no    <code>to_json()</code> function was provided), a strong guarantee holds: if an exception is thrown, there are no changes to any    JSON value.</li> <li>Depends on the called constructor. For types directly supported by the library (i.e., all types for which no    <code>to_json()</code> function was provided), a strong guarantee holds: if an exception is thrown, there are no changes to any    JSON value.</li> <li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li> <li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li> <li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li> <li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li> <li>No-throw guarantee: this constructor never throws exceptions.</li> </ol>"},{"location":"api/basic_json/basic_json/#exceptions","title":"Exceptions","text":"<ol> <li>(none)</li> <li>The function does not throw exceptions.</li> <li>(none)</li> <li>(none)</li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.301</code> if <code>type_deduction</code> is   <code>false</code>, <code>manual_type</code> is <code>value_t::object</code>, but <code>init</code> contains an element which is not a pair whose first   element is a string. In this case, the constructor could not create an object. If <code>type_deduction</code> would have been   <code>true</code>, an array would have been created. See <code>object(initializer_list_t)</code> for an example.</li> </ul> </li> <li>(none)</li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>invalid_iterator.201</code> if iterators <code>first</code>   and <code>last</code> are not compatible (i.e., do not belong to the same JSON value). In this case, the range   <code>[first, last)</code> is undefined.</li> <li>Throws <code>invalid_iterator.204</code> if iterators <code>first</code>   and <code>last</code> belong to a primitive type (number, boolean, or string), but <code>first</code> does not point to the first   element anymore. In this case, the range <code>[first, last)</code> is undefined. See the example code below.</li> <li>Throws <code>invalid_iterator.206</code> if iterators <code>first</code>   and <code>last</code> belong to a <code>null</code> value. In this case, the range <code>[first, last)</code> is undefined.</li> </ul> </li> <li>(none)</li> <li>The function does not throw exceptions.</li> </ol>"},{"location":"api/basic_json/basic_json/#complexity","title":"Complexity","text":"<ol> <li>Constant.</li> <li>Constant.</li> <li>Usually linear in the size of the passed <code>val</code>, also depending on the implementation of the called <code>to_json()</code>    method.</li> <li>Usually linear in the size of the passed <code>val</code>, also depending on the implementation of the called <code>to_json()</code>    method.</li> <li>Linear in the size of the initializer list <code>init</code>.</li> <li>Linear in <code>cnt</code>.</li> <li>Linear in distance between <code>first</code> and <code>last</code>.</li> <li>Linear in the size of <code>other</code>.</li> <li>Constant.</li> </ol>"},{"location":"api/basic_json/basic_json/#notes","title":"Notes","text":"<ul> <li> <p>Overload 5:</p> <p>Empty initializer list</p> <p>When used without parentheses around an empty initializer list, <code>basic_json()</code> is called instead of this function, yielding the JSON <code>null</code> value.</p> </li> <li> <p>Overload 7:</p> <p>Preconditions</p> <ul> <li>Iterators <code>first</code> and <code>last</code> must be initialized. **This precondition is enforced with a   runtime assertion.</li> <li>Range <code>[first, last)</code> is valid. Usually, this precondition cannot be checked efficiently. Only certain edge   cases are detected; see the description of the exceptions above. A violation of this precondition yields   undefined behavior.</li> </ul> <p>Runtime assertion</p> <p>A precondition is enforced with a runtime assertion.</p> </li> <li> <p>Overload 8:</p> <p>Postcondition</p> <p><code>*this == other</code></p> </li> <li> <p>Overload 9:</p> <p>Postconditions</p> <ul> <li><code>`*this</code> has the same value as <code>other</code> before the call.</li> <li><code>other</code> is a JSON <code>null</code> value</li> </ul> </li> </ul>"},{"location":"api/basic_json/basic_json/#examples","title":"Examples","text":"Example: (1) create an empty value with a given type <p>The following code shows the constructor for different <code>value_t</code> values.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create the different JSON values with default values\n    json j_null(json::value_t::null);\n    json j_boolean(json::value_t::boolean);\n    json j_number_integer(json::value_t::number_integer);\n    json j_number_float(json::value_t::number_float);\n    json j_object(json::value_t::object);\n    json j_array(json::value_t::array);\n    json j_string(json::value_t::string);\n\n    // serialize the JSON values\n    std::cout &lt;&lt; j_null &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>null\nfalse\n0\n0.0\n{}\n[]\n\"\"\n</code></pre> Example: (2) create a <code>null</code> object <p>The following code shows the constructor with and without a null pointer parameter.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // implicitly create a JSON null value\n    json j1;\n\n    // explicitly create a JSON null value\n    json j2(nullptr);\n\n    // serialize the JSON null value\n    std::cout &lt;&lt; j1 &lt;&lt; '\\n' &lt;&lt; j2 &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>null\nnull\n</code></pre> Example: (3) create a JSON value from compatible types <p>The following code shows the constructor with several compatible types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n#include &lt;list&gt;\n#include &lt;forward_list&gt;\n#include &lt;set&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;valarray&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // ============\n    // object types\n    // ============\n\n    // create an object from an object_t value\n    json::object_t object_value = { {\"one\", 1}, {\"two\", 2} };\n    json j_object_t(object_value);\n\n    // create an object from std::map\n    std::map&lt;std::string, int&gt; c_map\n    {\n        {\"one\", 1}, {\"two\", 2}, {\"three\", 3}\n    };\n    json j_map(c_map);\n\n    // create an object from std::unordered_map\n    std::unordered_map&lt;const char*, double&gt; c_umap\n    {\n        {\"one\", 1.2}, {\"two\", 2.3}, {\"three\", 3.4}\n    };\n    json j_umap(c_umap);\n\n    // create an object from std::multimap\n    std::multimap&lt;std::string, bool&gt; c_mmap\n    {\n        {\"one\", true}, {\"two\", true}, {\"three\", false}, {\"three\", true}\n    };\n    json j_mmap(c_mmap); // only one entry for key \"three\" is used\n\n    // create an object from std::unordered_multimap\n    std::unordered_multimap&lt;std::string, bool&gt; c_ummap\n    {\n        {\"one\", true}, {\"two\", true}, {\"three\", false}, {\"three\", true}\n    };\n    json j_ummap(c_ummap); // only one entry for key \"three\" is used\n\n    // serialize the JSON objects\n    std::cout &lt;&lt; j_object_t &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_map &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_umap &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_mmap &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_ummap &lt;&lt; \"\\n\\n\";\n\n    // ===========\n    // array types\n    // ===========\n\n    // create an array from an array_t value\n    json::array_t array_value = {\"one\", \"two\", 3, 4.5, false};\n    json j_array_t(array_value);\n\n    // create an array from std::vector\n    std::vector&lt;int&gt; c_vector {1, 2, 3, 4};\n    json j_vec(c_vector);\n\n    // create an array from std::valarray\n    std::valarray&lt;short&gt; c_valarray {10, 9, 8, 7};\n    json j_valarray(c_valarray);\n\n    // create an array from std::deque\n    std::deque&lt;double&gt; c_deque {1.2, 2.3, 3.4, 5.6};\n    json j_deque(c_deque);\n\n    // create an array from std::list\n    std::list&lt;bool&gt; c_list {true, true, false, true};\n    json j_list(c_list);\n\n    // create an array from std::forward_list\n    std::forward_list&lt;std::int64_t&gt; c_flist {12345678909876, 23456789098765, 34567890987654, 45678909876543};\n    json j_flist(c_flist);\n\n    // create an array from std::array\n    std::array&lt;unsigned long, 4&gt; c_array {{1, 2, 3, 4}};\n    json j_array(c_array);\n\n    // create an array from std::set\n    std::set&lt;std::string&gt; c_set {\"one\", \"two\", \"three\", \"four\", \"one\"};\n    json j_set(c_set); // only one entry for \"one\" is used\n\n    // create an array from std::unordered_set\n    std::unordered_set&lt;std::string&gt; c_uset {\"one\", \"two\", \"three\", \"four\", \"one\"};\n    json j_uset(c_uset); // only one entry for \"one\" is used\n\n    // create an array from std::multiset\n    std::multiset&lt;std::string&gt; c_mset {\"one\", \"two\", \"one\", \"four\"};\n    json j_mset(c_mset); // both entries for \"one\" are used\n\n    // create an array from std::unordered_multiset\n    std::unordered_multiset&lt;std::string&gt; c_umset {\"one\", \"two\", \"one\", \"four\"};\n    json j_umset(c_umset); // both entries for \"one\" are used\n\n    // serialize the JSON arrays\n    std::cout &lt;&lt; j_array_t &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_vec &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_valarray &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_deque &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_list &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_flist &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_set &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_uset &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_mset &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_umset &lt;&lt; \"\\n\\n\";\n\n    // ============\n    // string types\n    // ============\n\n    // create string from a string_t value\n    json::string_t string_value = \"The quick brown fox jumps over the lazy dog.\";\n    json j_string_t(string_value);\n\n    // create a JSON string directly from a string literal\n    json j_string_literal(\"The quick brown fox jumps over the lazy dog.\");\n\n    // create string from std::string\n    std::string s_stdstring = \"The quick brown fox jumps over the lazy dog.\";\n    json j_stdstring(s_stdstring);\n\n    // serialize the JSON strings\n    std::cout &lt;&lt; j_string_t &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string_literal &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_stdstring &lt;&lt; \"\\n\\n\";\n\n    // ============\n    // number types\n    // ============\n\n    // create a JSON number from number_integer_t\n    json::number_integer_t value_integer_t = -42;\n    json j_integer_t(value_integer_t);\n\n    // create a JSON number from number_unsigned_t\n    json::number_integer_t value_unsigned_t = 17;\n    json j_unsigned_t(value_unsigned_t);\n\n    // create a JSON number from an anonymous enum\n    enum { enum_value = 17 };\n    json j_enum(enum_value);\n\n    // create values of different integer types\n    short n_short = 42;\n    int n_int = -23;\n    long n_long = 1024;\n    int_least32_t n_int_least32_t = -17;\n    uint8_t n_uint8_t = 8;\n\n    // create (integer) JSON numbers\n    json j_short(n_short);\n    json j_int(n_int);\n    json j_long(n_long);\n    json j_int_least32_t(n_int_least32_t);\n    json j_uint8_t(n_uint8_t);\n\n    // create values of different floating-point types\n    json::number_float_t v_ok = 3.141592653589793;\n    json::number_float_t v_nan = NAN;\n    json::number_float_t v_infinity = INFINITY;\n\n    // create values of different floating-point types\n    float n_float = 42.23;\n    float n_float_nan = 1.0f / 0.0f;\n    double n_double = 23.42;\n\n    // create (floating point) JSON numbers\n    json j_ok(v_ok);\n    json j_nan(v_nan);\n    json j_infinity(v_infinity);\n    json j_float(n_float);\n    json j_float_nan(n_float_nan);\n    json j_double(n_double);\n\n    // serialize the JSON numbers\n    std::cout &lt;&lt; j_integer_t &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_unsigned_t &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_enum &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_short &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_int &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_long &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_int_least32_t &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_uint8_t &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_ok &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_nan &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_infinity &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_float &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_float_nan &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_double &lt;&lt; \"\\n\\n\";\n\n    // =============\n    // boolean types\n    // =============\n\n    // create boolean values\n    json j_truth = true;\n    json j_falsity = false;\n\n    // serialize the JSON booleans\n    std::cout &lt;&lt; j_truth &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_falsity &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\n{\"one\":1,\"three\":3,\"two\":2}\n{\"one\":1.2,\"three\":3.4,\"two\":2.3}\n{\"one\":true,\"three\":false,\"two\":true}\n{\"one\":true,\"three\":false,\"two\":true}\n\n[\"one\",\"two\",3,4.5,false]\n[1,2,3,4]\n[10,9,8,7]\n[1.2,2.3,3.4,5.6]\n[true,true,false,true]\n[12345678909876,23456789098765,34567890987654,45678909876543]\n[1,2,3,4]\n[\"four\",\"one\",\"three\",\"two\"]\n[\"four\",\"three\",\"two\",\"one\"]\n[\"four\",\"one\",\"one\",\"two\"]\n[\"four\",\"two\",\"one\",\"one\"]\n\n\"The quick brown fox jumps over the lazy dog.\"\n\"The quick brown fox jumps over the lazy dog.\"\n\"The quick brown fox jumps over the lazy dog.\"\n\n-42\n17\n17\n42\n-23\n1024\n-17\n8\n3.141592653589793\nnull\nnull\n42.22999954223633\nnull\n23.42\n\ntrue\nfalse\n</code></pre> <p>Note the output is platform-dependent.</p> Example: (5) create a container (array or object) from an initializer list <p>The example below shows how JSON values are created from initializer lists.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_empty_init_list = json({});\n    json j_object = { {\"one\", 1}, {\"two\", 2} };\n    json j_array = {1, 2, 3, 4};\n    json j_nested_object = { {\"one\", {1}}, {\"two\", {1, 2}} };\n    json j_nested_array = { {{1}, \"one\"}, {{1, 2}, \"two\"} };\n\n    // serialize the JSON value\n    std::cout &lt;&lt; j_empty_init_list &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_nested_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_nested_array &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{}\n{\"one\":1,\"two\":2}\n[1,2,3,4]\n{\"one\":[1],\"two\":[1,2]}\n[[[1],\"one\"],[[1,2],\"two\"]]\n</code></pre> Example: (6) construct an array with count copies of a given value <p>The following code shows examples for creating arrays with several copies of a given value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array by creating copies of a JSON value\n    json value = \"Hello\";\n    json array_0 = json(0, value);\n    json array_1 = json(1, value);\n    json array_5 = json(5, value);\n\n    // serialize the JSON arrays\n    std::cout &lt;&lt; array_0 &lt;&lt; '\\n';\n    std::cout &lt;&lt; array_1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; array_5 &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[]\n[\"Hello\"]\n[\"Hello\",\"Hello\",\"Hello\",\"Hello\",\"Hello\"]\n</code></pre> Example: (7) construct a JSON container given an iterator range <p>The example below shows several ways to create JSON values by specifying a subrange with iterators.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_array = {\"alpha\", \"bravo\", \"charly\", \"delta\", \"easy\"};\n    json j_number = 42;\n    json j_object = {{\"one\", \"eins\"}, {\"two\", \"zwei\"}};\n\n    // create copies using iterators\n    json j_array_range(j_array.begin() + 1, j_array.end() - 2);\n    json j_number_range(j_number.begin(), j_number.end());\n    json j_object_range(j_object.begin(), j_object.find(\"two\"));\n\n    // serialize the values\n    std::cout &lt;&lt; j_array_range &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_range &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object_range &lt;&lt; '\\n';\n\n    // example for an exception\n    try\n    {\n        json j_invalid(j_number.begin() + 1, j_number.end());\n    }\n    catch (const json::invalid_iterator&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[\"bravo\",\"charly\"]\n42\n{\"one\":\"eins\"}\n[json.exception.invalid_iterator.204] iterators out of range\n</code></pre> Example: (8) copy constructor <p>The following code shows an example for the copy constructor.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON array\n    json j1 = {\"one\", \"two\", 3, 4.5, false};\n\n    // create a copy\n    json j2(j1);\n\n    // serialize the JSON array\n    std::cout &lt;&lt; j1 &lt;&lt; \" = \" &lt;&lt; j2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (j1 == j2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[\"one\",\"two\",3,4.5,false] = [\"one\",\"two\",3,4.5,false]\ntrue\n</code></pre> Example: (9) move constructor <p>The code below shows the move constructor explicitly called via <code>std::move</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON value\n    json a = 23;\n\n    // move contents of a to b\n    json b(std::move(a));\n\n    // serialize the JSON arrays\n    std::cout &lt;&lt; a &lt;&lt; '\\n';\n    std::cout &lt;&lt; b &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>null\n23\n</code></pre>"},{"location":"api/basic_json/basic_json/#version-history","title":"Version history","text":"<ol> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 2.1.0.</li> <li>Since version 3.2.0.</li> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> </ol>"},{"location":"api/basic_json/begin/","title":"nlohmann::basic_json::begin","text":"<pre><code>iterator begin() noexcept;\nconst_iterator begin() const noexcept;\n</code></pre> <p>Returns an iterator to the first element.</p> <p></p>"},{"location":"api/basic_json/begin/#return-value","title":"Return value","text":"<p>iterator to the first element</p>"},{"location":"api/basic_json/begin/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/begin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/begin/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>begin()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to the first element\n    json::iterator it = array.begin();\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>1\n</code></pre>"},{"location":"api/basic_json/begin/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/binary/","title":"nlohmann::basic_json::binary","text":"<pre><code>// (1)\nstatic basic_json binary(const typename binary_t::container_type&amp; init);\nstatic basic_json binary(typename binary_t::container_type&amp;&amp; init);\n\n// (2)\nstatic basic_json binary(const typename binary_t::container_type&amp; init,\n                         std::uint8_t subtype);\nstatic basic_json binary(typename binary_t::container_type&amp;&amp; init,\n                         std::uint8_t subtype);\n</code></pre> <ol> <li>Creates a JSON binary array value from a given binary container.</li> <li>Creates a JSON binary array value from a given binary container with subtype.</li> </ol> <p>Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>"},{"location":"api/basic_json/binary/#parameters","title":"Parameters","text":"<code>init</code> (in) container containing bytes to use as a binary type <code>subtype</code> (in) subtype to use in CBOR, MessagePack, and BSON"},{"location":"api/basic_json/binary/#return-value","title":"Return value","text":"<p>JSON binary array value</p>"},{"location":"api/basic_json/binary/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/binary/#complexity","title":"Complexity","text":"<p>Linear in the size of <code>init</code>; constant for <code>typename binary_t::container_type&amp;&amp; init</code> versions.</p>"},{"location":"api/basic_json/binary/#notes","title":"Notes","text":"<p>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension, it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</p>"},{"location":"api/basic_json/binary/#examples","title":"Examples","text":"Example <p>The following code shows how to create a binary value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a binary vector\n    std::vector&lt;std::uint8_t&gt; vec = {0xCA, 0xFE, 0xBA, 0xBE};\n\n    // create a binary JSON value with subtype 42\n    json j = json::binary(vec, 42);\n\n    // output type and subtype\n    std::cout &lt;&lt; \"type: \" &lt;&lt; j.type_name() &lt;&lt; \", subtype: \" &lt;&lt; j.get_binary().subtype() &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>type: binary, subtype: 42\n</code></pre>"},{"location":"api/basic_json/binary/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/binary_t/","title":"nlohmann::basic_json::binary_t","text":"<pre><code>using binary_t = byte_container_with_subtype&lt;BinaryType&gt;;\n</code></pre> <p>This type is a type designed to carry binary data that appears in various serialized formats, such as CBOR's Major Type 2, MessagePack's bin, and BSON's generic binary subtype. This type is NOT a part of standard JSON and exists solely for compatibility with these binary types. As such, it is simply defined as an ordered sequence of zero or more byte values.</p> <p>Additionally, as an implementation detail, the subtype of the binary data is carried around as a <code>std::uint64_t</code>, which is compatible with both of the binary data formats that use binary subtyping, (though the specific numbering is incompatible with each other, and it is up to the user to translate between them). The subtype is added to <code>BinaryType</code> via the helper type byte_container_with_subtype.</p> <p>CBOR's RFC 7049 describes this type as:</p> <p>Major type 2: a byte string. The string's length in bytes is represented following the rules for positive integers (major type 0).</p> <p>MessagePack's documentation on the bin type family describes this type as:</p> <p>Bin format family stores a byte array in 2, 3, or 5 bytes of extra bytes in addition to the size of the byte array.</p> <p>BSON's specifications describe several binary types; however, this type is intended to represent the generic binary type which has the description:</p> <p>Generic binary subtype - This is the most commonly used binary subtype and should be the 'default' for drivers and tools.</p> <p>None of these impose any limitations on the internal representation other than the basic unit of storage be some type of array whose parts are decomposable into bytes.</p> <p>The default representation of this binary format is a <code>std::vector&lt;std::uint8_t&gt;</code>, which is a very common way to represent a byte array in modern C++.</p>"},{"location":"api/basic_json/binary_t/#template-parameters","title":"Template parameters","text":"<code>BinaryType</code> container type to store arrays"},{"location":"api/basic_json/binary_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/binary_t/#default-type","title":"Default type","text":"<p>The default values for <code>BinaryType</code> is <code>std::vector&lt;std::uint8_t&gt;</code>.</p>"},{"location":"api/basic_json/binary_t/#storage","title":"Storage","text":"<p>Binary Arrays are stored as pointers in a <code>basic_json</code> type. That is, for any access to array values, a pointer of the type <code>binary_t*</code> must be dereferenced.</p>"},{"location":"api/basic_json/binary_t/#notes-on-subtypes","title":"Notes on subtypes","text":"<ul> <li> <p>CBOR</p> <ul> <li>Binary values are represented as byte strings. Subtypes are written as tags.</li> </ul> </li> <li> <p>MessagePack</p> <ul> <li>If a subtype is given and the binary array contains exactly 1, 2, 4, 8, or 16 elements, the fixext family (fixext1,   fixext2, fixext4, fixext8) is used. For other sizes, the ext family (ext8, ext16, ext32) is used. The subtype is   then added as a signed 8-bit integer.</li> <li>If no subtype is given, the bin family (bin8, bin16, bin32) is used.</li> </ul> </li> <li> <p>BSON</p> <ul> <li>If a subtype is given, it is used and added as an unsigned 8-bit integer.</li> <li>If no subtype is given, the generic binary subtype 0x00 is used.</li> </ul> </li> </ul>"},{"location":"api/basic_json/binary_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>binary_t</code> is by default, a typedef to <code>nlohmann::byte_container_with_subtype&lt;std::vector&lt;std::uint8_t&gt;&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;nlohmann::byte_container_with_subtype&lt;std::vector&lt;std::uint8_t&gt;&gt;, json::binary_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/binary_t/#see-also","title":"See also","text":"<ul> <li>byte_container_with_subtype</li> </ul>"},{"location":"api/basic_json/binary_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.8.0. Changed the type of subtype to <code>std::uint64_t</code> in version 3.10.0.</li> </ul>"},{"location":"api/basic_json/boolean_t/","title":"nlohmann::basic_json::boolean_t","text":"<pre><code>using boolean_t = BooleanType;\n</code></pre> <p>The type used to store JSON booleans.</p> <p>RFC 8259 implicitly describes a boolean as a type which differentiates the two literals <code>true</code> and <code>false</code>.</p> <p>To store objects in C++, a type is defined by the template parameter  <code>BooleanType</code> which chooses the type to use.</p>"},{"location":"api/basic_json/boolean_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/boolean_t/#default-type","title":"Default type","text":"<p>With the default values for <code>BooleanType</code> (<code>bool</code>), the default value for <code>boolean_t</code> is <code>bool</code>.</p>"},{"location":"api/basic_json/boolean_t/#storage","title":"Storage","text":"<p>Boolean values are stored directly inside a <code>basic_json</code> type.</p>"},{"location":"api/basic_json/boolean_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>boolean_t</code> is by default, a typedef to <code>bool</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;bool, json::boolean_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/boolean_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/cbegin/","title":"nlohmann::basic_json::cbegin","text":"<pre><code>const_iterator cbegin() const noexcept;\n</code></pre> <p>Returns an iterator to the first element.</p> <p></p>"},{"location":"api/basic_json/cbegin/#return-value","title":"Return value","text":"<p>iterator to the first element</p>"},{"location":"api/basic_json/cbegin/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/cbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/cbegin/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>cbegin()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    const json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to the first element\n    json::const_iterator it = array.cbegin();\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>1\n</code></pre>"},{"location":"api/basic_json/cbegin/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/cbor_tag_handler_t/","title":"nlohmann::basic_json::cbor_tag_handler_t","text":"<pre><code>enum class cbor_tag_handler_t\n{\n    error,\n    ignore,\n    store\n};\n</code></pre> <p>This enumeration is used in the <code>from_cbor</code> function to choose how to treat tags:</p> error throw a <code>parse_error</code> exception in case of a tag ignore ignore tags store store tagged values as binary container with subtype (for bytes 0xd8..0xdb)"},{"location":"api/basic_json/cbor_tag_handler_t/#examples","title":"Examples","text":"Example <p>The example below shows how the different values of the <code>cbor_tag_handler_t</code> influence the behavior of <code>from_cbor</code> when reading a tagged byte string.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // tagged byte string\n    std::vector&lt;std::uint8_t&gt; vec = {{0xd8, 0x42, 0x44, 0xcA, 0xfe, 0xba, 0xbe}};\n\n    // cbor_tag_handler_t::error throws\n    try\n    {\n        auto b_throw_on_tag = json::from_cbor(vec, true, true, json::cbor_tag_handler_t::error);\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // cbor_tag_handler_t::ignore ignores the tag\n    auto b_ignore_tag = json::from_cbor(vec, true, true, json::cbor_tag_handler_t::ignore);\n    std::cout &lt;&lt; b_ignore_tag &lt;&lt; std::endl;\n\n    // cbor_tag_handler_t::store stores the tag as binary subtype\n    auto b_store_tag = json::from_cbor(vec, true, true, json::cbor_tag_handler_t::store);\n    std::cout &lt;&lt; b_store_tag &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.112] parse error at byte 1: syntax error while parsing CBOR value: invalid byte: 0xD8\n{\"bytes\":[202,254,186,190],\"subtype\":null}\n{\"bytes\":[202,254,186,190],\"subtype\":66}\n</code></pre>"},{"location":"api/basic_json/cbor_tag_handler_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.9.0. Added value <code>store</code> in 3.10.0.</li> </ul>"},{"location":"api/basic_json/cend/","title":"nlohmann::basic_json::cend","text":"<pre><code>const_iterator cend() const noexcept;\n</code></pre> <p>Returns an iterator to one past the last element.</p> <p></p>"},{"location":"api/basic_json/cend/#return-value","title":"Return value","text":"<p>iterator one past the last element</p>"},{"location":"api/basic_json/cend/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/cend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/cend/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>cend()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to one past the last element\n    json::const_iterator it = array.cend();\n\n    // decrement the iterator to point to the last element\n    --it;\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>5\n</code></pre>"},{"location":"api/basic_json/cend/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/clear/","title":"nlohmann::basic_json::clear","text":"<pre><code>void clear() noexcept;\n</code></pre> <p>Clears the content of a JSON value and resets it to the default value as if <code>basic_json(value_t)</code> would have been called with the current value type from <code>type()</code>:</p> Value type initial value null <code>null</code> boolean <code>false</code> string <code>\"\"</code> number <code>0</code> binary An empty byte vector object <code>{}</code> array <code>[]</code> <p>Has the same effect as calling</p> <pre><code>*this = basic_json(type());\n</code></pre>"},{"location":"api/basic_json/clear/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/clear/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value.</p>"},{"location":"api/basic_json/clear/#notes","title":"Notes","text":"<p>All iterators, pointers, and references related to this container are invalidated.</p>"},{"location":"api/basic_json/clear/#examples","title":"Examples","text":"Example <p>The example below shows the effect of <code>clear()</code> to different JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call clear()\n    j_null.clear();\n    j_boolean.clear();\n    j_number_integer.clear();\n    j_number_float.clear();\n    j_object.clear();\n    j_array.clear();\n    j_string.clear();\n\n    // serialize the cleared values()\n    std::cout &lt;&lt; j_null &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>null\nfalse\n0\n0.0\n{}\n[]\n\"\"\n</code></pre>"},{"location":"api/basic_json/clear/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Added support for binary types in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/contains/","title":"nlohmann::basic_json::contains","text":"<pre><code>// (1)\nbool contains(const typename object_t::key_type&amp; key) const;\n\n// (2)\ntemplate&lt;typename KeyType&gt;\nbool contains(KeyType&amp;&amp; key) const;\n\n// (3)\nbool contains(const json_pointer&amp; ptr) const;\n</code></pre> <ol> <li>Check whether an element exists in a JSON object with a key equivalent to <code>key</code>. If the element is not found or the     JSON value is not an object, <code>false</code> is returned.</li> <li>See 1. This overload is only available if <code>KeyType</code> is comparable with <code>typename object_t::key_type</code> and    <code>typename object_comparator_t::is_transparent</code> denotes a type.</li> <li>Check whether the given JSON pointer <code>ptr</code> can be resolved in the current JSON value.</li> </ol>"},{"location":"api/basic_json/contains/#template-parameters","title":"Template parameters","text":"<code>KeyType</code> A type for an object key other than <code>json_pointer</code> that is comparable with <code>string_t</code> using  <code>object_comparator_t</code>. This can also be a string view (C++17)."},{"location":"api/basic_json/contains/#parameters","title":"Parameters","text":"<code>key</code> (in) key value to check its existence. <code>ptr</code> (in) JSON pointer to check its existence."},{"location":"api/basic_json/contains/#return-value","title":"Return value","text":"<ol> <li><code>true</code> if an element with specified <code>key</code> exists. If no such element with such a key is found or the JSON value    is not an object, <code>false</code> is returned.</li> <li>See 1.</li> <li><code>true</code> if the JSON pointer can be resolved to a stored value, <code>false</code> otherwise.</li> </ol>"},{"location":"api/basic_json/contains/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/contains/#exceptions","title":"Exceptions","text":"<ol> <li>The function does not throw exceptions.</li> <li>The function does not throw exceptions.</li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>parse_error.106</code> if an array index begins with   <code>0</code>.</li> <li>Throws <code>parse_error.109</code> if an array index was not a   number.</li> </ul> </li> </ol>"},{"location":"api/basic_json/contains/#complexity","title":"Complexity","text":"<p>Logarithmic in the size of the JSON object.</p>"},{"location":"api/basic_json/contains/#notes","title":"Notes","text":"<ul> <li>This method always returns <code>false</code> when executed on a JSON type that is not an object.</li> <li>This method can be executed on any JSON value type.</li> </ul> <p>Postconditions</p> <p>If <code>j.contains(x)</code> returns <code>true</code> for a key or JSON pointer <code>x</code>, then it is safe to call <code>j[x]</code>.</p>"},{"location":"api/basic_json/contains/#examples","title":"Examples","text":"Example: (1) check with key <p>The example shows how <code>contains()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create some JSON values\n    json j_object = R\"( {\"key\": \"value\"} )\"_json;\n    json j_array = R\"( [1, 2, 3] )\"_json;\n\n    // call contains\n    std::cout &lt;&lt; std::boolalpha &lt;&lt;\n              \"j_object contains 'key': \" &lt;&lt; j_object.contains(\"key\") &lt;&lt; '\\n' &lt;&lt;\n              \"j_object contains 'another': \" &lt;&lt; j_object.contains(\"another\") &lt;&lt; '\\n' &lt;&lt;\n              \"j_array contains 'key': \" &lt;&lt; j_array.contains(\"key\") &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>j_object contains 'key': true\nj_object contains 'another': false\nj_array contains 'key': false\n</code></pre> Example: (2) check with key using string_view <p>The example shows how <code>contains()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create some JSON values\n    json j_object = R\"( {\"key\": \"value\"} )\"_json;\n    json j_array = R\"( [1, 2, 3] )\"_json;\n\n    // call contains\n    std::cout &lt;&lt; std::boolalpha &lt;&lt;\n              \"j_object contains 'key': \" &lt;&lt; j_object.contains(\"key\"sv) &lt;&lt; '\\n' &lt;&lt;\n              \"j_object contains 'another': \" &lt;&lt; j_object.contains(\"another\"sv) &lt;&lt; '\\n' &lt;&lt;\n              \"j_array contains 'key': \" &lt;&lt; j_array.contains(\"key\"sv) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>j_object contains 'key': true\nj_object contains 'another': false\nj_array contains 'key': false\n</code></pre> Example: (3) check with JSON pointer <p>The example shows how <code>contains()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j =\n    {\n        {\"number\", 1}, {\"string\", \"foo\"}, {\"array\", {1, 2}}\n    };\n\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; j.contains(\"/number\"_json_pointer) &lt;&lt; '\\n'\n              &lt;&lt; j.contains(\"/string\"_json_pointer) &lt;&lt; '\\n'\n              &lt;&lt; j.contains(\"/array\"_json_pointer) &lt;&lt; '\\n'\n              &lt;&lt; j.contains(\"/array/1\"_json_pointer) &lt;&lt; '\\n'\n              &lt;&lt; j.contains(\"/array/-\"_json_pointer) &lt;&lt; '\\n'\n              &lt;&lt; j.contains(\"/array/4\"_json_pointer) &lt;&lt; '\\n'\n              &lt;&lt; j.contains(\"/baz\"_json_pointer) &lt;&lt; std::endl;\n\n    try\n    {\n        // try to use an array index with leading '0'\n        j.contains(\"/array/01\"_json_pointer);\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    try\n    {\n        // try to use an array index that is not a number\n        j.contains(\"/array/one\"_json_pointer);\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>true\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/contains/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.11.0.</li> <li>Added in version 3.6.0. Extended template <code>KeyType</code> to support comparable types in version 3.11.0.</li> <li>Added in version 3.7.0.</li> </ol>"},{"location":"api/basic_json/count/","title":"nlohmann::basic_json::count","text":"<pre><code>// (1)\nsize_type count(const typename object_t::key_type&amp; key) const;\n\n// (2)\ntemplate&lt;typename KeyType&gt;\nsize_type count(KeyType&amp;&amp; key) const;\n</code></pre> <ol> <li>Returns the number of elements with key <code>key</code>. If <code>ObjectType</code> is the default <code>std::map</code> type, the return value will    always be <code>0</code> (<code>key</code> was not found) or <code>1</code> (<code>key</code> was found).</li> <li>See 1. This overload is only available if <code>KeyType</code> is comparable with <code>typename object_t::key_type</code> and    <code>typename object_comparator_t::is_transparent</code> denotes a type.</li> </ol>"},{"location":"api/basic_json/count/#template-parameters","title":"Template parameters","text":"<code>KeyType</code> A type for an object key other than <code>json_pointer</code> that is comparable with <code>string_t</code> using  <code>object_comparator_t</code>. This can also be a string view (C++17)."},{"location":"api/basic_json/count/#parameters","title":"Parameters","text":"<code>key</code> (in) key value of the element to count."},{"location":"api/basic_json/count/#return-value","title":"Return value","text":"<p>Number of elements with key <code>key</code>. If the JSON value is not an object, the return value will be <code>0</code>.</p>"},{"location":"api/basic_json/count/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/count/#complexity","title":"Complexity","text":"<p>Logarithmic in the size of the JSON object.</p>"},{"location":"api/basic_json/count/#notes","title":"Notes","text":"<p>This method always returns <code>0</code> when executed on a JSON type that is not an object.</p>"},{"location":"api/basic_json/count/#examples","title":"Examples","text":"Example: (1) count number of elements <p>The example shows how <code>count()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n\n    // call count()\n    auto count_two = j_object.count(\"two\");\n    auto count_three = j_object.count(\"three\");\n\n    // print values\n    std::cout &lt;&lt; \"number of elements with key \\\"two\\\": \" &lt;&lt; count_two &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"number of elements with key \\\"three\\\": \" &lt;&lt; count_three &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>number of elements with key \"two\": 1\nnumber of elements with key \"three\": 0\n</code></pre> Example: (2) count number of elements using string_view <p>The example shows how <code>count()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n\n    // call count()\n    auto count_two = j_object.count(\"two\"sv);\n    auto count_three = j_object.count(\"three\"sv);\n\n    // print values\n    std::cout &lt;&lt; \"number of elements with key \\\"two\\\": \" &lt;&lt; count_two &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"number of elements with key \\\"three\\\": \" &lt;&lt; count_three &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>number of elements with key \"two\": 1\nnumber of elements with key \"three\": 0\n</code></pre>"},{"location":"api/basic_json/count/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.11.0.</li> <li>Added in version 1.0.0. Changed parameter <code>key</code> type to <code>KeyType&amp;&amp;</code> in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/crbegin/","title":"nlohmann::basic_json::crbegin","text":"<pre><code>const_reverse_iterator crbegin() const noexcept;\n</code></pre> <p>Returns an iterator to the reverse-beginning; that is, the last element.</p> <p></p>"},{"location":"api/basic_json/crbegin/#return-value","title":"Return value","text":"<p>reverse iterator to the first element</p>"},{"location":"api/basic_json/crbegin/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/crbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/crbegin/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>crbegin()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to the reverse-beginning\n    json::const_reverse_iterator it = array.crbegin();\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>5\n</code></pre>"},{"location":"api/basic_json/crbegin/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/crend/","title":"nlohmann::basic_json::crend","text":"<pre><code>const_reverse_iterator crend() const noexcept;\n</code></pre> <p>Returns an iterator to the reverse-end; that is, one before the first element. This element acts as a placeholder, attempting to access it results in undefined behavior.</p> <p></p>"},{"location":"api/basic_json/crend/#return-value","title":"Return value","text":"<p>reverse iterator to the element following the last element</p>"},{"location":"api/basic_json/crend/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/crend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/crend/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>eend()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to the reverse-end\n    json::const_reverse_iterator it = array.crend();\n\n    // increment the iterator to point to the first element\n    --it;\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>1\n</code></pre>"},{"location":"api/basic_json/crend/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/default_object_comparator_t/","title":"nlohmann::basic_json::default_object_comparator_t","text":"<pre><code>using default_object_comparator_t = std::less&lt;StringType&gt;;  // until C++14\n\nusing default_object_comparator_t = std::less&lt;&gt;;            // since C++14\n</code></pre> <p>The default comparator used by <code>object_t</code>.</p> <p>Since C++14 a transparent comparator is used which prevents unnecessary string construction when looking up a key in an object.</p> <p>The actual comparator used depends on <code>object_t</code> and can be obtained via <code>object_comparator_t</code>.</p>"},{"location":"api/basic_json/default_object_comparator_t/#examples","title":"Examples","text":"Example <p>The example below demonstrates the default comparator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"one &lt; two : \" &lt;&lt; json::default_object_comparator_t{}(\"one\", \"two\") &lt;&lt; \"\\n\"\n              &lt;&lt; \"three &lt; four : \" &lt;&lt; json::default_object_comparator_t{}(\"three\", \"four\") &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>one &lt; two : true\nthree &lt; four : false\n</code></pre>"},{"location":"api/basic_json/default_object_comparator_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/basic_json/diff/","title":"nlohmann::basic_json::diff","text":"<pre><code>static basic_json diff(const basic_json&amp; source,\n                       const basic_json&amp; target);\n</code></pre> <p>Creates a JSON Patch so that value <code>source</code> can be changed into the value <code>target</code> by calling <code>patch</code> function.</p> <p>For two JSON values <code>source</code> and <code>target</code>, the following code yields always <code>true</code>: <pre><code>source.patch(diff(source, target)) == target;\n</code></pre></p>"},{"location":"api/basic_json/diff/#parameters","title":"Parameters","text":"<code>source</code> (in) JSON value to compare from <code>target</code> (in) JSON value to compare against"},{"location":"api/basic_json/diff/#return-value","title":"Return value","text":"<p>a JSON patch to convert the <code>source</code> to <code>target</code></p>"},{"location":"api/basic_json/diff/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/diff/#complexity","title":"Complexity","text":"<p>Linear in the lengths of <code>source</code> and <code>target</code>.</p>"},{"location":"api/basic_json/diff/#notes","title":"Notes","text":"<p>Currently, only <code>remove</code>, <code>add</code>, and <code>replace</code> operations are generated.</p>"},{"location":"api/basic_json/diff/#examples","title":"Examples","text":"Example <p>The following code shows how a JSON patch is created as a diff for two JSON values.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // the source document\n    json source = R\"(\n        {\n            \"baz\": \"qux\",\n            \"foo\": \"bar\"\n        }\n    )\"_json;\n\n    // the target document\n    json target = R\"(\n        {\n            \"baz\": \"boo\",\n            \"hello\": [\n                \"world\"\n            ]\n        }\n    )\"_json;\n\n    // create the patch\n    json patch = json::diff(source, target);\n\n    // roundtrip\n    json patched_source = source.patch(patch);\n\n    // output patch and roundtrip result\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; patch &lt;&lt; \"\\n\\n\"\n              &lt;&lt; std::setw(4) &lt;&lt; patched_source &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>[\n    {\n        \"op\": \"replace\",\n        \"path\": \"/baz\",\n        \"value\": \"boo\"\n    },\n    {\n        \"op\": \"remove\",\n        \"path\": \"/foo\"\n    },\n    {\n        \"op\": \"add\",\n        \"path\": \"/hello\",\n        \"value\": [\n            \"world\"\n        ]\n    }\n]\n\n{\n    \"baz\": \"boo\",\n    \"hello\": [\n        \"world\"\n    ]\n}\n</code></pre>"},{"location":"api/basic_json/diff/#see-also","title":"See also","text":"<ul> <li>RFC 6902 (JSON Patch)</li> </ul>"},{"location":"api/basic_json/diff/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> </ul>"},{"location":"api/basic_json/dump/","title":"nlohmann::basic_json::dump","text":"<pre><code>string_t dump(const int indent = -1,\n              const char indent_char = ' ',\n              const bool ensure_ascii = false,\n              const error_handler_t error_handler = error_handler_t::strict) const;\n</code></pre> <p>Serialization function for JSON values. The function tries to mimic Python's <code>json.dumps()</code> function, and currently supports its <code>indent</code> and <code>ensure_ascii</code> parameters.</p>"},{"location":"api/basic_json/dump/#parameters","title":"Parameters","text":"<code>indent</code> (in) If <code>indent</code> is nonnegative, then array elements and object members will be pretty-printed with that indent level. An indent level of <code>0</code> will only insert newlines. <code>-1</code> (the default) selects the most compact representation. <code>indent_char</code> (in) The character to use for indentation if <code>indent</code> is greater than <code>0</code>. The default is <code></code> (space). <code>ensure_ascii</code> (in) If <code>ensure_ascii</code> is true, all non-ASCII characters in the output are escaped with <code>\\uXXXX</code> sequences, and the result consists of ASCII characters only. <code>error_handler</code> (in) how to react on decoding errors; there are three possible values (see <code>error_handler_t</code>: <code>strict</code> (throws and exception in case a decoding error occurs; default), <code>replace</code> (replace invalid UTF-8 sequences with U+FFFD), and <code>ignore</code> (ignore invalid UTF-8 sequences during serialization; all bytes are copied to the output unchanged))."},{"location":"api/basic_json/dump/#return-value","title":"Return value","text":"<p>string containing the serialization of the JSON value</p>"},{"location":"api/basic_json/dump/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</p>"},{"location":"api/basic_json/dump/#exceptions","title":"Exceptions","text":"<p>Throws <code>type_error.316</code> if a string stored inside the JSON value is not UTF-8 encoded and <code>error_handler</code> is set to <code>strict</code></p>"},{"location":"api/basic_json/dump/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/dump/#notes","title":"Notes","text":"<p>Binary values are serialized as an object containing two keys:</p> <ul> <li>\"bytes\": an array of bytes as integers</li> <li>\"subtype\": the subtype as integer or <code>null</code> if the binary has no subtype</li> </ul>"},{"location":"api/basic_json/dump/#examples","title":"Examples","text":"Example <p>The following example shows the effect of different <code>indent</code>, <code>indent_char</code>, and <code>ensure_ascii</code> parameters to the result of the serialization.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hell\u00f6 \ud83d\ude00!\";\n\n    // call dump()\n    std::cout &lt;&lt; \"objects:\" &lt;&lt; '\\n'\n              &lt;&lt; j_object.dump() &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_object.dump(-1) &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_object.dump(0) &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_object.dump(4) &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_object.dump(1, '\\t') &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"arrays:\" &lt;&lt; '\\n'\n              &lt;&lt; j_array.dump() &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_array.dump(-1) &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_array.dump(0) &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_array.dump(4) &lt;&lt; \"\\n\\n\"\n              &lt;&lt; j_array.dump(1, '\\t') &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"strings:\" &lt;&lt; '\\n'\n              &lt;&lt; j_string.dump() &lt;&lt; '\\n'\n              &lt;&lt; j_string.dump(-1, ' ', true) &lt;&lt; '\\n';\n\n    // create JSON value with invalid UTF-8 byte sequence\n    json j_invalid = \"\u00e4\\xA9\u00fc\";\n    try\n    {\n        std::cout &lt;&lt; j_invalid.dump() &lt;&lt; std::endl;\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"string with replaced invalid characters: \"\n              &lt;&lt; j_invalid.dump(-1, ' ', false, json::error_handler_t::replace)\n              &lt;&lt; \"\\nstring with ignored invalid characters: \"\n              &lt;&lt; j_invalid.dump(-1, ' ', false, json::error_handler_t::ignore)\n              &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>objects:\n{\"one\":1,\"two\":2}\n\n{\"one\":1,\"two\":2}\n\n{\n\"one\": 1,\n\"two\": 2\n}\n\n{\n    \"one\": 1,\n    \"two\": 2\n}\n\n{\n    \"one\": 1,\n    \"two\": 2\n}\n\narrays:\n[1,2,4,8,16]\n\n[1,2,4,8,16]\n\n[\n1,\n2,\n4,\n8,\n16\n]\n\n[\n    1,\n    2,\n    4,\n    8,\n    16\n]\n\n[\n    1,\n    2,\n    4,\n    8,\n    16\n]\n\nstrings:\n\"Hell\u00f6 \ud83d\ude00!\"\n\"Hell\\u00f6 \\ud83d\\ude00!\"\n[json.exception.type_error.316] invalid UTF-8 byte at index 2: 0xA9\nstring with replaced invalid characters: \"\u00e4\ufffd\u00fc\"\nstring with ignored invalid characters: \"\u00e4\u00fc\"\n</code></pre>"},{"location":"api/basic_json/dump/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Indentation character <code>indent_char</code>, option <code>ensure_ascii</code> and exceptions added in version 3.0.0.</li> <li>Error handlers added in version 3.4.0.</li> <li>Serialization of binary values added in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/emplace/","title":"nlohmann::basic_json::emplace","text":"<pre><code>template&lt;class... Args&gt;\nstd::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp; ... args);\n</code></pre> <p>Inserts a new element into a JSON object constructed in-place with the given <code>args</code> if there is no element with the key in the container. If the function is called on a JSON null value, an empty object is created before appending the value created from <code>args</code>.</p>"},{"location":"api/basic_json/emplace/#template-parameters","title":"Template parameters","text":"<code>Args</code> compatible types to create a <code>basic_json</code> object"},{"location":"api/basic_json/emplace/#iterator-invalidation","title":"Iterator invalidation","text":"<p>For <code>ordered_json</code>, adding a value to an object can yield a reallocation, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated.</p>"},{"location":"api/basic_json/emplace/#parameters","title":"Parameters","text":"<code>args</code> (in) arguments to forward to a constructor of <code>basic_json</code>"},{"location":"api/basic_json/emplace/#return-value","title":"Return value","text":"<p>a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a <code>bool</code> denoting whether the insertion took place.</p>"},{"location":"api/basic_json/emplace/#exceptions","title":"Exceptions","text":"<p>Throws <code>type_error.311</code> when called on a type other than JSON object or <code>null</code>; example: <code>\"cannot use emplace() with number\"</code></p>"},{"location":"api/basic_json/emplace/#complexity","title":"Complexity","text":"<p>Logarithmic in the size of the container, O(log(<code>size()</code>)).</p>"},{"location":"api/basic_json/emplace/#examples","title":"Examples","text":"Example <p>The example shows how <code>emplace()</code> can be used to add elements to a JSON object. Note how the <code>null</code> value was silently converted to a JSON object. Further note how no value is added if there was already one value stored with the same key.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json object = {{\"one\", 1}, {\"two\", 2}};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values\n    auto res1 = object.emplace(\"three\", 3);\n    null.emplace(\"A\", \"a\");\n    null.emplace(\"B\", \"b\");\n\n    // the following call will not add an object, because there is already\n    // a value stored at key \"B\"\n    auto res2 = null.emplace(\"B\", \"c\");\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; *res1.first &lt;&lt; \" \" &lt;&lt; std::boolalpha &lt;&lt; res1.second &lt;&lt; '\\n';\n\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n    std::cout &lt;&lt; *res2.first &lt;&lt; \" \" &lt;&lt; std::boolalpha &lt;&lt; res2.second &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\nnull\n{\"one\":1,\"three\":3,\"two\":2}\n3 true\n{\"A\":\"a\",\"B\":\"b\"}\n\"b\" false\n</code></pre>"},{"location":"api/basic_json/emplace/#version-history","title":"Version history","text":"<ul> <li>Since version 2.0.8.</li> </ul>"},{"location":"api/basic_json/emplace_back/","title":"nlohmann::basic_json::emplace_back","text":"<pre><code>template&lt;class... Args&gt;\nreference emplace_back(Args&amp;&amp; ... args);\n</code></pre> <p>Creates a JSON value from the passed parameters <code>args</code> to the end of the JSON value. If the function is called on a JSON <code>null</code> value, an empty array is created before appending the value created from <code>args</code>.</p>"},{"location":"api/basic_json/emplace_back/#template-parameters","title":"Template parameters","text":"<code>Args</code> compatible types to create a <code>basic_json</code> object"},{"location":"api/basic_json/emplace_back/#iterator-invalidation","title":"Iterator invalidation","text":"<p>By adding an element to the end of the array, a reallocation can happen, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated. Otherwise, only the <code>end()</code> iterator is invalidated.</p>"},{"location":"api/basic_json/emplace_back/#parameters","title":"Parameters","text":"<code>args</code> (in) arguments to forward to a constructor of <code>basic_json</code>"},{"location":"api/basic_json/emplace_back/#return-value","title":"Return value","text":"<p>reference to the inserted element</p>"},{"location":"api/basic_json/emplace_back/#exceptions","title":"Exceptions","text":"<p>Throws <code>type_error.311</code> when called on a type other than JSON array or <code>null</code>; example: <code>\"cannot use emplace_back() with number\"</code></p>"},{"location":"api/basic_json/emplace_back/#complexity","title":"Complexity","text":"<p>Amortized constant.</p>"},{"location":"api/basic_json/emplace_back/#examples","title":"Examples","text":"Example <p>The example shows how <code>emplace_back()</code> can be used to add elements to a JSON array. Note how the <code>null</code> value was silently converted to a JSON array.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json array = {1, 2, 3, 4, 5};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values\n    array.emplace_back(6);\n    null.emplace_back(\"first\");\n    null.emplace_back(3, \"second\");\n\n    // print values\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3,4,5]\nnull\n[1,2,3,4,5,6]\n[\"first\",[\"second\",\"second\",\"second\"]]\n</code></pre>"},{"location":"api/basic_json/emplace_back/#see-also","title":"See also","text":"<ul> <li>operator+= add a value to an array/object</li> <li>push_back add a value to an array/object</li> </ul>"},{"location":"api/basic_json/emplace_back/#version-history","title":"Version history","text":"<ul> <li>Since version 2.0.8.</li> <li>Returns reference since 3.7.0.</li> </ul>"},{"location":"api/basic_json/empty/","title":"nlohmann::basic_json::empty","text":"<pre><code>bool empty() const noexcept;\n</code></pre> <p>Checks if a JSON value has no elements (i.e., whether its <code>size()</code> is <code>0</code>).</p>"},{"location":"api/basic_json/empty/#return-value","title":"Return value","text":"<p>The return value depends on the different types and is defined as follows:</p> Value type return value null <code>true</code> boolean <code>false</code> string <code>false</code> number <code>false</code> binary <code>false</code> object result of function <code>object_t::empty()</code> array result of function <code>array_t::empty()</code>"},{"location":"api/basic_json/empty/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/empty/#complexity","title":"Complexity","text":"<p>Constant, as long as <code>array_t</code> and <code>object_t</code> satisfy the Container concept; that is, their <code>empty()</code> functions have constant complexity.</p>"},{"location":"api/basic_json/empty/#possible-implementation","title":"Possible implementation","text":"<pre><code>bool empty() const noexcept\n{\n    return size() == 0;\n}\n</code></pre>"},{"location":"api/basic_json/empty/#notes","title":"Notes","text":"<p>This function does not return whether a string stored as JSON value is empty -- it returns whether the JSON container itself is empty which is <code>false</code> in the case of a string.</p>"},{"location":"api/basic_json/empty/#examples","title":"Examples","text":"Example <p>The following code uses <code>empty()</code> to check if a JSON object contains any elements.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_object_empty(json::value_t::object);\n    json j_array = {1, 2, 4, 8, 16};\n    json j_array_empty(json::value_t::array);\n    json j_string = \"Hello, world\";\n\n    // call empty()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object_empty.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array_empty.empty() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.empty() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\n</code></pre>"},{"location":"api/basic_json/empty/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended to return <code>false</code> for binary types in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/end/","title":"nlohmann::basic_json::end","text":"<pre><code>iterator end() noexcept;\nconst_iterator end() const noexcept;\n</code></pre> <p>Returns an iterator to one past the last element.</p> <p></p>"},{"location":"api/basic_json/end/#return-value","title":"Return value","text":"<p>iterator one past the last element</p>"},{"location":"api/basic_json/end/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/end/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/end/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>end()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to one past the last element\n    json::iterator it = array.end();\n\n    // decrement the iterator to point to the last element\n    --it;\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>5\n</code></pre>"},{"location":"api/basic_json/end/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/end_pos/","title":"nlohmann::basic_json::end_pos","text":"<pre><code>#if JSON_DIAGNOSTIC_POSITIONS\nconstexpr std::size_t end_pos() const noexcept;\n#endif\n</code></pre> <p>Returns the position immediately following the last character of the JSON string from which the value was parsed from.</p> JSON type return value object position after the closing <code>}</code> array position after the closing <code>]</code> string position after the closing <code>\"</code> number position after the last character boolean position after <code>e</code> null position after <code>l</code>"},{"location":"api/basic_json/end_pos/#return-value","title":"Return value","text":"<p>the position of the character following the last character of the given value in the parsed JSON string, if the value was created by the <code>parse</code> function, or <code>std::string::npos</code> if the value was constructed otherwise</p>"},{"location":"api/basic_json/end_pos/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/end_pos/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/end_pos/#notes","title":"Notes","text":"<p>Note</p> <p>The function is only available if macro <code>JSON_DIAGNOSTIC_POSITIONS</code> has been defined to <code>1</code> before including the library header.</p> <p>Invalidation</p> <p>The returned positions are only valid as long as the JSON value is not changed. The positions are not updated when the JSON value is changed.</p>"},{"location":"api/basic_json/end_pos/#examples","title":"Examples","text":"Example <pre><code>#include &lt;iostream&gt;\n\n#define JSON_DIAGNOSTIC_POSITIONS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string json_string = R\"(\n    {\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\n    )\";\n    json j = json::parse(json_string);\n\n    std::cout &lt;&lt; \"Root diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos: \" &lt;&lt; j.start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j.end_pos() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"{\\n        \\\"address\\\": {\\n            \\\"street\\\": \\\"Fake Street\\\",\\n            \\\"housenumber\\\": 1\\n        }\\n    }\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j.start_pos(), j.end_pos() - j.start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"address diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"{            \\\"street\\\": \\\"Fake Street\\\",\\n            \\\"housenumber\\\": 1\\n        }\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"].start_pos(), j[\"address\"].end_pos() - j[\"address\"].start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"street diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"][\"street\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"][\"street\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"\\\"Fake Street\\\"\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"][\"street\"].start_pos(), j[\"address\"][\"street\"].end_pos() - j[\"address\"][\"street\"].start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"housenumber diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"][\"housenumber\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"][\"housenumber\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"1\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"][\"housenumber\"].start_pos(), j[\"address\"][\"housenumber\"].end_pos() - j[\"address\"][\"housenumber\"].start_pos()) &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>Root diagnostic positions: \n    start_pos: 5\n    end_pos:109\nOriginal string: \n{\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\nParsed string: \n{\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\n\naddress diagnostic positions: \n    start_pos:26\n    end_pos:103\n\nOriginal string: \n{            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\nParsed string: \n{\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n\nstreet diagnostic positions: \n    start_pos:50\n    end_pos:63\n\nOriginal string: \n\"Fake Street\"\nParsed string: \n\"Fake Street\"\n\nhousenumber diagnostic positions: \n    start_pos:92\n    end_pos:93\n\nOriginal string: \n1\nParsed string: \n1\n</code></pre> <p>The output shows the start/end positions of all the objects and fields in the JSON string.</p>"},{"location":"api/basic_json/end_pos/#see-also","title":"See also","text":"<ul> <li>start_pos to access the start position</li> <li>JSON_DIAGNOSTIC_POSITIONS for an overview of the diagnostic positions</li> </ul>"},{"location":"api/basic_json/end_pos/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.12.0.</li> </ul>"},{"location":"api/basic_json/erase/","title":"nlohmann::basic_json::erase","text":"<pre><code>// (1)\niterator erase(iterator pos);\nconst_iterator erase(const_iterator pos);\n\n// (2)\niterator erase(iterator first, iterator last);\nconst_iterator erase(const_iterator first, const_iterator last);\n\n// (3)\nsize_type erase(const typename object_t::key_type&amp; key);\n\n// (4)\ntemplate&lt;typename KeyType&gt;\nsize_type erase(KeyType&amp;&amp; key);\n\n// (5)\nvoid erase(const size_type idx);\n</code></pre> <ol> <li> <p>Removes an element from a JSON value specified by iterator <code>pos</code>. The iterator <code>pos</code> must be valid and    dereferenceable. Thus, the <code>end()</code> iterator (which is valid, but is not dereferenceable) cannot be used as a value for    <code>pos</code>.</p> <p>If called on a primitive type other than <code>null</code>, the resulting JSON value will be <code>null</code>.</p> </li> <li> <p>Remove an element range specified by <code>[first; last)</code> from a JSON value. The iterator <code>first</code> does not need to be    dereferenceable if <code>first == last</code>: erasing an empty range is a no-op.</p> <p>If called on a primitive type other than <code>null</code>, the resulting JSON value will be <code>null</code>.</p> </li> <li> <p>Removes an element from a JSON object by key.</p> </li> <li> <p>See 3. This overload is only available if <code>KeyType</code> is comparable with <code>typename object_t::key_type</code> and    <code>typename object_comparator_t::is_transparent</code> denotes a type.</p> </li> <li> <p>Removes an element from a JSON array by index.</p> </li> </ol>"},{"location":"api/basic_json/erase/#template-parameters","title":"Template parameters","text":"<code>KeyType</code> A type for an object key other than <code>json_pointer</code> that is comparable with <code>string_t</code> using  <code>object_comparator_t</code>. This can also be a string view (C++17)."},{"location":"api/basic_json/erase/#parameters","title":"Parameters","text":"<code>pos</code> (in) iterator to the element to remove <code>first</code> (in) iterator to the beginning of the range to remove <code>last</code> (in) iterator past the end of the range to remove <code>key</code> (in) object key of the elements to remove <code>idx</code> (in) array index of the element to remove"},{"location":"api/basic_json/erase/#return-value","title":"Return value","text":"<ol> <li>Iterator following the last removed element. If the iterator <code>pos</code> refers to the last element, the <code>end()</code> iterator    is returned.</li> <li>Iterator following the last removed element. If the iterator <code>last</code> refers to the last element, the <code>end()</code> iterator    is returned.</li> <li>Number of elements removed. If <code>ObjectType</code> is the default <code>std::map</code> type, the return value will always be <code>0</code>    (<code>key</code> was not found) or <code>1</code> (<code>key</code> was found).</li> <li>See 3.</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/erase/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/erase/#exceptions","title":"Exceptions","text":"<ol> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.307</code> if called on a <code>null</code> value;   example: <code>\"cannot use erase() with null\"</code></li> <li>Throws <code>invalid_iterator.202</code> if called on an   iterator which does not belong to the current JSON value; example: <code>\"iterator does not fit current value\"</code></li> <li>Throws <code>invalid_iterator.205</code> if called on a   primitive type with invalid iterator (i.e., any iterator which is not <code>begin()</code>); example: <code>\"iterator out of   range\"</code></li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.307</code> if called on a <code>null</code> value;   example: <code>\"cannot use erase() with null\"</code></li> <li>Throws <code>invalid_iterator.203</code> if called on iterators   which does not belong to the current JSON value; example: <code>\"iterators do not fit current value\"</code></li> <li>Throws <code>invalid_iterator.204</code> if called on a   primitive type with invalid iterators (i.e., if <code>first != begin()</code> and <code>last != end()</code>); example: <code>\"iterators out   of range\"</code></li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.307</code> when called on a type other than   JSON object; example: <code>\"cannot use erase() with null\"</code></li> </ul> </li> <li>See 3.</li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.307</code> when called on a type other than   JSON object; example: <code>\"cannot use erase() with null\"</code></li> <li>Throws <code>out_of_range.401</code> when <code>idx &gt;= size()</code>; example:   <code>\"array index 17 is out of range\"</code></li> </ul> </li> </ol>"},{"location":"api/basic_json/erase/#complexity","title":"Complexity","text":"<ol> <li>The complexity depends on the type:<ul> <li>objects: amortized constant</li> <li>arrays: linear in distance between <code>pos</code> and the end of the container</li> <li>strings and binary: linear in the length of the member</li> <li>other types: constant</li> </ul> </li> <li>The complexity depends on the type:<ul> <li>objects: <code>log(size()) + std::distance(first, last)</code></li> <li>arrays: linear in the distance between <code>first</code> and <code>last</code>, plus linear      in the distance between <code>last</code> and end of the container</li> <li>strings and binary: linear in the length of the member</li> <li>other types: constant</li> </ul> </li> <li><code>log(size()) + count(key)</code></li> <li><code>log(size()) + count(key)</code></li> <li>Linear in distance between <code>idx</code> and the end of the container.</li> </ol>"},{"location":"api/basic_json/erase/#notes","title":"Notes","text":"<ol> <li>Invalidates iterators and references at or after the point of the <code>erase</code>, including the <code>end()</code> iterator.</li> <li>(none)</li> <li>References and iterators to the erased elements are invalidated. Other references and iterators are not affected.</li> <li>See 3.</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/erase/#examples","title":"Examples","text":"Example: (1) remove element given an iterator <p>The example shows the effect of <code>erase()</code> for different JSON types using an iterator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call erase()\n    j_boolean.erase(j_boolean.begin());\n    j_number_integer.erase(j_number_integer.begin());\n    j_number_float.erase(j_number_float.begin());\n    j_object.erase(j_object.find(\"two\"));\n    j_array.erase(j_array.begin() + 2);\n    j_string.erase(j_string.begin());\n\n    // print values\n    std::cout &lt;&lt; j_boolean &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>null\nnull\nnull\n{\"one\":1}\n[1,2,8,16]\nnull\n</code></pre> Example: (2) remove elements given an iterator range <p>The example shows the effect of <code>erase()</code> for different JSON types using an iterator range.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call erase()\n    j_boolean.erase(j_boolean.begin(), j_boolean.end());\n    j_number_integer.erase(j_number_integer.begin(), j_number_integer.end());\n    j_number_float.erase(j_number_float.begin(), j_number_float.end());\n    j_object.erase(j_object.find(\"two\"), j_object.end());\n    j_array.erase(j_array.begin() + 1, j_array.begin() + 3);\n    j_string.erase(j_string.begin(), j_string.end());\n\n    // print values\n    std::cout &lt;&lt; j_boolean &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>null\nnull\nnull\n{\"one\":1}\n[1,8,16]\nnull\n</code></pre> Example: (3) remove element from a JSON object given a key <p>The example shows the effect of <code>erase()</code> for different JSON types using an object key.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n\n    // call erase()\n    auto count_one = j_object.erase(\"one\");\n    auto count_three = j_object.erase(\"three\");\n\n    // print values\n    std::cout &lt;&lt; j_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; count_one &lt;&lt; \" \" &lt;&lt; count_three &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\"two\":2}\n1 0\n</code></pre> Example: (4) remove element from a JSON object given a key using string_view <p>The example shows the effect of <code>erase()</code> for different JSON types using an object key.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n\n    // call erase()\n    auto count_one = j_object.erase(\"one\"sv);\n    auto count_three = j_object.erase(\"three\"sv);\n\n    // print values\n    std::cout &lt;&lt; j_object &lt;&lt; '\\n';\n    std::cout &lt;&lt; count_one &lt;&lt; \" \" &lt;&lt; count_three &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\"two\":2}\n1 0\n</code></pre> Example: (5) remove element from a JSON array given an index <p>The example shows the effect of <code>erase()</code> using an array index.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON array\n    json j_array = {0, 1, 2, 3, 4, 5};\n\n    // call erase()\n    j_array.erase(2);\n\n    // print values\n    std::cout &lt;&lt; j_array &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[0,1,3,4,5]\n</code></pre>"},{"location":"api/basic_json/erase/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Added support for binary types in version 3.8.0.</li> <li>Added in version 1.0.0. Added support for binary types in version 3.8.0.</li> <li>Added in version 1.0.0.</li> <li>Added in version 3.11.0.</li> <li>Added in version 1.0.0.</li> </ol>"},{"location":"api/basic_json/error_handler_t/","title":"nlohmann::basic_json::error_handler_t","text":"<pre><code>enum class error_handler_t {\n    strict,\n    replace,\n    ignore\n};\n</code></pre> <p>This enumeration is used in the <code>dump</code> function to choose how to treat decoding errors while serializing a <code>basic_json</code> value. Three values are differentiated:</p> strict throw a <code>type_error</code> exception in case of invalid UTF-8 replace replace invalid UTF-8 sequences with U+FFFD (\ufffd REPLACEMENT CHARACTER) ignore ignore invalid UTF-8 sequences; all bytes are copied to the output unchanged"},{"location":"api/basic_json/error_handler_t/#examples","title":"Examples","text":"Example <p>The example below shows how the different values of the <code>error_handler_t</code> influence the behavior of <code>dump</code> when reading serializing an invalid UTF-8 sequence.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON value with invalid UTF-8 byte sequence\n    json j_invalid = \"\u00e4\\xA9\u00fc\";\n    try\n    {\n        std::cout &lt;&lt; j_invalid.dump() &lt;&lt; std::endl;\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"string with replaced invalid characters: \"\n              &lt;&lt; j_invalid.dump(-1, ' ', false, json::error_handler_t::replace)\n              &lt;&lt; \"\\nstring with ignored invalid characters: \"\n              &lt;&lt; j_invalid.dump(-1, ' ', false, json::error_handler_t::ignore)\n              &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.type_error.316] invalid UTF-8 byte at index 2: 0xA9\nstring with replaced invalid characters: \"\u00e4\ufffd\u00fc\"\nstring with ignored invalid characters: \"\u00e4\u00fc\"\n</code></pre>"},{"location":"api/basic_json/error_handler_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.4.0.</li> </ul>"},{"location":"api/basic_json/exception/","title":"nlohmann::basic_json::exception","text":"<pre><code>class exception : public std::exception;\n</code></pre> <p>This class is an extension of <code>std::exception</code> objects with a member <code>id</code> for exception ids. It is used as the base class for all exceptions thrown by the <code>basic_json</code> class. This class can hence be used as \"wildcard\" to catch exceptions, see example below.</p> <pre><code>classDiagram\n  direction LR\n\n    class std_exception [\"std::exception\"] {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n\n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception &lt;|-- json_exception\n    json_exception &lt;|-- json_parse_error\n    json_exception &lt;|-- json_invalid_iterator\n    json_exception &lt;|-- json_type_error\n    json_exception &lt;|-- json_out_of_range\n    json_exception &lt;|-- json_other_error\n\n    style json_exception fill:#CCCCFF</code></pre> <p>Subclasses:</p> <ul> <li><code>parse_error</code> for exceptions indicating a parse error</li> <li><code>invalid_iterator</code> for exceptions indicating errors with iterators</li> <li><code>type_error</code> for exceptions indicating executing a member function with a wrong type</li> <li><code>out_of_range</code> for exceptions indicating access out of the defined range</li> <li><code>other_error</code> for exceptions indicating other library errors</li> </ul>"},{"location":"api/basic_json/exception/#member-functions","title":"Member functions","text":"<ul> <li>what - returns explanatory string</li> </ul>"},{"location":"api/basic_json/exception/#member-variables","title":"Member variables","text":"<ul> <li>id - the id of the exception</li> </ul>"},{"location":"api/basic_json/exception/#notes","title":"Notes","text":"<p>To have nothrow-copy-constructible exceptions, we internally use <code>std::runtime_error</code> which can cope with arbitrary-length error messages. Intermediate strings are built with static functions and then passed to the actual constructor.</p>"},{"location":"api/basic_json/exception/#examples","title":"Examples","text":"Example <p>The following code shows how arbitrary library exceptions can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // calling at() for a non-existing key\n        json j = {{\"foo\", \"bar\"}};\n        json k = j.at(\"non-existing\");\n    }\n    catch (const json::exception&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.out_of_range.403] key 'non-existing' not found\nexception id: 403\n</code></pre>"},{"location":"api/basic_json/exception/#see-also","title":"See also","text":"<p>List of exceptions</p>"},{"location":"api/basic_json/exception/#version-history","title":"Version history","text":"<ul> <li>Since version 3.0.0.</li> </ul>"},{"location":"api/basic_json/find/","title":"nlohmann::basic_json::find","text":"<pre><code>// (1)\niterator find(const typename object_t::key_type&amp; key);\nconst_iterator find(const typename object_t::key_type&amp; key) const;\n\n// (2)\ntemplate&lt;typename KeyType&gt;\niterator find(KeyType&amp;&amp; key);\ntemplate&lt;typename KeyType&gt;\nconst_iterator find(KeyType&amp;&amp; key) const;\n</code></pre> <ol> <li>Finds an element in a JSON object with a key equivalent to <code>key</code>. If the element is not found or the    JSON value is not an object, <code>end()</code> is returned.</li> <li>See 1. This overload is only available if <code>KeyType</code> is comparable with <code>typename object_t::key_type</code> and    <code>typename object_comparator_t::is_transparent</code> denotes a type.</li> </ol>"},{"location":"api/basic_json/find/#template-parameters","title":"Template parameters","text":"<code>KeyType</code> A type for an object key other than <code>json_pointer</code> that is comparable with <code>string_t</code> using  <code>object_comparator_t</code>. This can also be a string view (C++17)."},{"location":"api/basic_json/find/#parameters","title":"Parameters","text":"<code>key</code> (in) key value of the element to search for."},{"location":"api/basic_json/find/#return-value","title":"Return value","text":"<p>Iterator to an element with a key equivalent to <code>key</code>. If no such element is found or the JSON value is not an object, a past-the-end iterator (see <code>end()</code>) is returned.</p>"},{"location":"api/basic_json/find/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/find/#complexity","title":"Complexity","text":"<p>Logarithmic in the size of the JSON object.</p>"},{"location":"api/basic_json/find/#notes","title":"Notes","text":"<p>This method always returns <code>end()</code> when executed on a JSON type that is not an object.</p>"},{"location":"api/basic_json/find/#examples","title":"Examples","text":"Example: (1) find object element by key <p>The example shows how <code>find()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n\n    // call find\n    auto it_two = j_object.find(\"two\");\n    auto it_three = j_object.find(\"three\");\n\n    // print values\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; \"\\\"two\\\" was found: \" &lt;&lt; (it_two != j_object.end()) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"value at key \\\"two\\\": \" &lt;&lt; *it_two &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\\"three\\\" was found: \" &lt;&lt; (it_three != j_object.end()) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>\"two\" was found: true\nvalue at key \"two\": 2\n\"three\" was found: false\n</code></pre> Example: (2) find object element by key using string_view <p>The example shows how <code>find()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n\n    // call find\n    auto it_two = j_object.find(\"two\"sv);\n    auto it_three = j_object.find(\"three\"sv);\n\n    // print values\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; \"\\\"two\\\" was found: \" &lt;&lt; (it_two != j_object.end()) &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"value at key \\\"two\\\": \" &lt;&lt; *it_two &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\\"three\\\" was found: \" &lt;&lt; (it_three != j_object.end()) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>\"two\" was found: true\nvalue at key \"two\": 2\n\"three\" was found: false\n</code></pre>"},{"location":"api/basic_json/find/#see-also","title":"See also","text":"<ul> <li>contains checks whether a key exists</li> </ul>"},{"location":"api/basic_json/find/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.11.0.</li> <li>Added in version 1.0.0. Changed to support comparable types in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/flatten/","title":"nlohmann::basic_json::flatten","text":"<pre><code>basic_json flatten() const;\n</code></pre> <p>The function creates a JSON object whose keys are JSON pointers (see RFC 6901) and whose values are all primitive (see <code>is_primitive()</code> for more information). The original JSON value can be restored using the <code>unflatten()</code> function.</p>"},{"location":"api/basic_json/flatten/#return-value","title":"Return value","text":"<p>an object that maps JSON pointers to primitive values</p>"},{"location":"api/basic_json/flatten/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/flatten/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value.</p>"},{"location":"api/basic_json/flatten/#notes","title":"Notes","text":"<p>Empty objects and arrays are flattened to <code>null</code> and will not be reconstructed correctly by the <code>unflatten()</code> function.</p>"},{"location":"api/basic_json/flatten/#examples","title":"Examples","text":"Example <p>The following code shows how a JSON object is flattened to an object whose keys consist of JSON pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON value\n    json j =\n    {\n        {\"pi\", 3.141},\n        {\"happy\", true},\n        {\"name\", \"Niels\"},\n        {\"nothing\", nullptr},\n        {\n            \"answer\", {\n                {\"everything\", 42}\n            }\n        },\n        {\"list\", {1, 0, 2}},\n        {\n            \"object\", {\n                {\"currency\", \"USD\"},\n                {\"value\", 42.99}\n            }\n        }\n    };\n\n    // call flatten()\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j.flatten() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"/answer/everything\": 42,\n    \"/happy\": true,\n    \"/list/0\": 1,\n    \"/list/1\": 0,\n    \"/list/2\": 2,\n    \"/name\": \"Niels\",\n    \"/nothing\": null,\n    \"/object/currency\": \"USD\",\n    \"/object/value\": 42.99,\n    \"/pi\": 3.141\n}\n</code></pre>"},{"location":"api/basic_json/flatten/#see-also","title":"See also","text":"<ul> <li>unflatten the reverse function</li> </ul>"},{"location":"api/basic_json/flatten/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> </ul>"},{"location":"api/basic_json/from_bjdata/","title":"nlohmann::basic_json::from_bjdata","text":"<pre><code>// (1)\ntemplate&lt;typename InputType&gt;\nstatic basic_json from_bjdata(InputType&amp;&amp; i,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n// (2)\ntemplate&lt;typename IteratorType&gt;\nstatic basic_json from_bjdata(IteratorType first, IteratorType last,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n</code></pre> <p>Deserializes a given input to a JSON value using the BJData (Binary JData) serialization format.</p> <ol> <li>Reads from a compatible input.</li> <li>Reads from an iterator range.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/from_bjdata/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters</li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of iterators.</li> </ul> <code>IteratorType</code> a compatible iterator type"},{"location":"api/basic_json/from_bjdata/#parameters","title":"Parameters","text":"<code>i</code> (in) an input in BJData format convertible to an input adapter <code>first</code> (in) iterator to the start of the input <code>last</code> (in) iterator to the end of the input <code>strict</code> (in) whether to expect the input to be consumed until EOF (<code>true</code> by default) <code>allow_exceptions</code> (in) whether to throw exceptions in case of a parse error (optional, <code>true</code> by default)"},{"location":"api/basic_json/from_bjdata/#return-value","title":"Return value","text":"<p>deserialized JSON value; in case of a parse error and <code>allow_exceptions</code> set to <code>false</code>, the return value will be <code>value_t::discarded</code>. The latter can be checked with <code>is_discarded</code>.</p>"},{"location":"api/basic_json/from_bjdata/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/from_bjdata/#exceptions","title":"Exceptions","text":"<ul> <li>Throws parse_error.110 if the given input ends prematurely or   the end of the file was not reached when <code>strict</code> was set to true</li> <li>Throws parse_error.112 if a parse error occurs</li> <li>Throws parse_error.113 if a string could not be parsed   successfully</li> </ul>"},{"location":"api/basic_json/from_bjdata/#complexity","title":"Complexity","text":"<p>Linear in the size of the input.</p>"},{"location":"api/basic_json/from_bjdata/#examples","title":"Examples","text":"Example <p>The example shows the deserialization of a byte vector in BJData format to a JSON value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x7B, 0x69, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61,\n                                   0x63, 0x74, 0x54, 0x69, 0x06, 0x73, 0x63, 0x68,\n                                   0x65, 0x6D, 0x61, 0x69, 0x00, 0x7D\n                                  };\n\n    // deserialize it with BJData\n    json j = json::from_bjdata(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"api/basic_json/from_bjdata/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/basic_json/from_bson/","title":"nlohmann::basic_json::from_bson","text":"<pre><code>// (1)\ntemplate&lt;typename InputType&gt;\nstatic basic_json from_bson(InputType&amp;&amp; i,\n                            const bool strict = true,\n                            const bool allow_exceptions = true);\n// (2)\ntemplate&lt;typename IteratorType&gt;\nstatic basic_json from_bson(IteratorType first, IteratorType last,\n                            const bool strict = true,\n                            const bool allow_exceptions = true);\n</code></pre> <p>Deserializes a given input to a JSON value using the BSON (Binary JSON) serialization format.</p> <ol> <li>Reads from a compatible input.</li> <li>Reads from an iterator range.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/from_bson/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters</li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of iterators.</li> </ul> <code>IteratorType</code> a compatible iterator type"},{"location":"api/basic_json/from_bson/#parameters","title":"Parameters","text":"<code>i</code> (in) an input in BSON format convertible to an input adapter <code>first</code> (in) iterator to the start of the input <code>last</code> (in) iterator to the end of the input <code>strict</code> (in) whether to expect the input to be consumed until EOF (<code>true</code> by default) <code>allow_exceptions</code> (in) whether to throw exceptions in case of a parse error (optional, <code>true</code> by default)"},{"location":"api/basic_json/from_bson/#return-value","title":"Return value","text":"<p>deserialized JSON value; in case of a parse error and <code>allow_exceptions</code> set to <code>false</code>, the return value will be <code>value_t::discarded</code>.  The latter can be checked with <code>is_discarded</code>.</p>"},{"location":"api/basic_json/from_bson/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/from_bson/#exceptions","title":"Exceptions","text":"<p>Throws <code>parse_error.114</code> if an unsupported BSON record type is encountered.</p>"},{"location":"api/basic_json/from_bson/#complexity","title":"Complexity","text":"<p>Linear in the size of the input.</p>"},{"location":"api/basic_json/from_bson/#examples","title":"Examples","text":"Example <p>The example shows the deserialization of a byte vector in BSON format to a JSON value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x1b, 0x00, 0x00, 0x00, 0x08, 0x63, 0x6f, 0x6d,\n                                   0x70, 0x61, 0x63, 0x74, 0x00, 0x01, 0x10, 0x73,\n                                   0x63, 0x68, 0x65, 0x6d, 0x61, 0x00, 0x00, 0x00,\n                                   0x00, 0x00, 0x00\n                                  };\n\n    // deserialize it with BSON\n    json j = json::from_bson(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"api/basic_json/from_bson/#see-also","title":"See also","text":"<ul> <li>BSON specification</li> <li>to_bson for the analogous serialization</li> <li>from_cbor for the related CBOR format</li> <li>from_msgpack for the related MessagePack format</li> <li>from_ubjson for the related UBJSON format</li> </ul>"},{"location":"api/basic_json/from_bson/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.4.0.</li> </ul> <p>Deprecation</p> <ul> <li>Overload (2) replaces calls to <code>from_bson</code> with a pointer and a length as first two parameters, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_bson(ptr, len, ...);</code> with <code>from_bson(ptr, ptr+len, ...);</code>.</li> <li>Overload (2) replaces calls to <code>from_bson</code> with a pair of iterators as their first parameter, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_bson({ptr, ptr+len}, ...);</code> with <code>from_bson(ptr, ptr+len, ...);</code>.</li> </ul> <p>You should be warned by your compiler with a <code>-Wdeprecated-declarations</code> warning if you are using a deprecated function.</p>"},{"location":"api/basic_json/from_cbor/","title":"nlohmann::basic_json::from_cbor","text":"<pre><code>// (1)\ntemplate&lt;typename InputType&gt;\nstatic basic_json from_cbor(InputType&amp;&amp; i,\n                            const bool strict = true,\n                            const bool allow_exceptions = true,\n                            const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error);\n\n// (2)\ntemplate&lt;typename IteratorType&gt;\nstatic basic_json from_cbor(IteratorType first, IteratorType last,\n                            const bool strict = true,\n                            const bool allow_exceptions = true,\n                            const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error);\n</code></pre> <p>Deserializes a given input to a JSON value using the CBOR (Concise Binary Object Representation) serialization format.</p> <ol> <li>Reads from a compatible input.</li> <li>Reads from an iterator range.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/from_cbor/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters</li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of iterators.</li> </ul> <code>IteratorType</code> a compatible iterator type"},{"location":"api/basic_json/from_cbor/#parameters","title":"Parameters","text":"<code>i</code> (in) an input in CBOR format convertible to an input adapter <code>first</code> (in) iterator to the start of the input <code>last</code> (in) iterator to the end of the input <code>strict</code> (in) whether to expect the input to be consumed until EOF (<code>true</code> by default) <code>allow_exceptions</code> (in) whether to throw exceptions in case of a parse error (optional, <code>true</code> by default) <code>tag_handler</code> (in) how to treat CBOR tags (optional, <code>error</code> by default); see <code>cbor_tag_handler_t</code> for more information"},{"location":"api/basic_json/from_cbor/#return-value","title":"Return value","text":"<p>deserialized JSON value; in case of a parse error and <code>allow_exceptions</code> set to <code>false</code>, the return value will be <code>value_t::discarded</code>.  The latter can be checked with <code>is_discarded</code>.</p>"},{"location":"api/basic_json/from_cbor/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/from_cbor/#exceptions","title":"Exceptions","text":"<ul> <li>Throws parse_error.110 if the given input ends prematurely or   the end of the file was not reached when <code>strict</code> was set to true</li> <li>Throws parse_error.112 if unsupported features from CBOR were   used in the given input or if the input is not valid CBOR</li> <li>Throws parse_error.113 if a string was expected as a map key,   but not found</li> </ul>"},{"location":"api/basic_json/from_cbor/#complexity","title":"Complexity","text":"<p>Linear in the size of the input.</p>"},{"location":"api/basic_json/from_cbor/#examples","title":"Examples","text":"Example <p>The example shows the deserialization of a byte vector in CBOR format to a JSON value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0xa2, 0x67, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63,\n                                   0x74, 0xf5, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d,\n                                   0x61, 0x00\n                                  };\n\n    // deserialize it with CBOR\n    json j = json::from_cbor(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"api/basic_json/from_cbor/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.9.</li> <li>Parameter <code>start_index</code> since version 2.1.1.</li> <li>Changed to consume input adapters, removed <code>start_index</code> parameter, and added <code>strict</code> parameter in version 3.0.0.</li> <li>Added <code>allow_exceptions</code> parameter in version 3.2.0.</li> <li>Added <code>tag_handler</code> parameter in version 3.9.0.</li> </ul> <p>Deprecation</p> <ul> <li>Overload (2) replaces calls to <code>from_cbor</code> with a pointer and a length as first two parameters, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_cbor(ptr, len, ...);</code> with <code>from_cbor(ptr, ptr+len, ...);</code>.</li> <li>Overload (2) replaces calls to <code>from_cbor</code> with a pair of iterators as their first parameter, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_cbor({ptr, ptr+len}, ...);</code> with <code>from_cbor(ptr, ptr+len, ...);</code>.</li> </ul> <p>You should be warned by your compiler with a <code>-Wdeprecated-declarations</code> warning if you are using a deprecated function.</p>"},{"location":"api/basic_json/from_msgpack/","title":"nlohmann::basic_json::from_msgpack","text":"<pre><code>// (1)\ntemplate&lt;typename InputType&gt;\nstatic basic_json from_msgpack(InputType&amp;&amp; i,\n                               const bool strict = true,\n                               const bool allow_exceptions = true);\n// (2)\ntemplate&lt;typename IteratorType&gt;\nstatic basic_json from_msgpack(IteratorType first, IteratorType last,\n                               const bool strict = true,\n                               const bool allow_exceptions = true);\n</code></pre> <p>Deserializes a given input to a JSON value using the MessagePack serialization format.</p> <ol> <li>Reads from a compatible input.</li> <li>Reads from an iterator range.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/from_msgpack/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters</li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of iterators.</li> </ul> <code>IteratorType</code> a compatible iterator type"},{"location":"api/basic_json/from_msgpack/#parameters","title":"Parameters","text":"<code>i</code> (in) an input in MessagePack format convertible to an input adapter <code>first</code> (in) iterator to the start of the input <code>last</code> (in) iterator to the end of the input <code>strict</code> (in) whether to expect the input to be consumed until EOF (<code>true</code> by default) <code>allow_exceptions</code> (in) whether to throw exceptions in case of a parse error (optional, <code>true</code> by default)"},{"location":"api/basic_json/from_msgpack/#return-value","title":"Return value","text":"<p>deserialized JSON value; in case of a parse error and <code>allow_exceptions</code> set to <code>false</code>, the return value will be <code>value_t::discarded</code>. The latter can be checked with <code>is_discarded</code>.</p>"},{"location":"api/basic_json/from_msgpack/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/from_msgpack/#exceptions","title":"Exceptions","text":"<ul> <li>Throws parse_error.110 if the given input ends prematurely or   the end of the file was not reached when <code>strict</code> was set to true</li> <li>Throws parse_error.112 if unsupported features from   MessagePack were used in the given input or if the input is not valid MessagePack</li> <li>Throws parse_error.113 if a string was expected as a map key,   but not found</li> </ul>"},{"location":"api/basic_json/from_msgpack/#complexity","title":"Complexity","text":"<p>Linear in the size of the input.</p>"},{"location":"api/basic_json/from_msgpack/#examples","title":"Examples","text":"Example <p>The example shows the deserialization of a byte vector in MessagePack format to a JSON value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x82, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63,\n                                   0x74, 0xc3, 0xa6, 0x73, 0x63, 0x68, 0x65, 0x6d,\n                                   0x61, 0x00\n                                  };\n\n    // deserialize it with MessagePack\n    json j = json::from_msgpack(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"api/basic_json/from_msgpack/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.9.</li> <li>Parameter <code>start_index</code> since version 2.1.1.</li> <li>Changed to consume input adapters, removed <code>start_index</code> parameter, and added <code>strict</code> parameter in version 3.0.0.</li> <li>Added <code>allow_exceptions</code> parameter in version 3.2.0.</li> </ul> <p>Deprecation</p> <ul> <li>Overload (2) replaces calls to <code>from_msgpack</code> with a pointer and a length as first two parameters, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_msgpack(ptr, len, ...);</code> with <code>from_msgpack(ptr, ptr+len, ...);</code>.</li> <li>Overload (2) replaces calls to <code>from_cbor</code> with a pair of iterators as their first parameter, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_msgpack({ptr, ptr+len}, ...);</code> with <code>from_msgpack(ptr, ptr+len, ...);</code>.</li> </ul> <p>You should be warned by your compiler with a <code>-Wdeprecated-declarations</code> warning if you are using a deprecated function.</p>"},{"location":"api/basic_json/from_ubjson/","title":"nlohmann::basic_json::from_ubjson","text":"<pre><code>// (1)\ntemplate&lt;typename InputType&gt;\nstatic basic_json from_ubjson(InputType&amp;&amp; i,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n// (2)\ntemplate&lt;typename IteratorType&gt;\nstatic basic_json from_ubjson(IteratorType first, IteratorType last,\n                              const bool strict = true,\n                              const bool allow_exceptions = true);\n</code></pre> <p>Deserializes a given input to a JSON value using the UBJSON (Universal Binary JSON) serialization format.</p> <ol> <li>Reads from a compatible input.</li> <li>Reads from an iterator range.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/from_ubjson/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters</li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of iterators.</li> </ul> <code>IteratorType</code> a compatible iterator type"},{"location":"api/basic_json/from_ubjson/#parameters","title":"Parameters","text":"<code>i</code> (in) an input in UBJSON format convertible to an input adapter <code>first</code> (in) iterator to the start of the input <code>last</code> (in) iterator to the end of the input <code>strict</code> (in) whether to expect the input to be consumed until EOF (<code>true</code> by default) <code>allow_exceptions</code> (in) whether to throw exceptions in case of a parse error (optional, <code>true</code> by default)"},{"location":"api/basic_json/from_ubjson/#return-value","title":"Return value","text":"<p>deserialized JSON value; in case of a parse error and <code>allow_exceptions</code> set to <code>false</code>, the return value will be <code>value_t::discarded</code>. The latter can be checked with <code>is_discarded</code>.</p>"},{"location":"api/basic_json/from_ubjson/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/from_ubjson/#exceptions","title":"Exceptions","text":"<ul> <li>Throws parse_error.110 if the given input ends prematurely or   the end of the file was not reached when <code>strict</code> was set to true</li> <li>Throws parse_error.112 if a parse error occurs</li> <li>Throws parse_error.113 if a string could not be parsed    successfully</li> </ul>"},{"location":"api/basic_json/from_ubjson/#complexity","title":"Complexity","text":"<p>Linear in the size of the input.</p>"},{"location":"api/basic_json/from_ubjson/#examples","title":"Examples","text":"Example <p>The example shows the deserialization of a byte vector in UBJSON format to a JSON value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x7B, 0x69, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61,\n                                   0x63, 0x74, 0x54, 0x69, 0x06, 0x73, 0x63, 0x68,\n                                   0x65, 0x6D, 0x61, 0x69, 0x00, 0x7D\n                                  };\n\n    // deserialize it with UBJSON\n    json j = json::from_ubjson(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"api/basic_json/from_ubjson/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.1.0.</li> <li>Added <code>allow_exceptions</code> parameter in version 3.2.0.</li> </ul> <p>Deprecation</p> <ul> <li>Overload (2) replaces calls to <code>from_ubjson</code> with a pointer and a length as first two parameters, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_ubjson(ptr, len, ...);</code> with <code>from_ubjson(ptr, ptr+len, ...);</code>.</li> <li>Overload (2) replaces calls to <code>from_ubjson</code> with a pair of iterators as their first parameter, which has been   deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like   <code>from_ubjson({ptr, ptr+len}, ...);</code> with <code>from_ubjson(ptr, ptr+len, ...);</code>.</li> </ul> <p>You should be warned by your compiler with a <code>-Wdeprecated-declarations</code> warning if you are using a deprecated function.</p>"},{"location":"api/basic_json/front/","title":"nlohmann::basic_json::front","text":"<pre><code>reference front();\nconst_reference front() const;\n</code></pre> <p>Returns a reference to the first element in the container. For a JSON container <code>c</code>, the expression <code>c.front()</code> is equivalent to <code>*c.begin()</code>.</p>"},{"location":"api/basic_json/front/#return-value","title":"Return value","text":"<p>In the case of a structured type (array or object), a reference to the first element is returned. In the case of number, string, boolean, or binary values, a reference to the value is returned.</p>"},{"location":"api/basic_json/front/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/front/#exceptions","title":"Exceptions","text":"<p>If the JSON value is <code>null</code>, exception <code>invalid_iterator.214</code> is thrown.</p>"},{"location":"api/basic_json/front/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/front/#notes","title":"Notes","text":"<p>Precondition</p> <p>The array or object must not be empty. Calling <code>front</code> on an empty array or object yields undefined behavior.</p>"},{"location":"api/basic_json/front/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>front()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_object_empty(json::value_t::object);\n    json j_array = {1, 2, 4, 8, 16};\n    json j_array_empty(json::value_t::array);\n    json j_string = \"Hello, world\";\n\n    // call front()\n    //std::cout &lt;&lt; j_null.front() &lt;&lt; '\\n';          // would throw\n    std::cout &lt;&lt; j_boolean.front() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.front() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.front() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.front() &lt;&lt; '\\n';\n    //std::cout &lt;&lt; j_object_empty.front() &lt;&lt; '\\n';  // undefined behavior\n    std::cout &lt;&lt; j_array.front() &lt;&lt; '\\n';\n    //std::cout &lt;&lt; j_array_empty.front() &lt;&lt; '\\n';   // undefined behavior\n    std::cout &lt;&lt; j_string.front() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true\n17\n23.42\n1\n1\n\"Hello, world\"\n</code></pre>"},{"location":"api/basic_json/front/#see-also","title":"See also","text":"<ul> <li>back to access the last element</li> </ul>"},{"location":"api/basic_json/front/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Adjusted code to return reference to binary values in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/get/","title":"nlohmann::basic_json::get","text":"<pre><code>// (1)\ntemplate&lt;typename ValueType&gt;\nValueType get() const noexcept(\n    noexcept(JSONSerializer&lt;ValueType&gt;::from_json(\n        std::declval&lt;const basic_json_t&amp;&gt;(), std::declval&lt;ValueType&amp;&gt;())));\n\n// (2)\ntemplate&lt;typename BasicJsonType&gt;\nBasicJsonType get() const;\n\n// (3)\ntemplate&lt;typename PointerType&gt;\nPointerType get_ptr();\n\ntemplate&lt;typename PointerType&gt;\nconstexpr const PointerType get_ptr() const noexcept;\n</code></pre> <ol> <li> <p>Explicit type conversion between the JSON value and a compatible value which is    CopyConstructible and    DefaultConstructible. The value is converted by    calling the <code>json_serializer&lt;ValueType&gt;</code> <code>from_json()</code> method.</p> <p>The function is equivalent to executing <pre><code>ValueType ret;\nJSONSerializer&lt;ValueType&gt;::from_json(*this, ret);\nreturn ret;\n</code></pre></p> <p>This overload is chosen if:</p> <ul> <li><code>ValueType</code> is not <code>basic_json</code>,</li> <li><code>json_serializer&lt;ValueType&gt;</code> has a <code>from_json()</code> method of the form   <code>void from_json(const basic_json&amp;, ValueType&amp;)</code>, and</li> <li><code>json_serializer&lt;ValueType&gt;</code> does not have a <code>from_json()</code> method of the form   <code>ValueType from_json(const basic_json&amp;)</code></li> </ul> <p>If the type is not CopyConstructible and not DefaultConstructible, the value is converted by calling the <code>json_serializer&lt;ValueType&gt;</code> <code>from_json()</code> method.</p> <p>The function is then equivalent to executing <pre><code>return JSONSerializer&lt;ValueTypeCV&gt;::from_json(*this);\n</code></pre></p> <p>This overload is chosen if:</p> <ul> <li><code>ValueType</code> is not <code>basic_json</code> and</li> <li><code>json_serializer&lt;ValueType&gt;</code> has a <code>from_json()</code> method of the form  <code>ValueType from_json(const basic_json&amp;)</code></li> </ul> <p>If <code>json_serializer&lt;ValueType&gt;</code> has both overloads of <code>from_json()</code>, the latter one is chosen.</p> </li> <li> <p>Overload for <code>basic_json</code> specializations. The function is equivalent to executing     <pre><code>return *this;\n</code></pre></p> </li> <li> <p>Explicit pointer access to the internally stored JSON value. No copies are made.</p> </li> </ol>"},{"location":"api/basic_json/get/#template-parameters","title":"Template parameters","text":"<code>ValueType</code> the value type to return <code>BasicJsonType</code> a specialization of <code>basic_json</code> <code>PointerType</code> pointer type; must be a pointer to <code>array_t</code>, <code>object_t</code>, <code>string_t</code>, <code>boolean_t</code>, <code>number_integer_t</code>, or <code>number_unsigned_t</code>, <code>number_float_t</code>, or <code>binary_t</code>. Other types will not compile."},{"location":"api/basic_json/get/#return-value","title":"Return value","text":"<ol> <li>copy of the JSON value, converted to <code>ValueType</code></li> <li>a copy of <code>*this</code>, converted into <code>BasicJsonType</code></li> <li>pointer to the internally stored JSON value if the requested pointer type fits to the JSON value; <code>nullptr</code>    otherwise</li> </ol>"},{"location":"api/basic_json/get/#exceptions","title":"Exceptions","text":"<p>Depends on what <code>json_serializer&lt;ValueType&gt;</code> <code>from_json()</code> method throws</p>"},{"location":"api/basic_json/get/#notes","title":"Notes","text":"<p>Undefined behavior</p> <p>Writing data to the pointee (overload 3) of the result yields an undefined state.</p>"},{"location":"api/basic_json/get/#examples","title":"Examples","text":"Example <p>The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>, (3) A JSON object can be converted to C++ associative containers such as <code>std::unordered_map&lt;std::string, json&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON value with different types\n    json json_types =\n    {\n        {\"boolean\", true},\n        {\n            \"number\", {\n                {\"integer\", 42},\n                {\"floating-point\", 17.23}\n            }\n        },\n        {\"string\", \"Hello, world!\"},\n        {\"array\", {1, 2, 3, 4, 5}},\n        {\"null\", nullptr}\n    };\n\n    // use explicit conversions\n    auto v1 = json_types[\"boolean\"].template get&lt;bool&gt;();\n    auto v2 = json_types[\"number\"][\"integer\"].template get&lt;int&gt;();\n    auto v3 = json_types[\"number\"][\"integer\"].template get&lt;short&gt;();\n    auto v4 = json_types[\"number\"][\"floating-point\"].template get&lt;float&gt;();\n    auto v5 = json_types[\"number\"][\"floating-point\"].template get&lt;int&gt;();\n    auto v6 = json_types[\"string\"].template get&lt;std::string&gt;();\n    auto v7 = json_types[\"array\"].template get&lt;std::vector&lt;short&gt;&gt;();\n    auto v8 = json_types.template get&lt;std::unordered_map&lt;std::string, json&gt;&gt;();\n\n    // print the conversion results\n    std::cout &lt;&lt; v1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v2 &lt;&lt; ' ' &lt;&lt; v3 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v4 &lt;&lt; ' ' &lt;&lt; v5 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v6 &lt;&lt; '\\n';\n\n    for (auto i : v7)\n    {\n        std::cout &lt;&lt; i &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\n\\n\";\n\n    for (auto i : v8)\n    {\n        std::cout &lt;&lt; i.first &lt;&lt; \": \" &lt;&lt; i.second &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1\n42 42\n17.23 17\nHello, world!\n1 2 3 4 5 \n\nstring: \"Hello, world!\"\nnumber: {\"floating-point\":17.23,\"integer\":42}\nnull: null\nboolean: true\narray: [1,2,3,4,5]\n</code></pre> Example <p>The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a <code>#cpp nullptr</code> is returned if the value and the requested pointer type does not match.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON number\n    json value = 17;\n\n    // explicitly getting pointers\n    auto p1 = value.template get&lt;const json::number_integer_t*&gt;();\n    auto p2 = value.template get&lt;json::number_integer_t*&gt;();\n    auto p3 = value.template get&lt;json::number_integer_t* const&gt;();\n    auto p4 = value.template get&lt;const json::number_integer_t* const&gt;();\n    auto p5 = value.template get&lt;json::number_float_t*&gt;();\n\n    // print the pointees\n    std::cout &lt;&lt; *p1 &lt;&lt; ' ' &lt;&lt; *p2 &lt;&lt; ' ' &lt;&lt; *p3 &lt;&lt; ' ' &lt;&lt; *p4 &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (p5 == nullptr) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>17 17 17 17\ntrue\n</code></pre>"},{"location":"api/basic_json/get/#version-history","title":"Version history","text":"<ol> <li>Since version 2.1.0.</li> <li>Since version 2.1.0. Extended to work with other specializations of <code>basic_json</code> in version 3.2.0.</li> <li>Since version 1.0.0.</li> </ol>"},{"location":"api/basic_json/get_allocator/","title":"nlohmann::basic_json::get_allocator","text":"<pre><code>static allocator_type get_allocator();\n</code></pre> <p>Returns the allocator associated with the container.</p>"},{"location":"api/basic_json/get_allocator/#return-value","title":"Return value","text":"<p>associated allocator</p>"},{"location":"api/basic_json/get_allocator/#examples","title":"Examples","text":"Example <p>The example shows how <code>get_allocator()</code> is used to created <code>json</code> values.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    auto alloc = json::get_allocator();\n    using traits_t = std::allocator_traits&lt;decltype(alloc)&gt;;\n\n    json* j = traits_t::allocate(alloc, 1);\n    traits_t::construct(alloc, j, \"Hello, world!\");\n\n    std::cout &lt;&lt; *j &lt;&lt; std::endl;\n\n    traits_t::destroy(alloc, j);\n    traits_t::deallocate(alloc, j, 1);\n}\n</code></pre> <p>Output:</p> <pre><code>\"Hello, world!\"\n</code></pre>"},{"location":"api/basic_json/get_allocator/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/get_binary/","title":"nlohmann::basic_json::get_binary","text":"<pre><code>binary_t&amp; get_binary();\n\nconst binary_t&amp; get_binary() const;\n</code></pre> <p>Returns a reference to the stored binary value.</p>"},{"location":"api/basic_json/get_binary/#return-value","title":"Return value","text":"<p>Reference to binary value.</p>"},{"location":"api/basic_json/get_binary/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/get_binary/#exceptions","title":"Exceptions","text":"<p>Throws <code>type_error.302</code> if the value is not binary</p>"},{"location":"api/basic_json/get_binary/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/get_binary/#examples","title":"Examples","text":"Example <p>The following code shows how to query a binary value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a binary vector\n    std::vector&lt;std::uint8_t&gt; vec = {0xCA, 0xFE, 0xBA, 0xBE};\n\n    // create a binary JSON value with subtype 42\n    json j = json::binary(vec, 42);\n\n    // output type and subtype\n    std::cout &lt;&lt; \"type: \" &lt;&lt; j.type_name() &lt;&lt; \", subtype: \" &lt;&lt; j.get_binary().subtype() &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>type: binary, subtype: 42\n</code></pre>"},{"location":"api/basic_json/get_binary/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/get_ptr/","title":"nlohmann::basic_json::get_ptr","text":"<pre><code>template&lt;typename PointerType&gt;\nPointerType get_ptr() noexcept;\n\ntemplate&lt;typename PointerType&gt;\nconstexpr const PointerType get_ptr() const noexcept;\n</code></pre> <p>Implicit pointer access to the internally stored JSON value. No copies are made.</p>"},{"location":"api/basic_json/get_ptr/#template-parameters","title":"Template parameters","text":"<code>PointerType</code> pointer type; must be a pointer to <code>array_t</code>, <code>object_t</code>, <code>string_t</code>, <code>boolean_t</code>, <code>number_integer_t</code>, or <code>number_unsigned_t</code>, <code>number_float_t</code>, or <code>binary_t</code>. Other types will not compile."},{"location":"api/basic_json/get_ptr/#return-value","title":"Return value","text":"<p>pointer to the internally stored JSON value if the requested pointer type fits to the JSON value; <code>nullptr</code> otherwise</p>"},{"location":"api/basic_json/get_ptr/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/get_ptr/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/get_ptr/#notes","title":"Notes","text":"<p>Undefined behavior</p> <p>The pointer becomes invalid if the underlying JSON object changes.</p> <p>Consider the following example code where the pointer <code>ptr</code> changes after the array is resized. As a result, reading or writing to <code>ptr</code> after the array change would be undefined behavior. The address of the first array element changes, because the underlying <code>std::vector</code> is resized after adding a fifth element.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j = {1, 2, 3, 4};\n    auto* ptr = j[0].get_ptr&lt;std::int64_t*&gt;();\n    std::cout &lt;&lt; \"value at \" &lt;&lt; ptr &lt;&lt; \" is \" &lt;&lt; *ptr &lt;&lt; std::endl;\n\n    j.push_back(5);\n\n    ptr = j[0].get_ptr&lt;std::int64_t*&gt;();\n    std::cout &lt;&lt; \"value at \" &lt;&lt; ptr &lt;&lt; \" is \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>value at 0x6000012fc1c8 is 1\nvalue at 0x6000029fc088 is 1\n</code></pre>"},{"location":"api/basic_json/get_ptr/#examples","title":"Examples","text":"Example <p>The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a <code>nullptr</code> is returned if the value and the requested pointer type does not match.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON number\n    json value = 17;\n\n    // explicitly getting pointers\n    auto p1 = value.get_ptr&lt;const json::number_integer_t*&gt;();\n    auto p2 = value.get_ptr&lt;json::number_integer_t*&gt;();\n    auto p3 = value.get_ptr&lt;json::number_integer_t* const&gt;();\n    auto p4 = value.get_ptr&lt;const json::number_integer_t* const&gt;();\n    auto p5 = value.get_ptr&lt;json::number_float_t*&gt;();\n\n    // print the pointees\n    std::cout &lt;&lt; *p1 &lt;&lt; ' ' &lt;&lt; *p2 &lt;&lt; ' ' &lt;&lt; *p3 &lt;&lt; ' ' &lt;&lt; *p4 &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (p5 == nullptr) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>17 17 17 17\ntrue\n</code></pre>"},{"location":"api/basic_json/get_ptr/#see-also","title":"See also","text":"<ul> <li>get_ref() get a reference value</li> </ul>"},{"location":"api/basic_json/get_ptr/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended to binary types in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/get_ref/","title":"nlohmann::basic_json::get_ref","text":"<pre><code>template&lt;typename ReferenceType&gt;\nReferenceType get_ref();\n\ntemplate&lt;typename ReferenceType&gt;\nconst ReferenceType get_ref() const;\n</code></pre> <p>Implicit reference access to the internally stored JSON value. No copies are made.</p>"},{"location":"api/basic_json/get_ref/#template-parameters","title":"Template parameters","text":"<code>ReferenceType</code> reference type; must be a reference to <code>array_t</code>, <code>object_t</code>, <code>string_t</code>, <code>boolean_t</code>, <code>number_integer_t</code>, or <code>number_unsigned_t</code>, <code>number_float_t</code>, or <code>binary_t</code>. Enforced by a static assertion."},{"location":"api/basic_json/get_ref/#return-value","title":"Return value","text":"<p>reference to the internally stored JSON value if the requested reference type fits to the JSON value; throws <code>type_error.303</code> otherwise</p>"},{"location":"api/basic_json/get_ref/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/get_ref/#exceptions","title":"Exceptions","text":"<p>Throws <code>type_error.303</code> if the requested reference type does not match the stored JSON value type; example: <code>\"incompatible ReferenceType for get_ref, actual type is binary\"</code>.</p>"},{"location":"api/basic_json/get_ref/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/get_ref/#notes","title":"Notes","text":"<p>Undefined behavior</p> <p>The reference becomes invalid if the underlying JSON object changes.</p>"},{"location":"api/basic_json/get_ref/#examples","title":"Examples","text":"Example <p>The example shows several calls to <code>get_ref()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON number\n    json value = 17;\n\n    // explicitly getting references\n    auto r1 = value.get_ref&lt;const json::number_integer_t&amp;&gt;();\n    auto r2 = value.get_ref&lt;json::number_integer_t&amp;&gt;();\n\n    // print the values\n    std::cout &lt;&lt; r1 &lt;&lt; ' ' &lt;&lt; r2 &lt;&lt; '\\n';\n\n    // incompatible type throws exception\n    try\n    {\n        auto r3 = value.get_ref&lt;json::number_float_t&amp;&gt;();\n    }\n    catch (const json::type_error&amp; ex)\n    {\n        std::cout &lt;&lt; ex.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>17 17\n[json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is number\n</code></pre>"},{"location":"api/basic_json/get_ref/#see-also","title":"See also","text":"<ul> <li>get_ptr() get a pointer value</li> </ul>"},{"location":"api/basic_json/get_ref/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.1.0.</li> <li>Extended to binary types in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/get_to/","title":"nlohmann::basic_json::get_to","text":"<pre><code>template&lt;typename ValueType&gt;\nValueType&amp; get_to(ValueType&amp; v) const noexcept(\n    noexcept(JSONSerializer&lt;ValueType&gt;::from_json(\n        std::declval&lt;const basic_json_t&amp;&gt;(), v)));\n</code></pre> <p>Explicit type conversion between the JSON value and a compatible value. The value is filled into the input parameter by calling the <code>json_serializer&lt;ValueType&gt;</code> <code>from_json()</code> method.</p> <p>The function is equivalent to executing <pre><code>ValueType v;\nJSONSerializer&lt;ValueType&gt;::from_json(*this, v);\n</code></pre></p> <p>This overload is chosen if:</p> <ul> <li><code>ValueType</code> is not <code>basic_json</code>,</li> <li><code>json_serializer&lt;ValueType&gt;</code> has a <code>from_json()</code> method of the form <code>void from_json(const basic_json&amp;, ValueType&amp;)</code></li> </ul>"},{"location":"api/basic_json/get_to/#template-parameters","title":"Template parameters","text":"<code>ValueType</code> the value type to return"},{"location":"api/basic_json/get_to/#return-value","title":"Return value","text":"<p>the input parameter, allowing chaining calls</p>"},{"location":"api/basic_json/get_to/#exceptions","title":"Exceptions","text":"<p>Depends on what <code>json_serializer&lt;ValueType&gt;</code> <code>from_json()</code> method throws</p>"},{"location":"api/basic_json/get_to/#examples","title":"Examples","text":"Example <p>The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>, (3) A JSON object can be converted to C++ associative containers such as <code>#cpp std::unordered_map&lt;std::string, json&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON value with different types\n    json json_types =\n    {\n        {\"boolean\", true},\n        {\n            \"number\", {\n                {\"integer\", 42},\n                {\"floating-point\", 17.23}\n            }\n        },\n        {\"string\", \"Hello, world!\"},\n        {\"array\", {1, 2, 3, 4, 5}},\n        {\"null\", nullptr}\n    };\n\n    bool v1;\n    int v2;\n    short v3;\n    float v4;\n    int v5;\n    std::string v6;\n    std::vector&lt;short&gt; v7;\n    std::unordered_map&lt;std::string, json&gt; v8;\n\n    // use explicit conversions\n    json_types[\"boolean\"].get_to(v1);\n    json_types[\"number\"][\"integer\"].get_to(v2);\n    json_types[\"number\"][\"integer\"].get_to(v3);\n    json_types[\"number\"][\"floating-point\"].get_to(v4);\n    json_types[\"number\"][\"floating-point\"].get_to(v5);\n    json_types[\"string\"].get_to(v6);\n    json_types[\"array\"].get_to(v7);\n    json_types.get_to(v8);\n\n    // print the conversion results\n    std::cout &lt;&lt; v1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v2 &lt;&lt; ' ' &lt;&lt; v3 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v4 &lt;&lt; ' ' &lt;&lt; v5 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v6 &lt;&lt; '\\n';\n\n    for (auto i : v7)\n    {\n        std::cout &lt;&lt; i &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\n\\n\";\n\n    for (auto i : v8)\n    {\n        std::cout &lt;&lt; i.first &lt;&lt; \": \" &lt;&lt; i.second &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1\n42 42\n17.23 17\nHello, world!\n1 2 3 4 5 \n\nstring: \"Hello, world!\"\nnumber: {\"floating-point\":17.23,\"integer\":42}\nnull: null\nboolean: true\narray: [1,2,3,4,5]\n</code></pre>"},{"location":"api/basic_json/get_to/#version-history","title":"Version history","text":"<ul> <li>Since version 3.3.0.</li> </ul>"},{"location":"api/basic_json/input_format_t/","title":"nlohmann::basic_json::input_format_t","text":"<pre><code>enum class input_format_t {\n    json,\n    cbor,\n    msgpack,\n    ubjson,\n    bson,\n    bjdata\n};\n</code></pre> <p>This enumeration is used in the <code>sax_parse</code> function to choose the input format to parse:</p> json JSON (JavaScript Object Notation) cbor CBOR (Concise Binary Object Representation) msgpack MessagePack ubjson UBJSON (Universal Binary JSON) bson BSON (Binary JSON) bjdata BJData (Binary JData)"},{"location":"api/basic_json/input_format_t/#examples","title":"Examples","text":"Example <p>The example below shows how an <code>input_format_t</code> enum value is passed to <code>sax_parse</code> to set the input format to CBOR.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // CBOR byte string\n    std::vector&lt;std::uint8_t&gt; vec = {{0x44, 0xcA, 0xfe, 0xba, 0xbe}};\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse CBOR\n    bool result = json::sax_parse(vec, &amp;sec, json::input_format_t::cbor);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>binary(val=[...])\n\nresult: true\n</code></pre>"},{"location":"api/basic_json/input_format_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/basic_json/insert/","title":"nlohmann::basic_json::insert","text":"<pre><code>// (1)\niterator insert(const_iterator pos, const basic_json&amp; val);\niterator insert(const_iterator pos, basic_json&amp;&amp; val);\n\n// (2)\niterator insert(const_iterator pos, size_type cnt, const basic_json&amp; val);\n\n// (3)\niterator insert(const_iterator pos, const_iterator first, const_iterator last);\n\n// (4)\niterator insert(const_iterator pos, initializer_list_t ilist);\n\n// (5)\nvoid insert(const_iterator first, const_iterator last);\n</code></pre> <ol> <li>Inserts element <code>val</code> into an array before iterator <code>pos</code>.</li> <li>Inserts <code>cnt</code> copies of <code>val</code> into an array before iterator <code>pos</code>.</li> <li>Inserts elements from range <code>[first, last)</code> into an array before iterator <code>pos</code>.</li> <li>Inserts elements from initializer list <code>ilist</code> into an array before iterator <code>pos</code>.</li> <li>Inserts elements from range <code>[first, last)</code> into an object.</li> </ol>"},{"location":"api/basic_json/insert/#iterator-invalidation","title":"Iterator invalidation","text":"<p>For all cases where an element is added to an array, a reallocation can happen, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated. Otherwise, only the <code>end()</code> iterator is invalidated. Also, any iterator or reference after the insertion point will point to the same index, which is now a different value.</p> <p>For <code>ordered_json</code>, also adding an element to an object can yield a reallocation which again invalidates all iterators and all references. Also, any iterator or reference after the insertion point will point to the same index, which is now a different value.</p>"},{"location":"api/basic_json/insert/#parameters","title":"Parameters","text":"<code>pos</code> (in) iterator before which the content will be inserted; may be the <code>end()</code> iterator <code>val</code> (in) value to insert <code>cnt</code> (in) number of copies of <code>val</code> to insert <code>first</code> (in) the start of the range of elements to insert <code>last</code> (in) the end of the range of elements to insert <code>ilist</code> (in) initializer list to insert the values from"},{"location":"api/basic_json/insert/#return-value","title":"Return value","text":"<ol> <li>iterator pointing to the inserted <code>val</code>.</li> <li>iterator pointing to the first element inserted, or <code>pos</code> if <code>cnt==0</code></li> <li>iterator pointing to the first element inserted, or <code>pos</code> if <code>first==last</code></li> <li>iterator pointing to the first element inserted, or <code>pos</code> if <code>ilist</code> is empty</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/insert/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/insert/#exceptions","title":"Exceptions","text":"<ol> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.309</code> if called on JSON values other than   arrays; example: <code>\"cannot use insert() with string\"</code></li> <li>Throws <code>invalid_iterator.202</code> if called on an   iterator which does not belong to the current JSON value; example: <code>\"iterator does not fit current value\"</code></li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.309</code> if called on JSON values other than   arrays; example: <code>\"cannot use insert() with string\"</code></li> <li>Throws <code>invalid_iterator.202</code> if called on an   iterator which does not belong to the current JSON value; example: <code>\"iterator does not fit current value\"</code></li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.309</code> if called on JSON values other than   arrays; example: <code>\"cannot use insert() with string\"</code></li> <li>Throws <code>invalid_iterator.202</code> if called on an   iterator which does not belong to the current JSON value; example: <code>\"iterator does not fit current value\"</code></li> <li>Throws <code>invalid_iterator.210</code> if <code>first</code> and <code>last</code>   do not belong to the same JSON value; example: <code>\"iterators do not fit\"</code></li> <li>Throws <code>invalid_iterator.211</code> if <code>first</code> or <code>last</code>   are iterators into container for which insert is called; example: <code>\"passed iterators may not belong to container\"</code></li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.309</code> if called on JSON values other than   arrays; example: <code>\"cannot use insert() with string\"</code></li> <li>Throws <code>invalid_iterator.202</code> if called on an   iterator which does not belong to the current JSON value; example: <code>\"iterator does not fit current value\"</code></li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.309</code> if called on JSON values other than   objects; example: <code>\"cannot use insert() with string\"</code></li> <li>Throws <code>invalid_iterator.202</code> if called on an   iterator which does not belong to the current JSON value; example: <code>\"iterator does not fit current value\"</code></li> <li>Throws <code>invalid_iterator.210</code> if <code>first</code> and <code>last</code>   do not belong to the same JSON value; example: <code>\"iterators do not fit\"</code></li> </ul> </li> </ol>"},{"location":"api/basic_json/insert/#complexity","title":"Complexity","text":"<ol> <li>Constant plus linear in the distance between <code>pos</code> and end of the container.</li> <li>Linear in <code>cnt</code> plus linear in the distance between <code>pos</code> and end of the container.</li> <li>Linear in <code>std::distance(first, last)</code> plus linear in the distance between <code>pos</code> and end of the container.</li> <li>Linear in <code>ilist.size()</code> plus linear in the distance between <code>pos</code> and end of the container.</li> <li>Logarithmic: <code>O(N*log(size() + N))</code>, where <code>N</code> is the number of elements to insert.</li> </ol>"},{"location":"api/basic_json/insert/#examples","title":"Examples","text":"Example (1): insert element into array <p>The example shows how <code>insert()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON array\n    json v = {1, 2, 3, 4};\n\n    // insert number 10 before number 3\n    auto new_pos = v.insert(v.begin() + 2, 10);\n\n    // output new array and result of insert call\n    std::cout &lt;&lt; *new_pos &lt;&lt; '\\n';\n    std::cout &lt;&lt; v &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>10\n[1,2,10,3,4]\n</code></pre> Example (2): insert copies of element into array <p>The example shows how <code>insert()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON array\n    json v = {1, 2, 3, 4};\n\n    // insert number 7 copies of number 7 before number 3\n    auto new_pos = v.insert(v.begin() + 2, 7, 7);\n\n    // output new array and result of insert call\n    std::cout &lt;&lt; *new_pos &lt;&lt; '\\n';\n    std::cout &lt;&lt; v &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>7\n[1,2,7,7,7,7,7,7,7,3,4]\n</code></pre> Example (3): insert a range of elements into an array <p>The example shows how <code>insert()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON array\n    json v = {1, 2, 3, 4};\n\n    // create a JSON array to copy values from\n    json v2 = {\"one\", \"two\", \"three\", \"four\"};\n\n    // insert range from v2 before the end of array v\n    auto new_pos = v.insert(v.end(), v2.begin(), v2.end());\n\n    // output new array and result of insert call\n    std::cout &lt;&lt; *new_pos &lt;&lt; '\\n';\n    std::cout &lt;&lt; v &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>\"one\"\n[1,2,3,4,\"one\",\"two\",\"three\",\"four\"]\n</code></pre> Example (4): insert elements from an initializer list into an array <p>The example shows how <code>insert()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON array\n    json v = {1, 2, 3, 4};\n\n    // insert range from v2 before the end of array v\n    auto new_pos = v.insert(v.end(), {7, 8, 9});\n\n    // output new array and result of insert call\n    std::cout &lt;&lt; *new_pos &lt;&lt; '\\n';\n    std::cout &lt;&lt; v &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>7\n[1,2,3,4,7,8,9]\n</code></pre> Example (5): insert a range of elements into an object <p>The example shows how <code>insert()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create two JSON objects\n    json j1 = {{\"one\", \"eins\"}, {\"two\", \"zwei\"}};\n    json j2 = {{\"eleven\", \"elf\"}, {\"seventeen\", \"siebzehn\"}};\n\n    // output objects\n    std::cout &lt;&lt; j1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; j2 &lt;&lt; '\\n';\n\n    // insert range from j2 to j1\n    j1.insert(j2.begin(), j2.end());\n\n    // output result of insert call\n    std::cout &lt;&lt; j1 &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":\"eins\",\"two\":\"zwei\"}\n{\"eleven\":\"elf\",\"seventeen\":\"siebzehn\"}\n{\"eleven\":\"elf\",\"one\":\"eins\",\"seventeen\":\"siebzehn\",\"two\":\"zwei\"}\n</code></pre>"},{"location":"api/basic_json/insert/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0.</li> <li>Added in version 1.0.0.</li> <li>Added in version 1.0.0.</li> <li>Added in version 1.0.0.</li> <li>Added in version 3.0.0.</li> </ol>"},{"location":"api/basic_json/invalid_iterator/","title":"nlohmann::basic_json::invalid_iterator","text":"<pre><code>class invalid_iterator : public exception;\n</code></pre> <p>This exception is thrown if iterators passed to a library function do not match the expected semantics.</p> <p>Exceptions have ids 2xx (see list of iterator errors).</p> <pre><code>classDiagram\n  direction LR\n\n    class std_exception [\"std::exception\"] {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n\n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception &lt;|-- json_exception\n    json_exception &lt;|-- json_parse_error\n    json_exception &lt;|-- json_invalid_iterator\n    json_exception &lt;|-- json_type_error\n    json_exception &lt;|-- json_out_of_range\n    json_exception &lt;|-- json_other_error\n\n    style json_invalid_iterator fill:#CCCCFF</code></pre>"},{"location":"api/basic_json/invalid_iterator/#member-functions","title":"Member functions","text":"<ul> <li>what - returns explanatory string</li> </ul>"},{"location":"api/basic_json/invalid_iterator/#member-variables","title":"Member variables","text":"<ul> <li>id - the id of the exception</li> </ul>"},{"location":"api/basic_json/invalid_iterator/#examples","title":"Examples","text":"Example <p>The following code shows how a <code>invalid_iterator</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // calling iterator::key() on non-object iterator\n        json j = \"string\";\n        json::iterator it = j.begin();\n        auto k = it.key();\n    }\n    catch (const json::invalid_iterator&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.invalid_iterator.207] cannot use key() for non-object iterators\nexception id: 207\n</code></pre>"},{"location":"api/basic_json/invalid_iterator/#see-also","title":"See also","text":"<ul> <li>List of iterator errors</li> <li><code>parse_error</code> for exceptions indicating a parse error</li> <li><code>type_error</code> for exceptions indicating executing a member function with a wrong type</li> <li><code>out_of_range</code> for exceptions indicating access out of the defined range</li> <li><code>other_error</code> for exceptions indicating other library errors</li> </ul>"},{"location":"api/basic_json/invalid_iterator/#version-history","title":"Version history","text":"<ul> <li>Since version 3.0.0.</li> </ul>"},{"location":"api/basic_json/is_array/","title":"nlohmann::basic_json::is_array","text":"<pre><code>constexpr bool is_array() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is an array.</p>"},{"location":"api/basic_json/is_array/#return-value","title":"Return value","text":"<p><code>true</code> if type is an array, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_array/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_array/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_array/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_array()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_array()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_array() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_array() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_array/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/is_binary/","title":"nlohmann::basic_json::is_binary","text":"<pre><code>constexpr bool is_binary() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is a binary array.</p>"},{"location":"api/basic_json/is_binary/#return-value","title":"Return value","text":"<p><code>true</code> if type is binary, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_binary/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_binary/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_binary/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_binary()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_binary()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_binary() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_binary() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\n</code></pre>"},{"location":"api/basic_json/is_binary/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/is_boolean/","title":"nlohmann::basic_json::is_boolean","text":"<pre><code>constexpr bool is_boolean() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is <code>true</code> or <code>false</code>.</p>"},{"location":"api/basic_json/is_boolean/#return-value","title":"Return value","text":"<p><code>true</code> if type is boolean, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_boolean/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_boolean/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_boolean/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_boolean()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_boolean()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_boolean() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_boolean() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_boolean/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/is_discarded/","title":"nlohmann::basic_json::is_discarded","text":"<pre><code>constexpr bool is_discarded() const noexcept;\n</code></pre> <p>This function returns <code>true</code> for a JSON value if either:</p> <ul> <li>the value was discarded during parsing with a callback function (see <code>parser_callback_t</code>), or</li> <li>the value is the result of parsing invalid JSON with parameter <code>allow_exceptions</code> set to <code>false</code>; see   <code>parse</code> for more information.</li> </ul>"},{"location":"api/basic_json/is_discarded/#return-value","title":"Return value","text":"<p><code>true</code> if type is discarded, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_discarded/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_discarded/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_discarded/#notes","title":"Notes","text":"<p>Comparisons</p> <p>Discarded values are never compared equal with <code>operator==</code>. That is, checking whether a JSON value <code>j</code> is discarded will only work via:</p> <pre><code>j.is_discarded()\n</code></pre> <p>because</p> <pre><code>j == json::value_t::discarded\n</code></pre> <p>will always be <code>false</code>.</p> <p>Removal during parsing with callback functions</p> <p>When a value is discarded by a callback function (see <code>parser_callback_t</code>) during parsing, then it is removed when it is part of a structured value. For instance, if the second value of an array is discarded, instead of <code>[null, discarded, false]</code>, the array <code>[null, false]</code> is returned. Only if the top-level value is discarded, the return value of the <code>parse</code> call is discarded.</p> <p>This function will always be <code>false</code> for JSON values after parsing. That is, discarded values can only occur during parsing, but will be removed when inside a structured value or replaced by null in other cases.</p>"},{"location":"api/basic_json/is_discarded/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_discarded()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_discarded()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_discarded() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_discarded() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_discarded/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/is_null/","title":"nlohmann::basic_json::is_null","text":"<pre><code>constexpr bool is_null() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is <code>null</code>.</p>"},{"location":"api/basic_json/is_null/#return-value","title":"Return value","text":"<p><code>true</code> if type is <code>null</code>, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_null/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_null/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_null/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_null()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_null()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_null() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_null() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_null/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/is_number/","title":"nlohmann::basic_json::is_number","text":"<pre><code>constexpr bool is_number() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is a number. This includes both integer (signed and unsigned) and floating-point values.</p>"},{"location":"api/basic_json/is_number/#return-value","title":"Return value","text":"<p><code>true</code> if type is number (regardless whether integer, unsigned integer, or floating-type), <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_number/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_number/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_number/#possible-implementation","title":"Possible implementation","text":"<pre><code>constexpr bool is_number() const noexcept\n{\n    return is_number_integer() || is_number_float();\n}\n</code></pre>"},{"location":"api/basic_json/is_number/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_number()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_number()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_number() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_number() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_number/#see-also","title":"See also","text":"<ul> <li>is_number_integer() check if the value is an integer or unsigned integer number</li> <li>is_number_unsigned() check if the value is an unsigned integer number</li> <li>is_number_float() check if the value is a floating-point number</li> </ul>"},{"location":"api/basic_json/is_number/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended to also return <code>true</code> for unsigned integers in 2.0.0.</li> </ul>"},{"location":"api/basic_json/is_number_float/","title":"nlohmann::basic_json::is_number_float","text":"<pre><code>constexpr bool is_number_float() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is a floating-point number. This excludes signed and unsigned integer values.</p>"},{"location":"api/basic_json/is_number_float/#return-value","title":"Return value","text":"<p><code>true</code> if type is a floating-point number, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_number_float/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_number_float/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_number_float/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_number_float()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_number_float()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_number_float() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_number_float() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_number_float/#see-also","title":"See also","text":"<ul> <li>is_number() check if the value is a number</li> <li>is_number_integer() check if the value is an integer or unsigned integer number</li> <li>is_number_unsigned() check if the value is an unsigned integer number</li> </ul>"},{"location":"api/basic_json/is_number_float/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/is_number_integer/","title":"nlohmann::basic_json::is_number_integer","text":"<pre><code>constexpr bool is_number_integer() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is a signed or unsigned integer number. This excludes floating-point values.</p>"},{"location":"api/basic_json/is_number_integer/#return-value","title":"Return value","text":"<p><code>true</code> if type is an integer or unsigned integer number, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_number_integer/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_number_integer/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_number_integer/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_number_integer()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_number_integer()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_number_integer() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_number_integer() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_number_integer/#see-also","title":"See also","text":"<ul> <li>is_number() check if the value is a number</li> <li>is_number_unsigned() check if the value is an unsigned integer number</li> <li>is_number_float() check if the value is a floating-point number</li> </ul>"},{"location":"api/basic_json/is_number_integer/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended to also return <code>true</code> for unsigned integers in 2.0.0.</li> </ul>"},{"location":"api/basic_json/is_number_unsigned/","title":"nlohmann::basic_json::is_number_unsigned","text":"<pre><code>constexpr bool is_number_unsigned() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is an unsigned integer number. This excludes floating-point and signed integer values.</p>"},{"location":"api/basic_json/is_number_unsigned/#return-value","title":"Return value","text":"<p><code>true</code> if type is an unsigned integer number, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_number_unsigned/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_number_unsigned/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_number_unsigned/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_number_unsigned()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_number_unsigned()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_number_unsigned() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_number_unsigned() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_number_unsigned/#see-also","title":"See also","text":"<ul> <li>is_number() check if the value is a number</li> <li>is_number_integer() check if the value is an integer or unsigned integer number</li> <li>is_number_float() check if the value is a floating-point number</li> </ul>"},{"location":"api/basic_json/is_number_unsigned/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> </ul>"},{"location":"api/basic_json/is_object/","title":"nlohmann::basic_json::is_object","text":"<pre><code>constexpr bool is_object() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is an object.</p>"},{"location":"api/basic_json/is_object/#return-value","title":"Return value","text":"<p><code>true</code> if type is an object, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_object/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_object/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_object/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_object()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_object()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_object() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_object() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_object/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/is_primitive/","title":"nlohmann::basic_json::is_primitive","text":"<pre><code>constexpr bool is_primitive() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON type is primitive (string, number, boolean, <code>null</code>, binary).</p>"},{"location":"api/basic_json/is_primitive/#return-value","title":"Return value","text":"<p><code>true</code> if type is primitive (string, number, boolean, <code>null</code>, or binary), <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_primitive/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_primitive/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_primitive/#possible-implementation","title":"Possible implementation","text":"<pre><code>constexpr bool is_primitive() const noexcept\n{\n    return is_null() || is_string() || is_boolean() || is_number() || is_binary();\n}\n</code></pre>"},{"location":"api/basic_json/is_primitive/#notes","title":"Notes","text":"<p>The term primitive stems from RFC 8259:</p> <p>JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays).</p> <p>This library extends primitive types to binary types, because binary types are roughly comparable to strings. Hence, <code>is_primitive()</code> returns <code>true</code> for binary values.</p>"},{"location":"api/basic_json/is_primitive/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_primitive()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_primitive()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_primitive() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_primitive() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\n</code></pre>"},{"location":"api/basic_json/is_primitive/#see-also","title":"See also","text":"<ul> <li>is_structured() returns whether the JSON value is structured</li> <li>is_null() returns whether the JSON value is <code>null</code></li> <li>is_string() returns whether the JSON value is a string</li> <li>is_boolean() returns whether the JSON value is a boolean</li> <li>is_number() returns whether the JSON value is a number</li> <li>is_binary() returns whether the JSON value is a binary array</li> </ul>"},{"location":"api/basic_json/is_primitive/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended to return <code>true</code> for binary types in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/is_string/","title":"nlohmann::basic_json::is_string","text":"<pre><code>constexpr bool is_string() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON value is a string.</p>"},{"location":"api/basic_json/is_string/#return-value","title":"Return value","text":"<p><code>true</code> if type is a string, <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_string/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_string/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_string/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_string()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_string()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_string() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_string() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\n</code></pre>"},{"location":"api/basic_json/is_string/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/is_structured/","title":"nlohmann::basic_json::is_structured","text":"<pre><code>constexpr bool is_structured() const noexcept;\n</code></pre> <p>This function returns <code>true</code> if and only if the JSON type is structured (array or object).</p>"},{"location":"api/basic_json/is_structured/#return-value","title":"Return value","text":"<p><code>true</code> if type is structured (array or object), <code>false</code> otherwise.</p>"},{"location":"api/basic_json/is_structured/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/is_structured/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/is_structured/#possible-implementation","title":"Possible implementation","text":"<pre><code>constexpr bool is_structured() const noexcept\n{\n    return is_array() || is_object();\n}\n</code></pre>"},{"location":"api/basic_json/is_structured/#notes","title":"Notes","text":"<p>The term structured stems from RFC 8259:</p> <p>JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays).</p> <p>Note that though strings are containers in C++, they are treated as primitive values in JSON.</p>"},{"location":"api/basic_json/is_structured/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>is_structured()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_number_unsigned_integer = 12345678987654321u;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n    json j_binary = json::binary({1, 2, 3});\n\n    // call is_structured()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; j_null.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned_integer.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.is_structured() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_binary.is_structured() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>false\nfalse\nfalse\nfalse\nfalse\ntrue\ntrue\nfalse\nfalse\n</code></pre>"},{"location":"api/basic_json/is_structured/#see-also","title":"See also","text":"<ul> <li>is_primitive() returns whether JSON value is primitive</li> <li>is_array() returns whether the value is an array</li> <li>is_object() returns whether the value is an object</li> </ul>"},{"location":"api/basic_json/is_structured/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/items/","title":"nlohmann::basic_json::items","text":"<pre><code>iteration_proxy&lt;iterator&gt; items() noexcept;\niteration_proxy&lt;const_iterator&gt; items() const noexcept;\n</code></pre> <p>This function allows accessing <code>iterator::key()</code> and <code>iterator::value()</code> during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator.</p> <p>For loop without <code>items()</code> function:</p> <pre><code>for (auto it = j_object.begin(); it != j_object.end(); ++it)\n{\n    std::cout &lt;&lt; \"key: \" &lt;&lt; it.key() &lt;&lt; \", value:\" &lt;&lt; it.value() &lt;&lt; '\\n';\n}\n</code></pre> <p>Range-based for loop without <code>items()</code> function:</p> <pre><code>for (auto it : j_object)\n{\n    // \"it\" is of type json::reference and has no key() member\n    std::cout &lt;&lt; \"value: \" &lt;&lt; it &lt;&lt; '\\n';\n}\n</code></pre> <p>Range-based for loop with <code>items()</code> function:</p> <pre><code>for (auto&amp; el : j_object.items())\n{\n    std::cout &lt;&lt; \"key: \" &lt;&lt; el.key() &lt;&lt; \", value:\" &lt;&lt; el.value() &lt;&lt; '\\n';\n}\n</code></pre> <p>The <code>items()</code> function also allows using structured bindings (C++17):</p> <pre><code>for (auto&amp; [key, val] : j_object.items())\n{\n    std::cout &lt;&lt; \"key: \" &lt;&lt; key &lt;&lt; \", value:\" &lt;&lt; val &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"api/basic_json/items/#return-value","title":"Return value","text":"<p>iteration proxy object wrapping the current value with an interface to use in range-based for loops</p>"},{"location":"api/basic_json/items/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/items/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/items/#notes","title":"Notes","text":"<p>When iterating over an array, <code>key()</code> will return the index of the element as string (see example). For primitive types (e.g., numbers), <code>key()</code> returns an empty string.</p> <p>Lifetime issues</p> <p>Using <code>items()</code> on temporary objects is dangerous. Make sure the object's lifetime exceeds the iteration. See #2040 for more information.</p>"},{"location":"api/basic_json/items/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>items()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n\n    // example for an object\n    for (auto&amp; x : j_object.items())\n    {\n        std::cout &lt;&lt; \"key: \" &lt;&lt; x.key() &lt;&lt; \", value: \" &lt;&lt; x.value() &lt;&lt; '\\n';\n    }\n\n    // example for an array\n    for (auto&amp; x : j_array.items())\n    {\n        std::cout &lt;&lt; \"key: \" &lt;&lt; x.key() &lt;&lt; \", value: \" &lt;&lt; x.value() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>key: one, value: 1\nkey: two, value: 2\nkey: 0, value: 1\nkey: 1, value: 2\nkey: 2, value: 4\nkey: 3, value: 8\nkey: 4, value: 16\n</code></pre>"},{"location":"api/basic_json/items/#version-history","title":"Version history","text":"<ul> <li>Added <code>iterator_wrapper</code> in version 3.0.0.</li> <li>Added <code>items</code> and deprecated <code>iterator_wrapper</code> in version 3.1.0.</li> <li>Added structured binding support in version 3.5.0.</li> </ul> <p>Deprecation</p> <p>This function replaces the static function <code>iterator_wrapper</code> which was introduced in version 1.0.0, but has been deprecated in version 3.1.0. Function <code>iterator_wrapper</code> will be removed in version 4.0.0. Please replace all occurrences of <code>iterator_wrapper(j)</code> with <code>j.items()</code>.</p> <p>You should be warned by your compiler with a <code>-Wdeprecated-declarations</code> warning if you are using a deprecated function.</p>"},{"location":"api/basic_json/json_base_class_t/","title":"nlohmann::basic_json::json_base_class_t","text":"<pre><code>using json_base_class_t = detail::json_base_class&lt;CustomBaseClass&gt;;\n</code></pre> <p>The base class used to inject custom functionality into each instance of <code>basic_json</code>. Examples of such functionality might be metadata, additional member functions (e.g., visitors), or other application-specific code.</p>"},{"location":"api/basic_json/json_base_class_t/#template-parameters","title":"Template parameters","text":"<code>CustomBaseClass</code> the base class to be added to <code>basic_json</code>"},{"location":"api/basic_json/json_base_class_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/json_base_class_t/#default-type","title":"Default type","text":"<p>The default value for <code>CustomBaseClass</code> is <code>void</code>. In this case, an empty base class is used and no additional functionality is injected.</p>"},{"location":"api/basic_json/json_base_class_t/#limitations","title":"Limitations","text":"<p>The type <code>CustomBaseClass</code> has to be a default-constructible class. <code>basic_json</code> only supports copy/move construction/assignment if <code>CustomBaseClass</code> does so as well.</p>"},{"location":"api/basic_json/json_base_class_t/#examples","title":"Examples","text":"Example <p>The following code shows how to inject custom data and methods for each node.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nclass visitor_adaptor_with_metadata\n{\n  public:\n    template &lt;class Fnc&gt;\n    void visit(const Fnc&amp; fnc) const;\n\n    int metadata = 42;\n  private:\n    template &lt;class Ptr, class Fnc&gt;\n    void do_visit(const Ptr&amp; ptr, const Fnc&amp; fnc) const;\n};\n\nusing json = nlohmann::basic_json &lt;\n             std::map,\n             std::vector,\n             std::string,\n             bool,\n             std::int64_t,\n             std::uint64_t,\n             double,\n             std::allocator,\n             nlohmann::adl_serializer,\n             std::vector&lt;std::uint8_t&gt;,\n             visitor_adaptor_with_metadata\n             &gt;;\n\ntemplate &lt;class Fnc&gt;\nvoid visitor_adaptor_with_metadata::visit(const Fnc&amp; fnc) const\n{\n    do_visit(json::json_pointer{}, fnc);\n}\n\ntemplate &lt;class Ptr, class Fnc&gt;\nvoid visitor_adaptor_with_metadata::do_visit(const Ptr&amp; ptr, const Fnc&amp; fnc) const\n{\n    using value_t = nlohmann::detail::value_t;\n    const json&amp; j = *static_cast&lt;const json*&gt;(this);\n    switch (j.type())\n    {\n        case value_t::object:\n            fnc(ptr, j);\n            for (const auto&amp; entry : j.items())\n            {\n                entry.value().do_visit(ptr / entry.key(), fnc);\n            }\n            break;\n        case value_t::array:\n            fnc(ptr, j);\n            for (std::size_t i = 0; i &lt; j.size(); ++i)\n            {\n                j.at(i).do_visit(ptr / std::to_string(i), fnc);\n            }\n            break;\n        case value_t::null:\n        case value_t::string:\n        case value_t::boolean:\n        case value_t::number_integer:\n        case value_t::number_unsigned:\n        case value_t::number_float:\n        case value_t::binary:\n            fnc(ptr, j);\n            break;\n        case value_t::discarded:\n        default:\n            break;\n    }\n}\n\nint main()\n{\n    // create a json object\n    json j;\n    j[\"null\"];\n    j[\"object\"][\"uint\"] = 1U;\n    j[\"object\"].metadata = 21;\n\n    // visit and output\n    j.visit(\n         [&amp;](const json::json_pointer &amp; p,\n             const json &amp; j)\n    {\n        std::cout &lt;&lt; (p.empty() ? std::string{\"/\"} : p.to_string())\n                  &lt;&lt; \" - metadata = \" &lt;&lt; j.metadata &lt;&lt; \" -&gt; \" &lt;&lt; j.dump() &lt;&lt; '\\n';\n    });\n}\n</code></pre> <p>Output:</p> <pre><code>/ - metadata = 42 -&gt; {\"null\":null,\"object\":{\"uint\":1}}\n/null - metadata = 42 -&gt; null\n/object - metadata = 21 -&gt; {\"uint\":1}\n/object/uint - metadata = 42 -&gt; 1\n</code></pre>"},{"location":"api/basic_json/json_base_class_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.12.0.</li> </ul>"},{"location":"api/basic_json/json_serializer/","title":"nlohmann::basic_json::json_serializer","text":"<pre><code>template&lt;typename T, typename SFINAE&gt;\nusing json_serializer = JSONSerializer&lt;T, SFINAE&gt;;\n</code></pre>"},{"location":"api/basic_json/json_serializer/#template-parameters","title":"Template parameters","text":"<code>T</code> type to convert; will be used in the <code>to_json</code>/<code>from_json</code> functions <code>SFINAE</code> type to add compile type checks via SFINAE; usually <code>void</code>"},{"location":"api/basic_json/json_serializer/#notes","title":"Notes","text":""},{"location":"api/basic_json/json_serializer/#default-type","title":"Default type","text":"<p>The default values for <code>json_serializer</code> is <code>adl_serializer</code>.</p>"},{"location":"api/basic_json/json_serializer/#examples","title":"Examples","text":"Example <p>The example below shows how a conversion of a non-default-constructible type is implemented via a specialization of the <code>adl_serializer</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nnamespace ns\n{\n// a simple struct to model a person (not default constructible)\nstruct person\n{\n    person(std::string n, std::string a, int aa)\n        : name(std::move(n)), address(std::move(a)), age(aa)\n    {}\n\n    std::string name;\n    std::string address;\n    int age;\n};\n} // namespace ns\n\nnamespace nlohmann\n{\ntemplate &lt;&gt;\nstruct adl_serializer&lt;ns::person&gt;\n{\n    static ns::person from_json(const json&amp; j)\n    {\n        return {j.at(\"name\"), j.at(\"address\"), j.at(\"age\")};\n    }\n\n    // Here's the catch! You must provide a to_json method! Otherwise, you\n    // will not be able to convert person to json, since you fully\n    // specialized adl_serializer on that type\n    static void to_json(json&amp; j, ns::person p)\n    {\n        j[\"name\"] = p.name;\n        j[\"address\"] = p.address;\n        j[\"age\"] = p.age;\n    }\n};\n} // namespace nlohmann\n\nint main()\n{\n    json j;\n    j[\"name\"] = \"Ned Flanders\";\n    j[\"address\"] = \"744 Evergreen Terrace\";\n    j[\"age\"] = 60;\n\n    auto p = j.template get&lt;ns::person&gt;();\n\n    std::cout &lt;&lt; p.name &lt;&lt; \" (\" &lt;&lt; p.age &lt;&lt; \") lives in \" &lt;&lt; p.address &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>Ned Flanders (60) lives in 744 Evergreen Terrace\n</code></pre>"},{"location":"api/basic_json/json_serializer/#version-history","title":"Version history","text":"<ul> <li>Since version 2.0.0.</li> </ul>"},{"location":"api/basic_json/max_size/","title":"nlohmann::basic_json::max_size","text":"<pre><code>size_type max_size() const noexcept;\n</code></pre> <p>Returns the maximum number of elements a JSON value is able to hold due to system or library implementation limitations, i.e. <code>std::distance(begin(), end())</code> for the JSON value.</p>"},{"location":"api/basic_json/max_size/#return-value","title":"Return value","text":"<p>The return value depends on the different types and is defined as follows:</p> Value type return value null <code>0</code> (same as <code>size()</code>) boolean <code>1</code> (same as <code>size()</code>) string <code>1</code> (same as <code>size()</code>) number <code>1</code> (same as <code>size()</code>) binary <code>1</code> (same as <code>size()</code>) object result of function <code>object_t::max_size()</code> array result of function <code>array_t::max_size()</code>"},{"location":"api/basic_json/max_size/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/max_size/#complexity","title":"Complexity","text":"<p>Constant, as long as <code>array_t</code> and <code>object_t</code> satisfy the Container concept; that is, their <code>max_size()</code> functions have constant complexity.</p>"},{"location":"api/basic_json/max_size/#notes","title":"Notes","text":"<p>This function does not return the maximal length of a string stored as JSON value -- it returns the maximal number of string elements the JSON value can store which is <code>1</code>.</p>"},{"location":"api/basic_json/max_size/#examples","title":"Examples","text":"Example <p>The following code calls <code>max_size()</code> on the different value types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call max_size()\n    std::cout &lt;&lt; j_null.max_size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.max_size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.max_size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.max_size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.max_size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.max_size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.max_size() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>0\n1\n1\n1\n115292150460684697\n576460752303423487\n1\n</code></pre> <p>Note the output is platform-dependent.</p>"},{"location":"api/basic_json/max_size/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended to return <code>1</code> for binary types in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/merge_patch/","title":"nlohmann::basic_json::merge_patch","text":"<pre><code>void merge_patch(const basic_json&amp; apply_patch);\n</code></pre> <p>The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. This function applies a merge patch to the current JSON value.</p> <p>The function implements the following algorithm from Section 2 of RFC 7396 (JSON Merge Patch):</p> <pre><code>define MergePatch(Target, Patch):\n  if Patch is an Object:\n    if Target is not an Object:\n      Target = {} // Ignore the contents and set it to an empty Object\n    for each Name/Value pair in Patch:\n      if Value is null:\n        if Name exists in Target:\n          remove the Name/Value pair from Target\n      else:\n        Target[Name] = MergePatch(Target[Name], Value)\n    return Target\n  else:\n    return Patch\n</code></pre> <p>Thereby, <code>Target</code> is the current object; that is, the patch is applied to the current value.</p>"},{"location":"api/basic_json/merge_patch/#parameters","title":"Parameters","text":"<code>apply_patch</code> (in) the patch to apply"},{"location":"api/basic_json/merge_patch/#complexity","title":"Complexity","text":"<p>Linear in the lengths of <code>apply_patch</code>.</p>"},{"location":"api/basic_json/merge_patch/#examples","title":"Examples","text":"Example <p>The following code shows how a JSON Merge Patch is applied to a JSON document.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iomanip&gt; // for std::setw\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // the original document\n    json document = R\"({\n                \"title\": \"Goodbye!\",\n                \"author\": {\n                    \"givenName\": \"John\",\n                    \"familyName\": \"Doe\"\n                },\n                \"tags\": [\n                    \"example\",\n                    \"sample\"\n                ],\n                \"content\": \"This will be unchanged\"\n            })\"_json;\n\n    // the patch\n    json patch = R\"({\n                \"title\": \"Hello!\",\n                \"phoneNumber\": \"+01-123-456-7890\",\n                \"author\": {\n                    \"familyName\": null\n                },\n                \"tags\": [\n                    \"example\"\n                ]\n            })\"_json;\n\n    // apply the patch\n    document.merge_patch(patch);\n\n    // output original and patched document\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; document &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"author\": {\n        \"givenName\": \"John\"\n    },\n    \"content\": \"This will be unchanged\",\n    \"phoneNumber\": \"+01-123-456-7890\",\n    \"tags\": [\n        \"example\"\n    ],\n    \"title\": \"Hello!\"\n}\n</code></pre>"},{"location":"api/basic_json/merge_patch/#see-also","title":"See also","text":"<ul> <li>RFC 7396 (JSON Merge Patch)</li> <li>patch apply a JSON patch</li> </ul>"},{"location":"api/basic_json/merge_patch/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.0.0.</li> </ul>"},{"location":"api/basic_json/meta/","title":"nlohmann::basic_json::meta","text":"<pre><code>static basic_json meta();\n</code></pre> <p>This function returns a JSON object with information about the library, including the version number and information on the platform and compiler.</p>"},{"location":"api/basic_json/meta/#return-value","title":"Return value","text":"<p>JSON object holding version information</p> key description <code>compiler</code> Information on the used compiler. It is an object with the following keys: <code>c++</code> (the used C++ standard), <code>family</code> (the compiler family; possible values are <code>clang</code>, <code>icc</code>, <code>gcc</code>, <code>ilecpp</code>, <code>msvc</code>, <code>pgcpp</code>, <code>sunpro</code>, and <code>unknown</code>), and <code>version</code> (the compiler version). <code>copyright</code> The copyright line for the library as string. <code>name</code> The name of the library as string. <code>platform</code> The used platform as string. Possible values are <code>win32</code>, <code>linux</code>, <code>apple</code>, <code>unix</code>, and <code>unknown</code>. <code>url</code> The URL of the project as string. <code>version</code> The version of the library. It is an object with the following keys: <code>major</code>, <code>minor</code>, and <code>patch</code> as defined by Semantic Versioning, and <code>string</code> (the version string)."},{"location":"api/basic_json/meta/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</p>"},{"location":"api/basic_json/meta/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/meta/#examples","title":"Examples","text":"Example <p>The following code shows an example output of the <code>meta()</code> function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // call meta()\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"compiler\": {\n        \"c++\": \"201103\",\n        \"family\": \"gcc\",\n        \"version\": \"12.4.0\"\n    },\n    \"copyright\": \"(C) 2013-2025 Niels Lohmann\",\n    \"name\": \"JSON for Modern C++\",\n    \"platform\": \"apple\",\n    \"url\": \"https://github.com/nlohmann/json\",\n    \"version\": {\n        \"major\": 3,\n        \"minor\": 12,\n        \"patch\": 0,\n        \"string\": \"3.12.0\"\n    }\n}\n</code></pre> <p>Note the output is platform-dependent.</p>"},{"location":"api/basic_json/meta/#see-also","title":"See also","text":"<ul> <li>NLOHMANN_JSON_VERSION_MAJOR/NLOHMANN_JSON_VERSION_MINOR/NLOHMANN_JSON_VERSION_PATCH   - library version information</li> </ul>"},{"location":"api/basic_json/meta/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.1.0.</li> </ul>"},{"location":"api/basic_json/number_float_t/","title":"nlohmann::basic_json::number_float_t","text":"<pre><code>using number_float_t = NumberFloatType;\n</code></pre> <p>The type used to store JSON numbers (floating-point).</p> <p>RFC 8259 describes numbers as follows:</p> <p>The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted.</p> <p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer, or a floating-point number. Therefore, three different types, <code>number_integer_t</code>, <code>number_unsigned_t</code> and <code>number_float_t</code> are used.</p> <p>To store floating-point numbers in C++, a type is defined by the template parameter <code>NumberFloatType</code> which chooses the type to use.</p>"},{"location":"api/basic_json/number_float_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/number_float_t/#default-type","title":"Default type","text":"<p>With the default values for <code>NumberFloatType</code> (<code>double</code>), the default value for <code>number_float_t</code> is <code>double</code>.</p>"},{"location":"api/basic_json/number_float_t/#default-behavior","title":"Default behavior","text":"<ul> <li>The restrictions about leading zeros are not enforced in C++. Instead, leading zeros in floating-point literals will   be ignored. Internally, the value will be stored as a decimal number. For instance, the C++ floating-point literal   <code>01.2</code> will be serialized to <code>1.2</code>. During deserialization, leading zeros yield an error.</li> <li>Not-a-number (NaN) values will be serialized to <code>null</code>.</li> </ul>"},{"location":"api/basic_json/number_float_t/#limits","title":"Limits","text":"<p>RFC 8259 states:</p> <p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.</p> <p>This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than <code>-1.79769313486232e+308</code> and values greater than <code>1.79769313486232e+308</code> will be stored as NaN internally and be serialized to <code>null</code>.</p>"},{"location":"api/basic_json/number_float_t/#storage","title":"Storage","text":"<p>Floating-point number values are stored directly inside a <code>basic_json</code> type.</p>"},{"location":"api/basic_json/number_float_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>number_float_t</code> is by default, a typedef to <code>double</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;double, json::number_float_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/number_float_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/number_integer_t/","title":"nlohmann::basic_json::number_integer_t","text":"<pre><code>using number_integer_t = NumberIntegerType;\n</code></pre> <p>The type used to store JSON numbers (integers).</p> <p>RFC 8259 describes numbers as follows:</p> <p>The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted.</p> <p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer, or a floating-point number. Therefore, three different types, <code>number_integer_t</code>,  <code>number_unsigned_t</code> and <code>number_float_t</code> are used.</p> <p>To store integer numbers in C++, a type is defined by the template parameter <code>NumberIntegerType</code> which chooses the type to use.</p>"},{"location":"api/basic_json/number_integer_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/number_integer_t/#default-type","title":"Default type","text":"<p>With the default values for <code>NumberIntegerType</code> (<code>std::int64_t</code>), the default value for <code>number_integer_t</code> is <code>std::int64_t</code>.</p>"},{"location":"api/basic_json/number_integer_t/#default-behavior","title":"Default behavior","text":"<ul> <li>The restrictions about leading zeros are not enforced in C++. Instead, leading zeros in integer literals lead to an   interpretation as an octal number. Internally, the value will be stored as a decimal number. For instance, the C++   integer literal <code>010</code> will be serialized to <code>8</code>. During deserialization, leading zeros yield an error.</li> <li>Not-a-number (NaN) values will be serialized to <code>null</code>.</li> </ul>"},{"location":"api/basic_json/number_integer_t/#limits","title":"Limits","text":"<p>RFC 8259 specifies:</p> <p>An implementation may set limits on the range and precision of numbers.</p> <p>When the default type is used, the maximal integer number that can be stored is <code>9223372036854775807</code> (INT64_MAX) and the minimal integer number that can be stored is <code>-9223372036854775808</code> (INT64_MIN). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will automatically be stored as <code>number_unsigned_t</code> or <code>number_float_t</code>.</p> <p>RFC 8259 further states:</p> <p>Note that when such software is used, numbers that are integers and are in the range [-2^{53}+1, 2^{53}-1] are interoperable in the sense that implementations will agree exactly on their numeric values.</p> <p>As this range is a subrange of the exactly supported range [INT64_MIN, INT64_MAX], this class's integer type is interoperable.</p>"},{"location":"api/basic_json/number_integer_t/#storage","title":"Storage","text":"<p>Integer number values are stored directly inside a <code>basic_json</code> type.</p>"},{"location":"api/basic_json/number_integer_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>number_integer_t</code> is by default, a typedef to <code>std::int64_t</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;std::int64_t, json::number_integer_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/number_integer_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/number_unsigned_t/","title":"nlohmann::basic_json::number_unsigned_t","text":"<pre><code>using number_unsigned_t = NumberUnsignedType;\n</code></pre> <p>The type used to store JSON numbers (unsigned).</p> <p>RFC 8259 describes numbers as follows:</p> <p>The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted.</p> <p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer, or a floating-point number. Therefore, three different types, <code>number_integer_t</code>, <code>number_unsigned_t</code> and <code>number_float_t</code> are used.</p> <p>To store unsigned integer numbers in C++, a type is defined by the template parameter <code>NumberUnsignedType</code> which chooses the type to use.</p>"},{"location":"api/basic_json/number_unsigned_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/number_unsigned_t/#default-type","title":"Default type","text":"<p>With the default values for <code>NumberUnsignedType</code> (<code>std::uint64_t</code>), the default value for <code>number_unsigned_t</code> is <code>std::uint64_t</code>.</p>"},{"location":"api/basic_json/number_unsigned_t/#default-behavior","title":"Default behavior","text":"<ul> <li>The restrictions about leading zeros are not enforced in C++. Instead, leading zeros in integer literals lead to an   interpretation as an octal number. Internally, the value will be stored as a decimal number. For instance, the C++   integer  literal <code>010</code> will be serialized to <code>8</code>. During deserialization, leading zeros yield an error.</li> <li>Not-a-number (NaN) values will be serialized to <code>null</code>.</li> </ul>"},{"location":"api/basic_json/number_unsigned_t/#limits","title":"Limits","text":"<p>RFC 8259 specifies:</p> <p>An implementation may set limits on the range and precision of numbers.</p> <p>When the default type is used, the maximal integer number that can be stored is <code>18446744073709551615</code> (UINT64_MAX) and the minimal integer number that can be stored is <code>0</code>. Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will automatically be stored as <code>number_integer_t</code> or <code>number_float_t</code>.</p> <p>RFC 8259 further states:</p> <p>Note that when such software is used, numbers that are integers and are in the range \\f[-2^{53}+1, 2^{53}-1]\\f are interoperable in the sense that implementations will agree exactly on their numeric values.</p> <p>As this range is a subrange (when considered in conjunction with the <code>number_integer_t</code> type) of the exactly supported range [0, UINT64_MAX], this class's integer type is interoperable.</p>"},{"location":"api/basic_json/number_unsigned_t/#storage","title":"Storage","text":"<p>Integer number values are stored directly inside a <code>basic_json</code> type.</p>"},{"location":"api/basic_json/number_unsigned_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>number_unsigned_t</code> is by default, a typedef to <code>std::uint64_t</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;std::uint64_t, json::number_unsigned_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/number_unsigned_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> </ul>"},{"location":"api/basic_json/object/","title":"nlohmann::basic_json::object","text":"<pre><code>static basic_json object(initializer_list_t init = {});\n</code></pre> <p>Creates a JSON object value from a given initializer list. The initializer lists elements must be pairs, and their first elements must be strings. If the initializer list is empty, the empty object <code>{}</code> is created.</p>"},{"location":"api/basic_json/object/#parameters","title":"Parameters","text":"<code>init</code> (in) initializer list with JSON values to create an object from (optional)"},{"location":"api/basic_json/object/#return-value","title":"Return value","text":"<p>JSON object value</p>"},{"location":"api/basic_json/object/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/object/#exceptions","title":"Exceptions","text":"<p>Throws <code>type_error.301</code> if <code>init</code> is not a list of pairs whose first elements are strings. In this case, no object can be created. When such a value is passed to <code>basic_json(initializer_list_t, bool, value_t)</code>, an array would have been created from the passed initializer list <code>init</code>. See the example below.</p>"},{"location":"api/basic_json/object/#complexity","title":"Complexity","text":"<p>Linear in the size of <code>init</code>.</p>"},{"location":"api/basic_json/object/#notes","title":"Notes","text":"<p>This function is only added for symmetry reasons. In contrast to the related function <code>array(initializer_list_t)</code>, there are no cases that can only be expressed by this function. That is, any initializer list <code>init</code> can also be passed to the initializer list constructor <code>basic_json(initializer_list_t, bool, value_t)</code>.</p>"},{"location":"api/basic_json/object/#examples","title":"Examples","text":"Example <p>The following code shows an example for the <code>object</code> function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON objects\n    json j_no_init_list = json::object();\n    json j_empty_init_list = json::object({});\n    json j_list_of_pairs = json::object({ {\"one\", 1}, {\"two\", 2} });\n\n    // serialize the JSON objects\n    std::cout &lt;&lt; j_no_init_list &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_empty_init_list &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_list_of_pairs &lt;&lt; '\\n';\n\n    // example for an exception\n    try\n    {\n        // can only create an object from a list of pairs\n        json j_invalid_object = json::object({{ \"one\", 1, 2 }});\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>{}\n{}\n{\"one\":1,\"two\":2}\n[json.exception.type_error.301] cannot create object from initializer list\n</code></pre>"},{"location":"api/basic_json/object/#see-also","title":"See also","text":"<ul> <li><code>basic_json(initializer_list_t)</code> - create a JSON value from an initializer list</li> <li><code>array</code> - create a JSON array value from an initializer list</li> </ul>"},{"location":"api/basic_json/object/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/object_comparator_t/","title":"nlohmann::basic_json::object_comparator_t","text":"<pre><code>using object_comparator_t = typename object_t::key_compare;\n// or\nusing object_comparator_t = default_object_comparator_t;\n</code></pre> <p>The comparator used by <code>object_t</code>. Defined as <code>typename object_t::key_compare</code> if available, and <code>default_object_comparator_t</code> otherwise.</p>"},{"location":"api/basic_json/object_comparator_t/#examples","title":"Examples","text":"Example <p>The example below demonstrates the used object comparator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"json::object_comparator_t(\\\"one\\\", \\\"two\\\") = \" &lt;&lt; json::object_comparator_t{}(\"one\", \"two\") &lt;&lt; \"\\n\"\n              &lt;&lt; \"json::object_comparator_t(\\\"three\\\", \\\"four\\\") = \" &lt;&lt; json::object_comparator_t{}(\"three\", \"four\") &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>json::object_comparator_t(\"one\", \"two\") = true\njson::object_comparator_t(\"three\", \"four\") = false\n</code></pre>"},{"location":"api/basic_json/object_comparator_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.0.0.</li> <li>Changed to be conditionally defined as <code>typename object_t::key_compare</code> or <code>default_object_comparator_t</code> in   version 3.11.0.</li> </ul>"},{"location":"api/basic_json/object_t/","title":"nlohmann::basic_json::object_t","text":"<pre><code>using object_t = ObjectType&lt;StringType,\n                            basic_json,\n                            default_object_comparator_t,\n                            AllocatorType&lt;std::pair&lt;const StringType, basic_json&gt;&gt;&gt;;\n</code></pre> <p>The type used to store JSON objects.</p> <p>RFC 8259 describes JSON objects as follows:</p> <p>An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</p> <p>To store objects in C++, a type is defined by the template parameters described below.</p>"},{"location":"api/basic_json/object_t/#template-parameters","title":"Template parameters","text":"<code>ObjectType</code> the container to store objects (e.g., <code>std::map</code> or <code>std::unordered_map</code>) <code>StringType</code> the type of the keys or names (e.g., <code>std::string</code>). The comparison function <code>std::less&lt;StringType&gt;</code> is used to order elements inside the container. <code>AllocatorType</code> the allocator to use for objects (e.g., <code>std::allocator</code>)"},{"location":"api/basic_json/object_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/object_t/#default-type","title":"Default type","text":"<p>With the default values for <code>ObjectType</code> (<code>std::map</code>), <code>StringType</code> (<code>std::string</code>), and <code>AllocatorType</code> (<code>std::allocator</code>), the default value for <code>object_t</code> is:</p> <pre><code>// until C++14\nstd::map&lt;\n  std::string, // key_type\n  basic_json, // value_type\n  std::less&lt;std::string&gt;, // key_compare\n  std::allocator&lt;std::pair&lt;const std::string, basic_json&gt;&gt; // allocator_type\n&gt;\n\n// since C++14\nstd::map&lt;\n  std::string, // key_type\n  basic_json, // value_type\n  std::less&lt;&gt;, // key_compare\n  std::allocator&lt;std::pair&lt;const std::string, basic_json&gt;&gt; // allocator_type\n&gt;\n</code></pre> <p>See <code>default_object_comparator_t</code> for more information.</p>"},{"location":"api/basic_json/object_t/#behavior","title":"Behavior","text":"<p>The choice of <code>object_t</code> influences the behavior of the JSON class. With the default type, objects have the following behavior:</p> <ul> <li>When all names are unique, objects will be interoperable in the sense that all software implementations receiving that   object will agree on the name-value mappings.</li> <li>When the names within an object are not unique, it is unspecified which one of the values for a given key will be   chosen. For instance, <code>{\"key\": 2, \"key\": 1}</code> could be equal to either <code>{\"key\": 1}</code> or   <code>{\"key\": 2}</code>.</li> <li>Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see   <code>dump</code>) in this order. For instance, <code>{\"b\": 1, \"a\": 2}</code> and <code>{\"a\": 2, \"b\": 1}</code> will be stored   and serialized as <code>{\"a\": 2, \"b\": 1}</code>.</li> <li>When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense   that they will not be affected by these differences. For instance, <code>{\"b\": 1, \"a\": 2}</code> and   <code>{\"a\": 2, \"b\": 1}</code> will be treated as equal.</li> </ul>"},{"location":"api/basic_json/object_t/#limits","title":"Limits","text":"<p>RFC 8259 specifies:</p> <p>An implementation may set limits on the maximum depth of nesting.</p> <p>In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <code>max_size</code> function of a JSON object.</p>"},{"location":"api/basic_json/object_t/#storage","title":"Storage","text":"<p>Objects are stored as pointers in a <code>basic_json</code> type. That is, for any access to object values, a pointer of type <code>object_t*</code> must be dereferenced.</p>"},{"location":"api/basic_json/object_t/#object-key-order","title":"Object key order","text":"<p>The order name/value pairs are added to the object are not preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as <code>std::map</code> with <code>std::less</code> is used by default. Please note this behavior conforms to RFC 8259, because any order implements the specified \"unordered\" nature of JSON objects.</p>"},{"location":"api/basic_json/object_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>object_t</code> is by default, a typedef to <code>std::map&lt;json::string_t, json&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;std::map&lt;json::string_t, json&gt;, json::object_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/object_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/operator%2B%3D/","title":"nlohmann::basic_json::operator+=","text":"<pre><code>// (1)\nreference operator+=(basic_json&amp;&amp; val);\nreference operator+=(const basic_json&amp; val);\n\n// (2)\nreference operator+=(const typename object_t::value_type&amp; val);\n\n// (3)\nreference operator+=(initializer_list_t init);\n</code></pre> <ol> <li> <p>Appends the given element <code>val</code> to the end of the JSON array. If the function is called on a JSON null value, an    empty array is created before appending <code>val</code>.</p> </li> <li> <p>Inserts the given element <code>val</code> to the JSON object. If the function is called on a JSON null value, an empty object    is created before inserting <code>val</code>.</p> </li> <li> <p>This function allows using <code>operator+=</code> with an initializer list. In case</p> <ol> <li>the current value is an object,</li> <li>the initializer list <code>init</code> contains only two elements, and</li> <li>the first element of <code>init</code> is a string,</li> </ol> <p><code>init</code> is converted into an object element and added using <code>operator+=(const typename object_t::value_type&amp;)</code>. Otherwise, <code>init</code> is converted to a JSON value and added using <code>operator+=(basic_json&amp;&amp;)</code>.</p> </li> </ol>"},{"location":"api/basic_json/operator%2B%3D/#iterator-invalidation","title":"Iterator invalidation","text":"<p>For all cases where an element is added to an array, a reallocation can happen, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated. Otherwise, only the <code>end()</code> iterator is invalidated.</p> <p>For <code>ordered_json</code>, also adding an element to an object can yield a reallocation which again invalidates all iterators and all references.</p>"},{"location":"api/basic_json/operator%2B%3D/#parameters","title":"Parameters","text":"<code>val</code> (in) the value to add to the JSON array/object <code>init</code> (in) an initializer list"},{"location":"api/basic_json/operator%2B%3D/#return-value","title":"Return value","text":"<p><code>*this</code></p>"},{"location":"api/basic_json/operator%2B%3D/#exceptions","title":"Exceptions","text":"<p>All functions can throw the following exception:   - Throws <code>type_error.308</code> when called on a type other than     JSON array or null; example: <code>\"cannot use operator+=() with number\"</code></p>"},{"location":"api/basic_json/operator%2B%3D/#complexity","title":"Complexity","text":"<ol> <li>Amortized constant.</li> <li>Logarithmic in the size of the container, O(log(<code>size()</code>)).</li> <li>Linear in the size of the initializer list <code>init</code>.</li> </ol>"},{"location":"api/basic_json/operator%2B%3D/#notes","title":"Notes","text":"<p>(3) This function is required to resolve an ambiguous overload error, because pairs like <code>{\"key\", \"value\"}</code> can be both interpreted as <code>object_t::value_type</code> or <code>std::initializer_list&lt;basic_json&gt;</code>, see #235 for more information.</p>"},{"location":"api/basic_json/operator%2B%3D/#examples","title":"Examples","text":"Example: (1) add element to array <p>The example shows how <code>push_back()</code> and <code>+=</code> can be used to add elements to a JSON array. Note how the <code>null</code> value was silently converted to a JSON array.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json array = {1, 2, 3, 4, 5};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values\n    array.push_back(6);\n    array += 7;\n    null += \"first\";\n    null += \"second\";\n\n    // print values\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3,4,5]\nnull\n[1,2,3,4,5,6,7]\n[\"first\",\"second\"]\n</code></pre> Example: (2) add element to object <p>The example shows how <code>push_back()</code> and <code>+=</code> can be used to add elements to a JSON object. Note how the <code>null</code> value was silently converted to a JSON object.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json object = {{\"one\", 1}, {\"two\", 2}};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values\n    object.push_back(json::object_t::value_type(\"three\", 3));\n    object += json::object_t::value_type(\"four\", 4);\n    null += json::object_t::value_type(\"A\", \"a\");\n    null += json::object_t::value_type(\"B\", \"b\");\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\nnull\n{\"four\":4,\"one\":1,\"three\":3,\"two\":2}\n{\"A\":\"a\",\"B\":\"b\"}\n</code></pre> Example: (3) add to object from initializer list <p>The example shows how initializer lists are treated as objects when possible.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json object = {{\"one\", 1}, {\"two\", 2}};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values:\n    object.push_back({\"three\", 3});  // object is extended\n    object += {\"four\", 4};           // object is extended\n    null.push_back({\"five\", 5});     // null is converted to array\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // would throw:\n    //object.push_back({1, 2, 3});\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\nnull\n{\"four\":4,\"one\":1,\"three\":3,\"two\":2}\n[[\"five\",5]]\n</code></pre>"},{"location":"api/basic_json/operator%2B%3D/#see-also","title":"See also","text":"<ul> <li>emplace_back add a value to an array</li> <li>push_back add a value to an array/object</li> </ul>"},{"location":"api/basic_json/operator%2B%3D/#version-history","title":"Version history","text":"<ol> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 2.0.0.</li> </ol>"},{"location":"api/basic_json/operator%3D/","title":"nlohmann::basic_json::operator=","text":"<pre><code>basic_json&amp; operator=(basic_json other) noexcept (\n    std::is_nothrow_move_constructible&lt;value_t&gt;::value &amp;&amp;\n    std::is_nothrow_move_assignable&lt;value_t&gt;::value &amp;&amp;\n    std::is_nothrow_move_constructible&lt;json_value&gt;::value &amp;&amp;\n    std::is_nothrow_move_assignable&lt;json_value&gt;::value\n);\n</code></pre> <p>Copy assignment operator. Copies a JSON value via the \"copy and swap\" strategy: It is expressed in terms of the copy constructor, destructor, and the <code>swap()</code> member function.</p>"},{"location":"api/basic_json/operator%3D/#parameters","title":"Parameters","text":"<code>other</code> (in) value to copy from"},{"location":"api/basic_json/operator%3D/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator%3D/#examples","title":"Examples","text":"Example <p>The code below shows and example for the copy assignment. It creates a copy of value <code>a</code> which is then swapped with <code>b</code>. Finally, the copy of <code>a</code> (which is the null value after the swap) is destroyed.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json a = 23;\n    json b = 42;\n\n    // copy-assign a to b\n    b = a;\n\n    // serialize the JSON arrays\n    std::cout &lt;&lt; a &lt;&lt; '\\n';\n    std::cout &lt;&lt; b &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>23\n23\n</code></pre>"},{"location":"api/basic_json/operator%3D/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/operator%5B%5D/","title":"nlohmann::basic_json::operator[]","text":"<pre><code>// (1)\nreference operator[](size_type idx);\nconst_reference operator[](size_type idx) const;\n\n// (2)\nreference operator[](typename object_t::key_type key);\nconst_reference operator[](const typename object_t::key_type&amp; key) const;\n\n// (3)\ntemplate&lt;typename KeyType&gt;\nreference operator[](KeyType&amp;&amp; key);\ntemplate&lt;typename KeyType&gt;\nconst_reference operator[](KeyType&amp;&amp; key) const;\n\n// (4)\nreference operator[](const json_pointer&amp; ptr);\nconst_reference operator[](const json_pointer&amp; ptr) const;\n</code></pre> <ol> <li>Returns a reference to the array element at specified location <code>idx</code>.</li> <li>Returns a reference to the object element with specified key <code>key</code>. The non-const qualified overload takes the key by    value.</li> <li>See 2. This overload is only available if <code>KeyType</code> is comparable with <code>typename object_t::key_type</code> and    <code>typename object_comparator_t::is_transparent</code> denotes a type.</li> <li>Returns a reference to the element with specified JSON pointer <code>ptr</code>.</li> </ol>"},{"location":"api/basic_json/operator%5B%5D/#template-parameters","title":"Template parameters","text":"<code>KeyType</code> A type for an object key other than <code>json_pointer</code> that is comparable with <code>string_t</code> using  <code>object_comparator_t</code>. This can also be a string view (C++17)."},{"location":"api/basic_json/operator%5B%5D/#iterator-invalidation","title":"Iterator invalidation","text":"<p>For the non-const versions 1. and 4., when passing an array index that does not exist, it is created and filled with a <code>null</code> value before a reference to it is returned. For this, a reallocation can happen, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated.</p> <p>For <code>ordered_json</code>, also passing an object key to the non-const versions 2., 3., and 4., a reallocation can happen which again invalidates all iterators and all references.</p>"},{"location":"api/basic_json/operator%5B%5D/#parameters","title":"Parameters","text":"<code>idx</code> (in) index of the element to access <code>key</code> (in) object key of the element to access <code>ptr</code> (in) JSON pointer to the desired element"},{"location":"api/basic_json/operator%5B%5D/#return-value","title":"Return value","text":"<ol> <li>(const) reference to the element at index <code>idx</code></li> <li>(const) reference to the element at key <code>key</code></li> <li>(const) reference to the element at key <code>key</code></li> <li>(const) reference to the element pointed to by <code>ptr</code></li> </ol>"},{"location":"api/basic_json/operator%5B%5D/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/operator%5B%5D/#exceptions","title":"Exceptions","text":"<ol> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.305</code> if the JSON value is not an array   or null; in that case, using the <code>[]</code> operator with an index makes no sense.</li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.305</code> if the JSON value is not an object   or null; in that case, using the <code>[]</code> operator with a key makes no sense.</li> </ul> </li> <li>See 2.</li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>parse_error.106</code> if an array index in the passed   JSON pointer <code>ptr</code> begins with '0'.</li> <li>Throws <code>parse_error.109</code> if an array index in the passed   JSON pointer <code>ptr</code> is not a number.</li> <li>Throws <code>out_of_range.402</code> if the array index '-' is used   in the passed JSON pointer <code>ptr</code> for the const version.</li> <li>Throws <code>out_of_range.404</code> if the JSON pointer <code>ptr</code> can   not be resolved.</li> </ul> </li> </ol>"},{"location":"api/basic_json/operator%5B%5D/#complexity","title":"Complexity","text":"<ol> <li>Constant if <code>idx</code> is in the range of the array. Otherwise, linear in <code>idx - size()</code>.</li> <li>Logarithmic in the size of the container.</li> <li>Logarithmic in the size of the container.</li> <li>Logarithmic in the size of the container.</li> </ol>"},{"location":"api/basic_json/operator%5B%5D/#notes","title":"Notes","text":"<p>Undefined behavior and runtime assertions</p> <ol> <li>If the element with key <code>idx</code> does not exist, the behavior is undefined.</li> <li>If the element with key <code>key</code> does not exist, the behavior is undefined and is guarded by a    runtime assertion!</li> </ol> <ol> <li> <p>The non-const version may add values: If <code>idx</code> is beyond the range of the array (i.e., <code>idx &gt;= size()</code>), then the    array is silently filled up with <code>null</code> values to make <code>idx</code> a valid reference to the last stored element. In    case the value was <code>null</code> before, it is converted to an array.</p> </li> <li> <p>If <code>key</code> is not found in the object, then it is silently added to the object and filled with a <code>null</code> value to    make <code>key</code> a valid reference. In case the value was <code>null</code> before, it is converted to an object.</p> </li> <li> <p>See 2.</p> </li> <li> <p><code>null</code> values are created in arrays and objects if necessary.</p> <p>In particular:</p> <ul> <li>If the JSON pointer points to an object key that does not exist, it is created and filled with a <code>null</code>   value before a reference to it is returned.</li> <li>If the JSON pointer points to an array index that does not exist, it is created and filled with a <code>null</code>   value before a reference to it is returned. All indices between the current maximum and the given index are also   filled with <code>null</code>.</li> <li>The special value <code>-</code> is treated as a synonym for the index past the end.</li> </ul> </li> </ol>"},{"location":"api/basic_json/operator%5B%5D/#examples","title":"Examples","text":"Example: (1) access specified array element <p>The example below shows how array elements can be read and written using <code>[]</code> operator. Note the addition of <code>null</code> values.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON array\n    json array = {1, 2, 3, 4, 5};\n\n    // output element at index 3 (fourth element)\n    std::cout &lt;&lt; array[3] &lt;&lt; '\\n';\n\n    // change last element to 6\n    array[array.size() - 1] = 6;\n\n    // output changed array\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n\n    // write beyond array limit\n    array[10] = 11;\n\n    // output changed array\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>4\n[1,2,3,4,6]\n[1,2,3,4,6,null,null,null,null,null,11]\n</code></pre> Example: (1) access specified array element (const) <p>The example below shows how array elements can be read using the <code>[]</code> operator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON array\n    const json array = {\"first\", \"2nd\", \"third\", \"fourth\"};\n\n    // output element at index 2 (third element)\n    std::cout &lt;&lt; array.at(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>\"third\"\n</code></pre> Example: (2) access specified object element <p>The example below shows how object elements can be read and written using the <code>[]</code> operator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json object =\n    {\n        {\"one\", 1}, {\"two\", 2}, {\"three\", 2.9}\n    };\n\n    // output element with key \"two\"\n    std::cout &lt;&lt; object[\"two\"] &lt;&lt; \"\\n\\n\";\n\n    // change element with key \"three\"\n    object[\"three\"] = 3;\n\n    // output changed array\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; object &lt;&lt; \"\\n\\n\";\n\n    // mention nonexisting key\n    object[\"four\"];\n\n    // write to nonexisting key\n    object[\"five\"][\"really\"][\"nested\"] = true;\n\n    // output changed object\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; object &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>2\n\n{\n    \"one\": 1,\n    \"three\": 3,\n    \"two\": 2\n}\n\n{\n    \"five\": {\n        \"really\": {\n            \"nested\": true\n        }\n    },\n    \"four\": null,\n    \"one\": 1,\n    \"three\": 3,\n    \"two\": 2\n}\n</code></pre> Example: (2) access specified object element (const) <p>The example below shows how object elements can be read using the <code>[]</code> operator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    const json object =\n    {\n        {\"one\", 1}, {\"two\", 2}, {\"three\", 2.9}\n    };\n\n    // output element with key \"two\"\n    std::cout &lt;&lt; object[\"two\"] &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>2\n</code></pre> Example: (3) access specified object element using string_view <p>The example below shows how object elements can be read using the <code>[]</code> operator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    json object =\n    {\n        {\"one\", 1}, {\"two\", 2}, {\"three\", 2.9}\n    };\n\n    // output element with key \"two\"\n    std::cout &lt;&lt; object[\"two\"sv] &lt;&lt; \"\\n\\n\";\n\n    // change element with key \"three\"\n    object[\"three\"sv] = 3;\n\n    // output changed array\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; object &lt;&lt; \"\\n\\n\";\n\n    // mention nonexisting key\n    object[\"four\"sv];\n\n    // write to nonexisting key\n    object[\"five\"sv][\"really\"sv][\"nested\"sv] = true;\n\n    // output changed object\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; object &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>2\n\n{\n    \"one\": 1,\n    \"three\": 3,\n    \"two\": 2\n}\n\n{\n    \"five\": {\n        \"really\": {\n            \"nested\": true\n        }\n    },\n    \"four\": null,\n    \"one\": 1,\n    \"three\": 3,\n    \"two\": 2\n}\n</code></pre> Example: (3) access specified object element using string_view (const) <p>The example below shows how object elements can be read using the <code>[]</code> operator.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object\n    const json object =\n    {\n        {\"one\", 1}, {\"two\", 2}, {\"three\", 2.9}\n    };\n\n    // output element with key \"two\"\n    std::cout &lt;&lt; object[\"two\"sv] &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>2\n</code></pre> Example: (4) access specified element via JSON Pointer <p>The example below shows how values can be read and written using JSON Pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j =\n    {\n        {\"number\", 1}, {\"string\", \"foo\"}, {\"array\", {1, 2}}\n    };\n\n    // read-only access\n\n    // output element with JSON pointer \"/number\"\n    std::cout &lt;&lt; j[\"/number\"_json_pointer] &lt;&lt; '\\n';\n    // output element with JSON pointer \"/string\"\n    std::cout &lt;&lt; j[\"/string\"_json_pointer] &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array\"\n    std::cout &lt;&lt; j[\"/array\"_json_pointer] &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array/1\"\n    std::cout &lt;&lt; j[\"/array/1\"_json_pointer] &lt;&lt; '\\n';\n\n    // writing access\n\n    // change the string\n    j[\"/string\"_json_pointer] = \"bar\";\n    // output the changed string\n    std::cout &lt;&lt; j[\"string\"] &lt;&lt; '\\n';\n\n    // \"change\" a nonexisting object entry\n    j[\"/boolean\"_json_pointer] = true;\n    // output the changed object\n    std::cout &lt;&lt; j &lt;&lt; '\\n';\n\n    // change an array element\n    j[\"/array/1\"_json_pointer] = 21;\n    // \"change\" an array element with nonexisting index\n    j[\"/array/4\"_json_pointer] = 44;\n    // output the changed array\n    std::cout &lt;&lt; j[\"array\"] &lt;&lt; '\\n';\n\n    // \"change\" the array element past the end\n    j[\"/array/-\"_json_pointer] = 55;\n    // output the changed array\n    std::cout &lt;&lt; j[\"array\"] &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>1\n\"foo\"\n[1,2]\n2\n\"bar\"\n{\"array\":[1,2],\"boolean\":true,\"number\":1,\"string\":\"bar\"}\n[1,21,null,null,44]\n[1,21,null,null,44,55]\n</code></pre> Example: (4) access specified element via JSON Pointer (const) <p>The example below shows how values can be read using JSON Pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    const json j =\n    {\n        {\"number\", 1}, {\"string\", \"foo\"}, {\"array\", {1, 2}}\n    };\n\n    // read-only access\n\n    // output element with JSON pointer \"/number\"\n    std::cout &lt;&lt; j[\"/number\"_json_pointer] &lt;&lt; '\\n';\n    // output element with JSON pointer \"/string\"\n    std::cout &lt;&lt; j[\"/string\"_json_pointer] &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array\"\n    std::cout &lt;&lt; j[\"/array\"_json_pointer] &lt;&lt; '\\n';\n    // output element with JSON pointer \"/array/1\"\n    std::cout &lt;&lt; j[\"/array/1\"_json_pointer] &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>1\n\"foo\"\n[1,2]\n2\n</code></pre>"},{"location":"api/basic_json/operator%5B%5D/#see-also","title":"See also","text":"<ul> <li>documentation on unchecked access</li> <li>documentation on runtime assertions</li> <li>see <code>at</code> for access by reference with range checking</li> <li>see <code>value</code> for access with default value</li> </ul>"},{"location":"api/basic_json/operator%5B%5D/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0.</li> <li>Added in version 1.0.0. Added overloads for <code>T* key</code> in version 1.1.0. Removed overloads for <code>T* key</code> (replaced by 3)    in version 3.11.0.</li> <li>Added in version 3.11.0.</li> <li>Added in version 2.0.0.</li> </ol>"},{"location":"api/basic_json/operator_ValueType/","title":"nlohmann::basic_json::operator ValueType","text":"<pre><code>template&lt;typename ValueType&gt;\nJSON_EXPLICIT operator ValueType() const;\n</code></pre> <p>Implicit type conversion between the JSON value and a compatible value. The call is realized by calling <code>get()</code>. See Notes for the meaning of <code>JSON_EXPLICIT</code>.</p>"},{"location":"api/basic_json/operator_ValueType/#template-parameters","title":"Template parameters","text":"<code>ValueType</code> the value type to return"},{"location":"api/basic_json/operator_ValueType/#return-value","title":"Return value","text":"<p>copy of the JSON value, converted to <code>ValueType</code></p>"},{"location":"api/basic_json/operator_ValueType/#exceptions","title":"Exceptions","text":"<p>Depends on what <code>json_serializer&lt;ValueType&gt;</code> <code>from_json()</code> method throws</p>"},{"location":"api/basic_json/operator_ValueType/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value.</p>"},{"location":"api/basic_json/operator_ValueType/#notes","title":"Notes","text":"<p>Definition of <code>JSON_EXPLICIT</code></p> <p>By default <code>JSON_EXPLICIT</code> is defined to the empty string, so the signature is:</p> <pre><code>template&lt;typename ValueType&gt;\noperator ValueType() const;\n</code></pre> <p>If <code>JSON_USE_IMPLICIT_CONVERSIONS</code> is set to <code>0</code>, <code>JSON_EXPLICIT</code> is defined to <code>explicit</code>:</p> <pre><code>template&lt;typename ValueType&gt;\nexplicit operator ValueType() const;\n</code></pre> <p>That is, implicit conversions can be switched off by defining <code>JSON_USE_IMPLICIT_CONVERSIONS</code> to <code>0</code>.</p> <p>Future behavior change</p> <p>Implicit conversions will be switched off by default in the next major release of the library. That is, <code>JSON_EXPLICIT</code> will be set to <code>explicit</code> by default.</p> <p>You can prepare existing code by already defining <code>JSON_USE_IMPLICIT_CONVERSIONS</code> to <code>0</code> and replace any implicit conversions with calls to <code>get</code>.</p>"},{"location":"api/basic_json/operator_ValueType/#examples","title":"Examples","text":"Example <p>The example below shows several conversions from JSON values to other types. There are a few things to note: (1) Floating-point numbers can be converted to integers, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>, (3) A JSON object can be converted to C++ associative containers such as <code>std::unordered_map&lt;std::string, json&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON value with different types\n    json json_types =\n    {\n        {\"boolean\", true},\n        {\n            \"number\", {\n                {\"integer\", 42},\n                {\"floating-point\", 17.23}\n            }\n        },\n        {\"string\", \"Hello, world!\"},\n        {\"array\", {1, 2, 3, 4, 5}},\n        {\"null\", nullptr}\n    };\n\n    // use implicit conversions\n    bool v1 = json_types[\"boolean\"];\n    int v2 = json_types[\"number\"][\"integer\"];\n    short v3 = json_types[\"number\"][\"integer\"];\n    float v4 = json_types[\"number\"][\"floating-point\"];\n    int v5 = json_types[\"number\"][\"floating-point\"];\n    std::string v6 = json_types[\"string\"];\n    std::vector&lt;short&gt; v7 = json_types[\"array\"];\n    std::unordered_map&lt;std::string, json&gt; v8 = json_types;\n\n    // print the conversion results\n    std::cout &lt;&lt; v1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v2 &lt;&lt; ' ' &lt;&lt; v3 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v4 &lt;&lt; ' ' &lt;&lt; v5 &lt;&lt; '\\n';\n    std::cout &lt;&lt; v6 &lt;&lt; '\\n';\n\n    for (auto i : v7)\n    {\n        std::cout &lt;&lt; i &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; \"\\n\\n\";\n\n    for (auto i : v8)\n    {\n        std::cout &lt;&lt; i.first &lt;&lt; \": \" &lt;&lt; i.second &lt;&lt; '\\n';\n    }\n\n    // example for an exception\n    try\n    {\n        bool v1 = json_types[\"string\"];\n    }\n    catch (const json::type_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>1\n42 42\n17.23 17\nHello, world!\n1 2 3 4 5 \n\nstring: \"Hello, world!\"\nnumber: {\"floating-point\":17.23,\"integer\":42}\nnull: null\nboolean: true\narray: [1,2,3,4,5]\n[json.exception.type_error.302] type must be boolean, but is string\n</code></pre>"},{"location":"api/basic_json/operator_ValueType/#version-history","title":"Version history","text":"<ul> <li>Since version 1.0.0.</li> <li>Macros <code>JSON_EXPLICIT</code>/<code>JSON_USE_IMPLICIT_CONVERSIONS</code> added   in version 3.9.0.</li> </ul>"},{"location":"api/basic_json/operator_eq/","title":"nlohmann::basic_json::operator==","text":"<pre><code>// until C++20\nbool operator==(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator==(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator==(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n\n// since C++20\nclass basic_json {\n    bool operator==(const_reference rhs) const noexcept;              // (1)\n\n    template&lt;typename ScalarType&gt;\n    bool operator==(ScalarType rhs) const noexcept;                   // (2)\n};\n</code></pre> <ol> <li> <p>Compares two JSON values for equality according to the following rules:</p> <ul> <li>Two JSON values are equal if (1) neither value is discarded, or (2) they are of the same type and their stored   values are the same according to their respective <code>operator==</code>.</li> <li>Integer and floating-point numbers are automatically converted before comparison.</li> </ul> </li> <li> <p>Compares a JSON value and a scalar or a scalar and a JSON value for equality by converting the    scalar to a JSON value and comparing both JSON values according to 1.</p> </li> </ol>"},{"location":"api/basic_json/operator_eq/#template-parameters","title":"Template parameters","text":"<code>ScalarType</code> a scalar type according to <code>std::is_scalar&lt;ScalarType&gt;::value</code>"},{"location":"api/basic_json/operator_eq/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider  <code>rhs</code> (in) second value to consider"},{"location":"api/basic_json/operator_eq/#return-value","title":"Return value","text":"<p>whether the values <code>lhs</code>/<code>*this</code> and <code>rhs</code> are equal</p>"},{"location":"api/basic_json/operator_eq/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/operator_eq/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator_eq/#notes","title":"Notes","text":"<p>Comparing special values</p> <ul> <li><code>NaN</code> values are unordered within the domain of numbers.   The following comparisons all yield <code>false</code>:<ol> <li>Comparing a <code>NaN</code> with itself.</li> <li>Comparing a <code>NaN</code> with another <code>NaN</code>.</li> <li>Comparing a <code>NaN</code> and any other number.</li> </ol> </li> <li>JSON <code>null</code> values are all equal.</li> <li>Discarded values never compare equal to themselves.</li> </ul> <p>Comparing floating-point numbers</p> <p>Floating-point numbers inside JSON values numbers are compared with <code>json::number_float_t::operator==</code> which is <code>double::operator==</code> by default. To compare floating-point while respecting an epsilon, an alternative comparison function could be used, for instance</p> <pre><code>template&lt;typename T, typename = typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::type&gt;\ninline bool is_same(T a, T b, T epsilon = std::numeric_limits&lt;T&gt;::epsilon()) noexcept\n{\n    return std::abs(a - b) &lt;= epsilon;\n}\n</code></pre> <p>Or you can self-defined operator equal function like this:</p> <pre><code>bool my_equal(const_reference lhs, const_reference rhs)\n{\n    const auto lhs_type lhs.type();\n    const auto rhs_type rhs.type();\n    if (lhs_type == rhs_type)\n    {\n        switch(lhs_type)\n            // self_defined case\n            case value_t::number_float:\n                return std::abs(lhs - rhs) &lt;= std::numeric_limits&lt;float&gt;::epsilon();\n            // other cases remain the same with the original\n            ...\n    }\n...\n}\n</code></pre> <p>Comparing different <code>basic_json</code> specializations</p> <p>Comparing different <code>basic_json</code> specializations can have surprising effects. For instance, the result of comparing the JSON objects</p> <pre><code>{\n   \"version\": 1,\n   \"type\": \"integer\"\n}\n</code></pre> <p>and</p> <pre><code>{\n   \"type\": \"integer\",\n   \"version\": 1\n}\n</code></pre> <p>depends on whether <code>nlohmann::json</code> or <code>nlohmann::ordered_json</code> is used:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    nlohmann::json uj1 = {{\"version\", 1}, {\"type\", \"integer\"}};\n    nlohmann::json uj2 = {{\"type\", \"integer\"}, {\"version\", 1}};\n\n    nlohmann::ordered_json oj1 = {{\"version\", 1}, {\"type\", \"integer\"}};\n    nlohmann::ordered_json oj2 = {{\"type\", \"integer\"}, {\"version\", 1}};\n\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (uj1 == uj2) &lt;&lt; '\\n' &lt;&lt; (oj1 == oj2) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\nfalse\n</code></pre>"},{"location":"api/basic_json/operator_eq/#examples","title":"Examples","text":"Example <p>The example demonstrates comparing several JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array_1 = {1, 2, 3};\n    json array_2 = {1, 2, 4};\n    json object_1 = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json object_2 = {{\"B\", \"b\"}, {\"A\", \"a\"}};\n    json number_1 = 17;\n    json number_2 = 17.000000000000001L;\n    json string_1 = \"foo\";\n    json string_2 = \"bar\";\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array_1 &lt;&lt; \" == \" &lt;&lt; array_2 &lt;&lt; \" \" &lt;&lt; (array_1 == array_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object_1 &lt;&lt; \" == \" &lt;&lt; object_2 &lt;&lt; \" \" &lt;&lt; (object_1 == object_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number_1 &lt;&lt; \" == \" &lt;&lt; number_2 &lt;&lt; \" \" &lt;&lt; (number_1 == number_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string_1 &lt;&lt; \" == \" &lt;&lt; string_2 &lt;&lt; \" \" &lt;&lt; (string_1 == string_2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] == [1,2,4] false\n{\"A\":\"a\",\"B\":\"b\"} == {\"A\":\"a\",\"B\":\"b\"} true\n17 == 17.0 true\n\"foo\" == \"bar\" false\n</code></pre> Example <p>The example demonstrates comparing several JSON types against the null pointer (JSON <code>null</code>).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array = {1, 2, 3};\n    json object = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json number = 17;\n    json string = \"foo\";\n    json null;\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array &lt;&lt; \" == nullptr \" &lt;&lt; (array == nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object &lt;&lt; \" == nullptr \" &lt;&lt; (object == nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number &lt;&lt; \" == nullptr \" &lt;&lt; (number == nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string &lt;&lt; \" == nullptr \" &lt;&lt; (string == nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; \" == nullptr \" &lt;&lt; (null == nullptr) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] == nullptr false\n{\"A\":\"a\",\"B\":\"b\"} == nullptr false\n17 == nullptr false\n\"foo\" == nullptr false\nnull == nullptr true\n</code></pre>"},{"location":"api/basic_json/operator_eq/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Added C++20 member functions in version 3.11.0.</li> <li>Added in version 1.0.0. Added C++20 member functions in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/operator_ge/","title":"nlohmann::basic_json::operator&gt;=","text":"<pre><code>// until C++20\nbool operator&gt;=(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&gt;=(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&gt;=(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n</code></pre> <ol> <li> <p>Compares whether one JSON value <code>lhs</code> is greater than or equal to another JSON value <code>rhs</code> according to the following    rules:</p> <ul> <li>The comparison always yields <code>false</code> if (1) either operand is discarded, or (2) either operand is <code>NaN</code> and   the other operand is either <code>NaN</code> or any other number.</li> <li>Otherwise, returns the result of <code>!(lhs &lt; rhs)</code> (see operator&lt;).</li> </ul> </li> <li> <p>Compares whether a JSON value is greater than or equal to a scalar or a scalar is greater than or equal to a JSON    value by converting the scalar to a JSON value and comparing both JSON values according to 1.</p> </li> </ol>"},{"location":"api/basic_json/operator_ge/#template-parameters","title":"Template parameters","text":"<code>ScalarType</code> a scalar type according to <code>std::is_scalar&lt;ScalarType&gt;::value</code>"},{"location":"api/basic_json/operator_ge/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider  <code>rhs</code> (in) second value to consider"},{"location":"api/basic_json/operator_ge/#return-value","title":"Return value","text":"<p>whether <code>lhs</code> is less than or equal to <code>rhs</code></p>"},{"location":"api/basic_json/operator_ge/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/operator_ge/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator_ge/#notes","title":"Notes","text":"<p>Comparing <code>NaN</code></p> <p><code>NaN</code> values are unordered within the domain of numbers. The following comparisons all yield <code>false</code>:   1. Comparing a <code>NaN</code> with itself.   2. Comparing a <code>NaN</code> with another <code>NaN</code>.   3. Comparing a <code>NaN</code> and any other number.</p> <p>Operator overload resolution</p> <p>Since C++20 overload resolution will consider the rewritten candidate generated from <code>operator&lt;=&gt;</code>.</p>"},{"location":"api/basic_json/operator_ge/#examples","title":"Examples","text":"Example <p>The example demonstrates comparing several JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array_1 = {1, 2, 3};\n    json array_2 = {1, 2, 4};\n    json object_1 = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json object_2 = {{\"B\", \"b\"}, {\"A\", \"a\"}};\n    json number_1 = 17;\n    json number_2 = 17.0000000000001L;\n    json string_1 = \"foo\";\n    json string_2 = \"bar\";\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array_1 &lt;&lt; \" &gt;= \" &lt;&lt; array_2 &lt;&lt; \" \" &lt;&lt; (array_1 &gt;= array_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object_1 &lt;&lt; \" &gt;= \" &lt;&lt; object_2 &lt;&lt; \" \" &lt;&lt; (object_1 &gt;= object_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number_1 &lt;&lt; \" &gt;= \" &lt;&lt; number_2 &lt;&lt; \" \" &lt;&lt; (number_1 &gt;= number_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string_1 &lt;&lt; \" &gt;= \" &lt;&lt; string_2 &lt;&lt; \" \" &lt;&lt; (string_1 &gt;= string_2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] &gt;= [1,2,4] false\n{\"A\":\"a\",\"B\":\"b\"} &gt;= {\"A\":\"a\",\"B\":\"b\"} true\n17 &gt;= 17.0000000000001 false\n\"foo\" &gt;= \"bar\" true\n</code></pre>"},{"location":"api/basic_json/operator_ge/#see-also","title":"See also","text":"<ul> <li>operator&lt;=&gt; comparison: 3-way</li> </ul>"},{"location":"api/basic_json/operator_ge/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/operator_gt/","title":"nlohmann::basic_json::operator&gt;","text":"<pre><code>// until C++20\nbool operator&gt;(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&gt;(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&gt;(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n</code></pre> <ol> <li> <p>Compares whether one JSON value <code>lhs</code> is greater than another JSON value <code>rhs</code> according to the   following rules:</p> <ul> <li>The comparison always yields <code>false</code> if (1) either operand is discarded, or (2) either   operand is <code>NaN</code> and the other operand is either <code>NaN</code> or any other number.</li> <li>Otherwise, returns the result of <code>!(lhs &lt;= rhs)</code> (see operator&lt;=).</li> </ul> </li> <li> <p>Compares whether a JSON value is greater than a scalar or a scalar is greater than a JSON value by    converting the scalar to a JSON value and comparing both JSON values according to 1.</p> </li> </ol>"},{"location":"api/basic_json/operator_gt/#template-parameters","title":"Template parameters","text":"<code>ScalarType</code> a scalar type according to <code>std::is_scalar&lt;ScalarType&gt;::value</code>"},{"location":"api/basic_json/operator_gt/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider  <code>rhs</code> (in) second value to consider"},{"location":"api/basic_json/operator_gt/#return-value","title":"Return value","text":"<p>whether <code>lhs</code> is greater than <code>rhs</code></p>"},{"location":"api/basic_json/operator_gt/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/operator_gt/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator_gt/#notes","title":"Notes","text":"<p>Comparing <code>NaN</code></p> <p><code>NaN</code> values are unordered within the domain of numbers. The following comparisons all yield <code>false</code>:   1. Comparing a <code>NaN</code> with itself.   2. Comparing a <code>NaN</code> with another <code>NaN</code>.   3. Comparing a <code>NaN</code> and any other number.</p> <p>Operator overload resolution</p> <p>Since C++20 overload resolution will consider the rewritten candidate generated from <code>operator&lt;=&gt;</code>.</p>"},{"location":"api/basic_json/operator_gt/#examples","title":"Examples","text":"Example <p>The example demonstrates comparing several JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array_1 = {1, 2, 3};\n    json array_2 = {1, 2, 4};\n    json object_1 = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json object_2 = {{\"B\", \"b\"}, {\"A\", \"a\"}};\n    json number_1 = 17;\n    json number_2 = 17.0000000000001L;\n    json string_1 = \"foo\";\n    json string_2 = \"bar\";\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array_1 &lt;&lt; \" &gt; \" &lt;&lt; array_2 &lt;&lt; \" \" &lt;&lt; (array_1 &gt; array_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object_1 &lt;&lt; \" &gt; \" &lt;&lt; object_2 &lt;&lt; \" \" &lt;&lt; (object_1 &gt; object_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number_1 &lt;&lt; \" &gt; \" &lt;&lt; number_2 &lt;&lt; \" \" &lt;&lt; (number_1 &gt; number_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string_1 &lt;&lt; \" &gt; \" &lt;&lt; string_2 &lt;&lt; \" \" &lt;&lt; (string_1 &gt; string_2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] &gt; [1,2,4] false\n{\"A\":\"a\",\"B\":\"b\"} &gt; {\"A\":\"a\",\"B\":\"b\"} false\n17 &gt; 17.0000000000001 false\n\"foo\" &gt; \"bar\" true\n</code></pre>"},{"location":"api/basic_json/operator_gt/#see-also","title":"See also","text":"<ul> <li>operator&lt;=&gt; comparison: 3-way</li> </ul>"},{"location":"api/basic_json/operator_gt/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/operator_le/","title":"nlohmann::basic_json::operator&lt;=","text":"<pre><code>// until C++20\nbool operator&lt;=(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&lt;=(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&lt;=(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n</code></pre> <ol> <li> <p>Compares whether one JSON value <code>lhs</code> is less than or equal to another JSON value <code>rhs</code>    according to the following rules:</p> <ul> <li>The comparison always yields <code>false</code> if (1) either operand is discarded, or (2) either   operand is <code>NaN</code> and the other operand is either <code>NaN</code> or any other number.</li> <li>Otherwise, returns the result of <code>!(rhs &lt; lhs)</code> (see operator&lt;).</li> </ul> </li> <li> <p>Compares whether a JSON value is less than or equal to a scalar or a scalar is less than or equal    to a JSON value by converting the scalar to a JSON value and comparing both JSON values according    to 1.</p> </li> </ol>"},{"location":"api/basic_json/operator_le/#template-parameters","title":"Template parameters","text":"<code>ScalarType</code> a scalar type according to <code>std::is_scalar&lt;ScalarType&gt;::value</code>"},{"location":"api/basic_json/operator_le/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider  <code>rhs</code> (in) second value to consider"},{"location":"api/basic_json/operator_le/#return-value","title":"Return value","text":"<p>whether <code>lhs</code> is less than or equal to <code>rhs</code></p>"},{"location":"api/basic_json/operator_le/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/operator_le/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator_le/#notes","title":"Notes","text":"<p>Comparing <code>NaN</code></p> <p><code>NaN</code> values are unordered within the domain of numbers. The following comparisons all yield <code>false</code>:   1. Comparing a <code>NaN</code> with itself.   2. Comparing a <code>NaN</code> with another <code>NaN</code>.   3. Comparing a <code>NaN</code> and any other number.</p> <p>Operator overload resolution</p> <p>Since C++20 overload resolution will consider the rewritten candidate generated from <code>operator&lt;=&gt;</code>.</p>"},{"location":"api/basic_json/operator_le/#examples","title":"Examples","text":"Example <p>The example demonstrates comparing several JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array_1 = {1, 2, 3};\n    json array_2 = {1, 2, 4};\n    json object_1 = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json object_2 = {{\"B\", \"b\"}, {\"A\", \"a\"}};\n    json number_1 = 17;\n    json number_2 = 17.0000000000001L;\n    json string_1 = \"foo\";\n    json string_2 = \"bar\";\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array_1 &lt;&lt; \" &lt;= \" &lt;&lt; array_2 &lt;&lt; \" \" &lt;&lt; (array_1 &lt;= array_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object_1 &lt;&lt; \" &lt;= \" &lt;&lt; object_2 &lt;&lt; \" \" &lt;&lt; (object_1 &lt;= object_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number_1 &lt;&lt; \" &lt;= \" &lt;&lt; number_2 &lt;&lt; \" \" &lt;&lt; (number_1 &lt;= number_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string_1 &lt;&lt; \" &lt;= \" &lt;&lt; string_2 &lt;&lt; \" \" &lt;&lt; (string_1 &lt;= string_2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] &lt;= [1,2,4] true\n{\"A\":\"a\",\"B\":\"b\"} &lt;= {\"A\":\"a\",\"B\":\"b\"} true\n17 &lt;= 17.0000000000001 true\n\"foo\" &lt;= \"bar\" false\n</code></pre>"},{"location":"api/basic_json/operator_le/#see-also","title":"See also","text":"<ul> <li>operator&lt;=&gt; comparison: 3-way</li> </ul>"},{"location":"api/basic_json/operator_le/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/operator_lt/","title":"nlohmann::basic_json::operator&lt;","text":"<pre><code>// until C++20\nbool operator&lt;(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&lt;(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator&lt;(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n</code></pre> <ol> <li> <p>Compares whether one JSON value <code>lhs</code> is less than another JSON value <code>rhs</code> according to the   following rules:</p> <ul> <li>If either operand is discarded, the comparison yields <code>false</code>.</li> <li>If both operands have the same type, the values are compared using their respective <code>operator&lt;</code>.</li> <li>Integer and floating-point numbers are automatically converted before comparison.</li> <li>In case <code>lhs</code> and <code>rhs</code> have different types, the values are ignored and the order of the types   is considered, which is:<ol> <li>null</li> <li>boolean</li> <li>number (all types)</li> <li>object</li> <li>array</li> <li>string</li> <li>binary   For instance, any boolean value is considered less than any string.</li> </ol> </li> </ul> </li> <li> <p>Compares whether a JSON value is less than a scalar or a scalar is less than a JSON value by converting    the scalar to a JSON value and comparing both JSON values according to 1.</p> </li> </ol>"},{"location":"api/basic_json/operator_lt/#template-parameters","title":"Template parameters","text":"<code>ScalarType</code> a scalar type according to <code>std::is_scalar&lt;ScalarType&gt;::value</code>"},{"location":"api/basic_json/operator_lt/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider  <code>rhs</code> (in) second value to consider"},{"location":"api/basic_json/operator_lt/#return-value","title":"Return value","text":"<p>whether <code>lhs</code> is less than <code>rhs</code></p>"},{"location":"api/basic_json/operator_lt/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/operator_lt/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator_lt/#notes","title":"Notes","text":"<p>Comparing <code>NaN</code></p> <p><code>NaN</code> values are unordered within the domain of numbers. The following comparisons all yield <code>false</code>:   1. Comparing a <code>NaN</code> with itself.   2. Comparing a <code>NaN</code> with another <code>NaN</code>.   3. Comparing a <code>NaN</code> and any other number.</p> <p>Operator overload resolution</p> <p>Since C++20 overload resolution will consider the rewritten candidate generated from <code>operator&lt;=&gt;</code>.</p>"},{"location":"api/basic_json/operator_lt/#examples","title":"Examples","text":"Example <p>The example demonstrates comparing several JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array_1 = {1, 2, 3};\n    json array_2 = {1, 2, 4};\n    json object_1 = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json object_2 = {{\"B\", \"b\"}, {\"A\", \"a\"}};\n    json number_1 = 17;\n    json number_2 = 17.0000000000001L;\n    json string_1 = \"foo\";\n    json string_2 = \"bar\";\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array_1 &lt;&lt; \" == \" &lt;&lt; array_2 &lt;&lt; \" \" &lt;&lt; (array_1 &lt; array_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object_1 &lt;&lt; \" == \" &lt;&lt; object_2 &lt;&lt; \" \" &lt;&lt; (object_1 &lt; object_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number_1 &lt;&lt; \" == \" &lt;&lt; number_2 &lt;&lt; \" \" &lt;&lt; (number_1 &lt; number_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string_1 &lt;&lt; \" == \" &lt;&lt; string_2 &lt;&lt; \" \" &lt;&lt; (string_1 &lt; string_2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] == [1,2,4] true\n{\"A\":\"a\",\"B\":\"b\"} == {\"A\":\"a\",\"B\":\"b\"} false\n17 == 17.0000000000001 true\n\"foo\" == \"bar\" false\n</code></pre>"},{"location":"api/basic_json/operator_lt/#see-also","title":"See also","text":"<ul> <li>operator&lt;=&gt; comparison: 3-way</li> </ul>"},{"location":"api/basic_json/operator_lt/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> <li>Added in version 1.0.0. Conditionally removed since C++20 in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/operator_ne/","title":"nlohmann::basic_json::operator!=","text":"<pre><code>// until C++20\nbool operator!=(const_reference lhs, const_reference rhs) noexcept;   // (1)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator!=(const_reference lhs, const ScalarType rhs) noexcept;  // (2)\n\ntemplate&lt;typename ScalarType&gt;\nbool operator!=(ScalarType lhs, const const_reference rhs) noexcept;  // (2)\n\n// since C++20\nclass basic_json {\n    bool operator!=(const_reference rhs) const noexcept;              // (1)\n\n    template&lt;typename ScalarType&gt;\n    bool operator!=(ScalarType rhs) const noexcept;                   // (2)\n};\n</code></pre> <ol> <li> <p>Compares two JSON values for inequality according to the following rules:</p> <ul> <li>The comparison always yields <code>false</code> if (1) either operand is discarded, or (2) either operand is <code>NaN</code> and   the other operand is either <code>NaN</code> or any other number.</li> <li>Otherwise, returns the result of <code>!(lhs == rhs)</code> (until C++20) or <code>!(*this == rhs)</code> (since C++20).</li> </ul> </li> <li> <p>Compares a JSON value and a scalar or a scalar and a JSON value for inequality by converting the scalar to a JSON    value and comparing both JSON values according to 1.</p> </li> </ol>"},{"location":"api/basic_json/operator_ne/#template-parameters","title":"Template parameters","text":"<code>ScalarType</code> a scalar type according to <code>std::is_scalar&lt;ScalarType&gt;::value</code>"},{"location":"api/basic_json/operator_ne/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider  <code>rhs</code> (in) second value to consider"},{"location":"api/basic_json/operator_ne/#return-value","title":"Return value","text":"<p>whether the values <code>lhs</code>/<code>*this</code> and <code>rhs</code> are not equal</p>"},{"location":"api/basic_json/operator_ne/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/operator_ne/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator_ne/#notes","title":"Notes","text":"<p>Comparing <code>NaN</code></p> <p><code>NaN</code> values are unordered within the domain of numbers. The following comparisons all yield <code>false</code>:   1. Comparing a <code>NaN</code> with itself.   2. Comparing a <code>NaN</code> with another <code>NaN</code>.   3. Comparing a <code>NaN</code> and any other number.</p>"},{"location":"api/basic_json/operator_ne/#examples","title":"Examples","text":"Example <p>The example demonstrates comparing several JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array_1 = {1, 2, 3};\n    json array_2 = {1, 2, 4};\n    json object_1 = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json object_2 = {{\"B\", \"b\"}, {\"A\", \"a\"}};\n    json number_1 = 17;\n    json number_2 = 17.000000000000001L;\n    json string_1 = \"foo\";\n    json string_2 = \"bar\";\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array_1 &lt;&lt; \" != \" &lt;&lt; array_2 &lt;&lt; \" \" &lt;&lt; (array_1 != array_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object_1 &lt;&lt; \" != \" &lt;&lt; object_2 &lt;&lt; \" \" &lt;&lt; (object_1 != object_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number_1 &lt;&lt; \" != \" &lt;&lt; number_2 &lt;&lt; \" \" &lt;&lt; (number_1 != number_2) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string_1 &lt;&lt; \" != \" &lt;&lt; string_2 &lt;&lt; \" \" &lt;&lt; (string_1 != string_2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] != [1,2,4] true\n{\"A\":\"a\",\"B\":\"b\"} != {\"A\":\"a\",\"B\":\"b\"} false\n17 != 17.0 false\n\"foo\" != \"bar\" true\n</code></pre> Example <p>The example demonstrates comparing several JSON types against the null pointer (JSON <code>null</code>).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create several JSON values\n    json array = {1, 2, 3};\n    json object = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json number = 17;\n    json string = \"foo\";\n    json null;\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; array &lt;&lt; \" != nullptr \" &lt;&lt; (array != nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; object &lt;&lt; \" != nullptr \" &lt;&lt; (object != nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; number &lt;&lt; \" != nullptr \" &lt;&lt; (number != nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; string &lt;&lt; \" != nullptr \" &lt;&lt; (string != nullptr) &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; \" != nullptr \" &lt;&lt; (null != nullptr) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] != nullptr true\n{\"A\":\"a\",\"B\":\"b\"} != nullptr true\n17 != nullptr true\n\"foo\" != nullptr true\nnull != nullptr false\n</code></pre>"},{"location":"api/basic_json/operator_ne/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Added C++20 member functions in version 3.11.0.</li> <li>Added in version 1.0.0. Added C++20 member functions in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/operator_spaceship/","title":"nlohmann::basic_json::operator&lt;=&gt;","text":"<pre><code>// since C++20\nclass basic_json {\n    std::partial_ordering operator&lt;=&gt;(const_reference rhs) const noexcept;  // (1)\n\n    template&lt;typename ScalarType&gt;\n    std::partial_ordering operator&lt;=&gt;(const ScalarType rhs) const noexcept; // (2)\n};\n</code></pre> <ol> <li> <p>3-way compares two JSON values producing a result of type <code>std::partial_ordering</code> according to the following rules:</p> <ul> <li>Two JSON values compare with a result of <code>std::partial_ordering::unordered</code> if either value is discarded.</li> <li>If both JSON values are of the same type, the result is produced by 3-way comparing their stored values using   their respective <code>operator&lt;=&gt;</code>.</li> <li>Integer and floating-point numbers are converted to their common type and then 3-way compared using their   respective <code>operator&lt;=&gt;</code>.   For instance, comparing an integer and a floating-point value will 3-way compare the first value converted to   floating-point with the second value.</li> <li>Otherwise, yields a result by comparing the type (see <code>value_t</code>).</li> </ul> </li> <li> <p>3-way compares a JSON value and a scalar or a scalar and a JSON value by converting the scalar to a JSON value and    3-way comparing both JSON values (see 1).</p> </li> </ol>"},{"location":"api/basic_json/operator_spaceship/#template-parameters","title":"Template parameters","text":"<code>ScalarType</code> a scalar type according to <code>std::is_scalar&lt;ScalarType&gt;::value</code>"},{"location":"api/basic_json/operator_spaceship/#parameters","title":"Parameters","text":"<code>rhs</code> (in) second value to consider"},{"location":"api/basic_json/operator_spaceship/#return-value","title":"Return value","text":"<p>the <code>std::partial_ordering</code> of the 3-way comparison of <code>*this</code> and <code>rhs</code></p>"},{"location":"api/basic_json/operator_spaceship/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/operator_spaceship/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/operator_spaceship/#notes","title":"Notes","text":"<p>Comparing <code>NaN</code></p> <ul> <li><code>NaN</code> values are unordered within the domain of numbers.   The following comparisons all yield <code>std::partial_ordering::unordered</code>:<ol> <li>Comparing a <code>NaN</code> with itself.</li> <li>Comparing a <code>NaN</code> with another <code>NaN</code>.</li> <li>Comparing a <code>NaN</code> and any other number.</li> </ol> </li> </ul>"},{"location":"api/basic_json/operator_spaceship/#examples","title":"Examples","text":"Example: (1) comparing JSON values <p>The example demonstrates comparing several JSON values.</p> <pre><code>#include &lt;compare&gt;\n#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nconst char* to_string(const std::partial_ordering&amp; po)\n{\n    if (std::is_lt(po))\n    {\n        return \"less\";\n    }\n    else if (std::is_gt(po))\n    {\n        return \"greater\";\n    }\n    else if (std::is_eq(po))\n    {\n        return \"equivalent\";\n    }\n    return \"unordered\";\n}\n\nint main()\n{\n    // create several JSON values\n    json array_1 = {1, 2, 3};\n    json array_2 = {1, 2, 4};\n    json object_1 = {{\"A\", \"a\"}, {\"B\", \"b\"}};\n    json object_2 = {{\"B\", \"b\"}, {\"A\", \"a\"}};\n    json number = 17;\n    json string = \"foo\";\n    json discarded = json(json::value_t::discarded);\n\n    // output values and comparisons\n    std::cout &lt;&lt; array_1 &lt;&lt; \" &lt;=&gt; \" &lt;&lt; array_2 &lt;&lt; \" := \" &lt;&lt; to_string(array_1 &lt;=&gt; array_2) &lt;&lt; '\\n'; // *NOPAD*\n    std::cout &lt;&lt; object_1 &lt;&lt; \" &lt;=&gt; \" &lt;&lt; object_2 &lt;&lt; \" := \" &lt;&lt; to_string(object_1 &lt;=&gt; object_2) &lt;&lt; '\\n'; // *NOPAD*\n    std::cout &lt;&lt; string &lt;&lt; \" &lt;=&gt; \" &lt;&lt; number &lt;&lt; \" := \" &lt;&lt; to_string(string &lt;=&gt; number) &lt;&lt; '\\n'; // *NOPAD*\n    std::cout &lt;&lt; string &lt;&lt; \" &lt;=&gt; \" &lt;&lt; discarded &lt;&lt; \" := \" &lt;&lt; to_string(string &lt;=&gt; discarded) &lt;&lt; '\\n'; // *NOPAD*\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3] &lt;=&gt; [1,2,4] := less\n{\"A\":\"a\",\"B\":\"b\"} &lt;=&gt; {\"A\":\"a\",\"B\":\"b\"} := equivalent\n\"foo\" &lt;=&gt; 17 := greater\n\"foo\" &lt;=&gt; &lt;discarded&gt; := unordered\n</code></pre> Example: (2) comparing JSON values and scalars <p>The example demonstrates comparing several JSON values and scalars.</p> <pre><code>#include &lt;compare&gt;\n#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nconst char* to_string(const std::partial_ordering&amp; po)\n{\n    if (std::is_lt(po))\n    {\n        return \"less\";\n    }\n    else if (std::is_gt(po))\n    {\n        return \"greater\";\n    }\n    else if (std::is_eq(po))\n    {\n        return \"equivalent\";\n    }\n    return \"unordered\";\n}\n\nint main()\n{\n    using float_limits = std::numeric_limits&lt;json::number_float_t&gt;;\n    constexpr auto nan = float_limits::quiet_NaN();\n\n    // create several JSON values\n    json boolean = false;\n    json number = 17;\n    json string = \"17\";\n\n    // output values and comparisons\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::fixed;\n    std::cout &lt;&lt; boolean &lt;&lt; \" &lt;=&gt; \" &lt;&lt; true &lt;&lt; \" := \" &lt;&lt; to_string(boolean &lt;=&gt; true) &lt;&lt; '\\n'; // *NOPAD*\n    std::cout &lt;&lt; number &lt;&lt; \" &lt;=&gt; \" &lt;&lt; 17.0 &lt;&lt; \" := \" &lt;&lt; to_string(number &lt;=&gt; 17.0) &lt;&lt; '\\n'; // *NOPAD*\n    std::cout &lt;&lt; number &lt;&lt; \" &lt;=&gt; \" &lt;&lt; nan &lt;&lt; \" := \" &lt;&lt; to_string(number &lt;=&gt; nan) &lt;&lt; '\\n'; // *NOPAD*\n    std::cout &lt;&lt; string &lt;&lt; \" &lt;=&gt; \" &lt;&lt; 17 &lt;&lt; \" := \" &lt;&lt; to_string(string &lt;=&gt; 17) &lt;&lt; '\\n'; // *NOPAD*\n}\n</code></pre> <p>Output:</p> <pre><code>false &lt;=&gt; true := less\n17 &lt;=&gt; 17.000000 := equivalent\n17 &lt;=&gt; nan := unordered\n\"17\" &lt;=&gt; 17 := greater\n</code></pre>"},{"location":"api/basic_json/operator_spaceship/#see-also","title":"See also","text":"<ul> <li>operator== - comparison: equal</li> <li>operator!= - comparison: not equal</li> <li>operator&lt; - comparison: less than</li> <li>operator&lt;= - comparison: less than or equal</li> <li>operator&gt; - comparison: greater than</li> <li>operator&gt;= - comparison: greater than or equal</li> </ul>"},{"location":"api/basic_json/operator_spaceship/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.11.0.</li> <li>Added in version 3.11.0.</li> </ol>"},{"location":"api/basic_json/operator_value_t/","title":"nlohmann::basic_json::operator value_t","text":"<pre><code>constexpr operator value_t() const noexcept;\n</code></pre> <p>Return the type of the JSON value as a value from the <code>value_t</code> enumeration.</p>"},{"location":"api/basic_json/operator_value_t/#return-value","title":"Return value","text":"<p>the type of the JSON value</p> Value type return value <code>null</code> <code>value_t::null</code> boolean <code>value_t::boolean</code> string <code>value_t::string</code> number (integer) <code>value_t::number_integer</code> number (unsigned integer) <code>value_t::number_unsigned</code> number (floating-point) <code>value_t::number_float</code> object <code>value_t::object</code> array <code>value_t::array</code> binary <code>value_t::binary</code> discarded <code>value_t::discarded</code>"},{"location":"api/basic_json/operator_value_t/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/operator_value_t/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/operator_value_t/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>operator value_t()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = -17;\n    json j_number_unsigned = 42u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call operator value_t()\n    json::value_t t_null = j_null;\n    json::value_t t_boolean = j_boolean;\n    json::value_t t_number_integer = j_number_integer;\n    json::value_t t_number_unsigned = j_number_unsigned;\n    json::value_t t_number_float = j_number_float;\n    json::value_t t_object = j_object;\n    json::value_t t_array = j_array;\n    json::value_t t_string = j_string;\n\n    // print types\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; (t_null == json::value_t::null) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (t_boolean == json::value_t::boolean) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (t_number_integer == json::value_t::number_integer) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (t_number_unsigned == json::value_t::number_unsigned) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (t_number_float == json::value_t::number_float) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (t_object == json::value_t::object) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (t_array == json::value_t::array) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (t_string == json::value_t::string) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n</code></pre>"},{"location":"api/basic_json/operator_value_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Added unsigned integer type in version 2.0.0.</li> <li>Added binary type in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/other_error/","title":"nlohmann::basic_json::other_error","text":"<pre><code>class other_error : public exception;\n</code></pre> <p>This exception is thrown in case of errors that cannot be classified with the other exception types.</p> <p>Exceptions have ids 5xx (see list of other errors).</p> <pre><code>classDiagram\n  direction LR\n\n    class std_exception [\"std::exception\"] {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n\n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception &lt;|-- json_exception\n    json_exception &lt;|-- json_parse_error\n    json_exception &lt;|-- json_invalid_iterator\n    json_exception &lt;|-- json_type_error\n    json_exception &lt;|-- json_out_of_range\n    json_exception &lt;|-- json_other_error\n\n    style json_other_error fill:#CCCCFF</code></pre>"},{"location":"api/basic_json/other_error/#member-functions","title":"Member functions","text":"<ul> <li>what - returns explanatory string</li> </ul>"},{"location":"api/basic_json/other_error/#member-variables","title":"Member variables","text":"<ul> <li>id - the id of the exception</li> </ul>"},{"location":"api/basic_json/other_error/#examples","title":"Examples","text":"Example <p>The following code shows how a <code>other_error</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    try\n    {\n        // executing a failing JSON Patch operation\n        json value = R\"({\n            \"best_biscuit\": {\n                \"name\": \"Oreo\"\n            }\n        })\"_json;\n        json patch = R\"([{\n            \"op\": \"test\",\n            \"path\": \"/best_biscuit/name\",\n            \"value\": \"Choco Leibniz\"\n        }])\"_json;\n        value.patch(patch);\n    }\n    catch (const json::other_error&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/best_biscuit/name\",\"value\":\"Choco Leibniz\"}\nexception id: 501\n</code></pre>"},{"location":"api/basic_json/other_error/#see-also","title":"See also","text":"<ul> <li>List of other errors</li> <li><code>parse_error</code> for exceptions indicating a parse error</li> <li><code>invalid_iterator</code> for exceptions indicating errors with iterators</li> <li><code>type_error</code> for exceptions indicating executing a member function with a wrong type</li> <li><code>out_of_range</code> for exceptions indicating access out of the defined range</li> </ul>"},{"location":"api/basic_json/other_error/#version-history","title":"Version history","text":"<ul> <li>Since version 3.0.0.</li> </ul>"},{"location":"api/basic_json/out_of_range/","title":"nlohmann::basic_json::out_of_range","text":"<pre><code>class out_of_range : public exception;\n</code></pre> <p>This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance, in the case of array indices or nonexisting object keys.</p> <p>Exceptions have ids 4xx (see list of out-of-range errors).</p> <pre><code>classDiagram\n  direction LR\n\n    class std_exception [\"std::exception\"] {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n\n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception &lt;|-- json_exception\n    json_exception &lt;|-- json_parse_error\n    json_exception &lt;|-- json_invalid_iterator\n    json_exception &lt;|-- json_type_error\n    json_exception &lt;|-- json_out_of_range\n    json_exception &lt;|-- json_other_error\n\n    style json_out_of_range fill:#CCCCFF</code></pre>"},{"location":"api/basic_json/out_of_range/#member-functions","title":"Member functions","text":"<ul> <li>what - returns explanatory string</li> </ul>"},{"location":"api/basic_json/out_of_range/#member-variables","title":"Member variables","text":"<ul> <li>id - the id of the exception</li> </ul>"},{"location":"api/basic_json/out_of_range/#examples","title":"Examples","text":"Example <p>The following code shows how a <code>out_of_range</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // calling at() for an invalid index\n        json j = {1, 2, 3, 4};\n        j.at(4) = 10;\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.out_of_range.401] array index 4 is out of range\nexception id: 401\n</code></pre>"},{"location":"api/basic_json/out_of_range/#see-also","title":"See also","text":"<ul> <li>List of out-of-range errors</li> <li><code>parse_error</code> for exceptions indicating a parse error</li> <li><code>invalid_iterator</code> for exceptions indicating errors with iterators</li> <li><code>type_error</code> for exceptions indicating executing a member function with a wrong type</li> <li><code>other_error</code> for exceptions indicating other library errors</li> </ul>"},{"location":"api/basic_json/out_of_range/#version-history","title":"Version history","text":"<ul> <li>Since version 3.0.0.</li> </ul>"},{"location":"api/basic_json/parse/","title":"nlohmann::basic_json::parse","text":"<pre><code>// (1)\ntemplate&lt;typename InputType&gt;\nstatic basic_json parse(InputType&amp;&amp; i,\n                        const parser_callback_t cb = nullptr,\n                        const bool allow_exceptions = true,\n                        const bool ignore_comments = false,\n                        const bool ignore_trailing_commas = false);\n\n// (2)\ntemplate&lt;typename IteratorType&gt;\nstatic basic_json parse(IteratorType first, IteratorType last,\n                        const parser_callback_t cb = nullptr,\n                        const bool allow_exceptions = true,\n                        const bool ignore_comments = false,\n                        const bool ignore_trailing_commas = false);\n</code></pre> <ol> <li>Deserialize from a compatible input.</li> <li> <p>Deserialize from a pair of character iterators</p> <p>The <code>value_type</code> of the iterator must be an integral type with size of 1, 2, or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16, and UTF-32.</p> </li> </ol>"},{"location":"api/basic_json/parse/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer (throws if null)</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters (throws if null)</li> <li>a <code>std::string</code></li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of iterators.</li> </ul> <code>IteratorType</code> <p>a compatible iterator type, for instance.</p> <ul> <li>a pair of <code>std::string::iterator</code> or <code>std::vector&lt;std::uint8_t&gt;::iterator</code></li> <li>a pair of pointers such as <code>ptr</code> and <code>ptr + len</code></li> </ul>"},{"location":"api/basic_json/parse/#parameters","title":"Parameters","text":"<code>i</code> (in) Input to parse from. <code>cb</code> (in) a parser callback function of type <code>parser_callback_t</code> which is used to control the deserialization by filtering unwanted values (optional) <code>allow_exceptions</code> (in) whether to throw exceptions in case of a parse error (optional, <code>true</code> by default) <code>ignore_comments</code> (in) whether comments should be ignored and treated like whitespace (<code>true</code>) or yield a parse error (<code>false</code>); (optional, <code>false</code> by default) <code>ignore_trailing_commas</code> (in) whether trailing commas in arrays or objects should be ignored and treated like whitespace (<code>true</code>) or yield a parse error (<code>false</code>); (optional, <code>false</code> by default) <code>first</code> (in) iterator to the start of a character range <code>last</code> (in) iterator to the end of a character range"},{"location":"api/basic_json/parse/#return-value","title":"Return value","text":"<p>Deserialized JSON value; in case of a parse error and <code>allow_exceptions</code> set to <code>false</code>, the return value will be <code>value_t::discarded</code>. The latter can be checked with <code>is_discarded</code>.</p>"},{"location":"api/basic_json/parse/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/parse/#exceptions","title":"Exceptions","text":"<ul> <li>Throws <code>parse_error.101</code> in case of an unexpected token, or   empty input like a null <code>FILE*</code> or <code>char*</code> pointer.</li> <li>Throws <code>parse_error.102</code> if <code>to_unicode</code> fails or surrogate   error.</li> <li>Throws <code>parse_error.103</code> if <code>to_unicode</code> fails.</li> </ul>"},{"location":"api/basic_json/parse/#complexity","title":"Complexity","text":"<p>Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the parser callback function <code>cb</code> or reading from (1) the input <code>i</code> or (2) the iterator range [<code>first</code>, <code>last</code>] has a super-linear complexity.</p>"},{"location":"api/basic_json/parse/#notes","title":"Notes","text":"<p>A UTF-8 byte order mark is silently ignored.</p>"},{"location":"api/basic_json/parse/#examples","title":"Examples","text":"Parsing from a character array <p>The example below demonstrates the <code>parse()</code> function reading from an array.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text\n    char text[] = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n        }\n    }\n    )\";\n\n    // parse and serialize JSON\n    json j_complete = json::parse(text);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Thumbnail\": {\n            \"Height\": 125,\n            \"Url\": \"http://www.example.com/image/481989943\",\n            \"Width\": 100\n        },\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n</code></pre> Parsing from a string <p>The example below demonstrates the <code>parse()</code> function with and without callback function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n        }\n    }\n    )\";\n\n    // parse and serialize JSON\n    json j_complete = json::parse(text);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n\n    // define parser callback\n    json::parser_callback_t cb = [](int depth, json::parse_event_t event, json &amp; parsed)\n    {\n        // skip object elements with key \"Thumbnail\"\n        if (event == json::parse_event_t::key and parsed == json(\"Thumbnail\"))\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    };\n\n    // parse (with callback) and serialize JSON\n    json j_filtered = json::parse(text, cb);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_filtered &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Thumbnail\": {\n            \"Height\": 125,\n            \"Url\": \"http://www.example.com/image/481989943\",\n            \"Width\": 100\n        },\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n\n{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n</code></pre> Parsing from an input stream <p>The example below demonstrates the <code>parse()</code> function with and without callback function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n        }\n    }\n    )\";\n\n    // fill a stream with JSON text\n    std::stringstream ss;\n    ss &lt;&lt; text;\n\n    // parse and serialize JSON\n    json j_complete = json::parse(ss);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n\n    // define parser callback\n    json::parser_callback_t cb = [](int depth, json::parse_event_t event, json &amp; parsed)\n    {\n        // skip object elements with key \"Thumbnail\"\n        if (event == json::parse_event_t::key and parsed == json(\"Thumbnail\"))\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    };\n\n    // fill a stream with JSON text\n    ss.clear();\n    ss &lt;&lt; text;\n\n    // parse (with callback) and serialize JSON\n    json j_filtered = json::parse(ss, cb);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_filtered &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Thumbnail\": {\n            \"Height\": 125,\n            \"Url\": \"http://www.example.com/image/481989943\",\n            \"Width\": 100\n        },\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n\n{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n</code></pre> Parsing from a contiguous container <p>The example below demonstrates the <code>parse()</code> function reading from a contiguous container.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text given as std::vector\n    std::vector&lt;std::uint8_t&gt; text = {'[', '1', ',', '2', ',', '3', ']', '\\0'};\n\n    // parse and serialize JSON\n    json j_complete = json::parse(text);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>[\n    1,\n    2,\n    3\n]\n</code></pre> Parsing from a non-null-terminated string <p>The example below demonstrates the <code>parse()</code> function reading from a string that is not null-terminated.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text given as string that is not null-terminated\n    const char* ptr = \"[1,2,3]another value\";\n\n    // parse and serialize JSON\n    json j_complete = json::parse(ptr, ptr + 7);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>[\n    1,\n    2,\n    3\n]\n</code></pre> Parsing from an iterator pair <p>The example below demonstrates the <code>parse()</code> function reading from an iterator pair.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text given an input with other values\n    std::vector&lt;std::uint8_t&gt; input = {'[', '1', ',', '2', ',', '3', ']', 'o', 't', 'h', 'e', 'r'};\n\n    // parse and serialize JSON\n    json j_complete = json::parse(input.begin(), input.begin() + 7);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>[\n    1,\n    2,\n    3\n]\n</code></pre> Effect of <code>allow_exceptions</code> parameter <p>The example below demonstrates the effect of the <code>allow_exceptions</code> parameter in the \u00b4parse()` function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // an invalid JSON text\n    std::string text = R\"(\n    {\n        \"key\": \"value without closing quotes\n    }\n    )\";\n\n    // parse with exceptions\n    try\n    {\n        json j = json::parse(text);\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // parse without exceptions\n    json j = json::parse(text, nullptr, false);\n\n    if (j.is_discarded())\n    {\n        std::cout &lt;&lt; \"the input is invalid JSON\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; \"the input is valid JSON: \" &lt;&lt; j &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.101] parse error at line 4, column 0: syntax error while parsing value - invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n; last read: '\"value without closing quotes&lt;U+000A&gt;'\nthe input is invalid JSON\n</code></pre> Effect of <code>ignore_comments</code> parameter <p>The example below demonstrates the effect of the <code>ignore_comments</code> parameter in the <code>parse()</code> function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string s = R\"(\n    {\n        // update in 2006: removed Pluto\n        \"planets\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n                    \"Jupiter\", \"Uranus\", \"Neptune\" /*, \"Pluto\" */]\n    }\n    )\";\n\n    try\n    {\n        json j = json::parse(s);\n    }\n    catch (json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    json j = json::parse(s,\n                         /* callback */ nullptr,\n                         /* allow exceptions */ true,\n                         /* ignore_comments */ true);\n    std::cout &lt;&lt; j.dump(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.101] parse error at line 3, column 9: syntax error while parsing object key - invalid literal; last read: '&lt;U+000A&gt;    {&lt;U+000A&gt;        /'; expected string literal\n{\n  \"planets\": [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Uranus\",\n    \"Neptune\"\n  ]\n}\n</code></pre> Effect of <code>ignore_trailing_commas</code> parameter <p>The example below demonstrates the effect of the <code>ignore_trailing_commas</code> parameter in the <code>parse()</code> function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string s = R\"(\n    {\n        \"planets\": [\n            \"Mercury\",\n            \"Venus\",\n            \"Earth\",\n            \"Mars\",\n            \"Jupiter\",\n            \"Uranus\",\n            \"Neptune\",\n        ]\n    }\n    )\";\n\n    try\n    {\n        json j = json::parse(s);\n    }\n    catch (json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    json j = json::parse(s,\n                         /* callback */ nullptr,\n                         /* allow exceptions */ true,\n                         /* ignore_comments */ false,\n                         /* ignore_trailing_commas */ true);\n    std::cout &lt;&lt; j.dump(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.101] parse error at line 11, column 9: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal\n{\n  \"planets\": [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Uranus\",\n    \"Neptune\"\n  ]\n}\n</code></pre>"},{"location":"api/basic_json/parse/#see-also","title":"See also","text":"<ul> <li>accept - check if the input is valid JSON</li> <li>operator&gt;&gt; - deserialize from stream</li> </ul>"},{"location":"api/basic_json/parse/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Overload for contiguous containers (1) added in version 2.0.3.</li> <li>Ignoring comments via <code>ignore_comments</code> added in version 3.9.0.</li> <li>Changed runtime assertion in case of <code>FILE*</code> null pointers to exception in version 3.12.0.</li> <li>Added <code>ignore_trailing_commas</code> in version 3.12.1.</li> </ul> <p>Deprecation</p> <p>Overload (2) replaces calls to <code>parse</code> with a pair of iterators as their first parameter which has been deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like <code>parse({ptr, ptr+len}, ...);</code> with <code>parse(ptr, ptr+len, ...);</code>.</p> <p>You should be warned by your compiler with a <code>-Wdeprecated-declarations</code> warning if you are using a deprecated function.</p>"},{"location":"api/basic_json/parse_error/","title":"nlohmann::basic_json::parse_error","text":"<pre><code>class parse_error : public exception;\n</code></pre> <p>The library throws this exception when a parse error occurs. Parse errors can occur during the deserialization of JSON text, BSON, CBOR, MessagePack, UBJSON, as well as when using JSON Patch.</p> <p>Member <code>byte</code> holds the byte index of the last read character in the input file (see note below).</p> <p>Exceptions have ids 1xx (see list of parse errors).</p> <pre><code>classDiagram\n  direction LR\n\n    class std_exception [\"std::exception\"] {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n\n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception &lt;|-- json_exception\n    json_exception &lt;|-- json_parse_error\n    json_exception &lt;|-- json_invalid_iterator\n    json_exception &lt;|-- json_type_error\n    json_exception &lt;|-- json_out_of_range\n    json_exception &lt;|-- json_other_error\n\n    style json_parse_error fill:#CCCCFF</code></pre>"},{"location":"api/basic_json/parse_error/#member-functions","title":"Member functions","text":"<ul> <li>what - returns explanatory string</li> </ul>"},{"location":"api/basic_json/parse_error/#member-variables","title":"Member variables","text":"<ul> <li>id - the id of the exception</li> <li>byte - byte index of the parse error</li> </ul>"},{"location":"api/basic_json/parse_error/#notes","title":"Notes","text":"<p>For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector for binary formats.</p>"},{"location":"api/basic_json/parse_error/#examples","title":"Examples","text":"Example <p>The following code shows how a <code>parse_error</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // parsing input with a syntax error\n        json::parse(\"[1,2,3,]\");\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; '\\n'\n                  &lt;&lt; \"byte position of error: \" &lt;&lt; e.byte &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal\nexception id: 101\nbyte position of error: 8\n</code></pre>"},{"location":"api/basic_json/parse_error/#see-also","title":"See also","text":"<ul> <li>List of parse errors</li> <li><code>invalid_iterator</code> for exceptions indicating errors with iterators</li> <li><code>type_error</code> for exceptions indicating executing a member function with a wrong type</li> <li><code>out_of_range</code> for exceptions indicating access out of the defined range</li> <li><code>other_error</code> for exceptions indicating other library errors</li> </ul>"},{"location":"api/basic_json/parse_error/#version-history","title":"Version history","text":"<ul> <li>Since version 3.0.0.</li> </ul>"},{"location":"api/basic_json/parse_event_t/","title":"nlohmann::basic_json::parse_event_t","text":"<pre><code>enum class parse_event_t : std::uint8_t {\n    object_start,\n    object_end,\n    array_start,\n    array_end,\n    key,\n    value\n};\n</code></pre> <p>The parser callback distinguishes the following events:</p> <ul> <li><code>object_start</code>: the parser read <code>{</code> and started to process a JSON object</li> <li><code>key</code>: the parser read a key of a value in an object</li> <li><code>object_end</code>: the parser read <code>}</code> and finished processing a JSON object</li> <li><code>array_start</code>: the parser read <code>[</code> and started to process a JSON array</li> <li><code>array_end</code>: the parser read <code>]</code> and finished processing a JSON array</li> <li><code>value</code>: the parser finished reading a JSON value</li> </ul>"},{"location":"api/basic_json/parse_event_t/#examples","title":"Examples","text":""},{"location":"api/basic_json/parse_event_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/parser_callback_t/","title":"nlohmann::basic_json::parser_callback_t","text":"<pre><code>template&lt;typename BasicJsonType&gt;\nusing parser_callback_t =\n    std::function&lt;bool(int depth, parse_event_t event, BasicJsonType&amp; parsed)&gt;;\n</code></pre> <p>With a parser callback function, the result of parsing a JSON text can be influenced. When passed to <code>parse</code>, it is called on certain events (passed as <code>parse_event_t</code> via parameter <code>event</code>) with a set recursion depth <code>depth</code> and context JSON value <code>parsed</code>. The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not.</p> <p>We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters <code>depth</code>, <code>event</code>, and <code>parsed</code>.</p> parameter <code>event</code> description parameter <code>depth</code> parameter <code>parsed</code> <code>parse_event_t::object_start</code> the parser read <code>{</code> and started to process a JSON object depth of the parent of the JSON object a JSON value with type discarded <code>parse_event_t::key</code> the parser read a key of a value in an object depth of the currently parsed JSON object a JSON string containing the key <code>parse_event_t::object_end</code> the parser read <code>}</code> and finished processing a JSON object depth of the parent of the JSON object the parsed JSON object <code>parse_event_t::array_start</code> the parser read <code>[</code> and started to process a JSON array depth of the parent of the JSON array a JSON value with type discarded <code>parse_event_t::array_end</code> the parser read <code>]</code> and finished processing a JSON array depth of the parent of the JSON array the parsed JSON array <code>parse_event_t::value</code> the parser finished reading a JSON value depth of the value the parsed JSON value <p></p> <p>Discarding a value (i.e., returning <code>false</code>) has different effects depending on the context in which function was called:</p> <ul> <li>Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never   read.</li> <li>In case a value outside a structured type is skipped, it is replaced with <code>null</code>. This case happens if the top-level   element is skipped.</li> </ul>"},{"location":"api/basic_json/parser_callback_t/#parameters","title":"Parameters","text":"<code>depth</code> (in) the depth of the recursion during parsing <code>event</code> (in) an event of type <code>parse_event_t</code> indicating the context in the callback function has been called <code>parsed</code> (in, out) the current intermediate parse result; note that  writing to this value has no effect for <code>parse_event_t::key</code> events"},{"location":"api/basic_json/parser_callback_t/#return-value","title":"Return value","text":"<p>Whether the JSON value which called the function during parsing should be kept (<code>true</code>) or not (<code>false</code>). In the latter case, it is either skipped completely or replaced by an empty discarded object.</p>"},{"location":"api/basic_json/parser_callback_t/#examples","title":"Examples","text":"Example <p>The example below demonstrates the <code>parse()</code> function with and without callback function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n        }\n    }\n    )\";\n\n    // parse and serialize JSON\n    json j_complete = json::parse(text);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n\n    // define parser callback\n    json::parser_callback_t cb = [](int depth, json::parse_event_t event, json &amp; parsed)\n    {\n        // skip object elements with key \"Thumbnail\"\n        if (event == json::parse_event_t::key and parsed == json(\"Thumbnail\"))\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    };\n\n    // parse (with callback) and serialize JSON\n    json j_filtered = json::parse(text, cb);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_filtered &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Thumbnail\": {\n            \"Height\": 125,\n            \"Url\": \"http://www.example.com/image/481989943\",\n            \"Width\": 100\n        },\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n\n{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n</code></pre>"},{"location":"api/basic_json/parser_callback_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/patch/","title":"nlohmann::basic_json::patch","text":"<pre><code>basic_json patch(const basic_json&amp; json_patch) const;\n</code></pre> <p>JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JSON document. With this function, a JSON Patch is applied to the current JSON value by executing all operations from the patch.</p>"},{"location":"api/basic_json/patch/#parameters","title":"Parameters","text":"<code>json_patch</code> (in) JSON patch document"},{"location":"api/basic_json/patch/#return-value","title":"Return value","text":"<p>patched document</p>"},{"location":"api/basic_json/patch/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/patch/#exceptions","title":"Exceptions","text":"<ul> <li>Throws <code>parse_error.104</code> if the JSON patch does not consist of   an array of objects.</li> <li>Throws <code>parse_error.105</code> if the JSON patch is malformed (e.g.,   mandatory attributes are missing); example: <code>\"operation add must have member path\"</code>.</li> <li>Throws <code>out_of_range.401</code> if an array index is out of range.</li> <li>Throws <code>out_of_range.403</code> if a JSON pointer inside the patch   could not be resolved successfully in the current JSON value; example: <code>\"key baz not found\"</code>.</li> <li>Throws <code>out_of_range.405</code> if JSON pointer has no parent   (\"add\", \"remove\", \"move\")</li> <li>Throws <code>out_of_range.501</code> if \"test\" operation was   unsuccessful.</li> </ul>"},{"location":"api/basic_json/patch/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value and the length of the JSON patch. As usually the patch affects only a fraction of the JSON value, the complexity can usually be neglected.</p>"},{"location":"api/basic_json/patch/#notes","title":"Notes","text":"<p>The application of a patch is atomic: Either all operations succeed and the patched document is returned or an exception is thrown. In any case, the original value is not changed: the patch is applied to a copy of the value.</p>"},{"location":"api/basic_json/patch/#examples","title":"Examples","text":"Example <p>The following code shows how a JSON patch is applied to a value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // the original document\n    json doc = R\"(\n        {\n          \"baz\": \"qux\",\n          \"foo\": \"bar\"\n        }\n    )\"_json;\n\n    // the patch\n    json patch = R\"(\n        [\n          { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" },\n          { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] },\n          { \"op\": \"remove\", \"path\": \"/foo\"}\n        ]\n    )\"_json;\n\n    // apply the patch\n    json patched_doc = doc.patch(patch);\n\n    // output original and patched document\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; doc &lt;&lt; \"\\n\\n\"\n              &lt;&lt; std::setw(4) &lt;&lt; patched_doc &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"baz\": \"qux\",\n    \"foo\": \"bar\"\n}\n\n{\n    \"baz\": \"boo\",\n    \"hello\": [\n        \"world\"\n    ]\n}\n</code></pre>"},{"location":"api/basic_json/patch/#see-also","title":"See also","text":"<ul> <li>RFC 6902 (JSON Patch)</li> <li>RFC 6901 (JSON Pointer)</li> <li>patch_inplace applies a JSON Patch without creating a copy of the document</li> <li>merge_patch applies a JSON Merge Patch</li> </ul>"},{"location":"api/basic_json/patch/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> </ul>"},{"location":"api/basic_json/patch_inplace/","title":"nlohmann::basic_json::patch_inplace","text":"<pre><code>void patch_inplace(const basic_json&amp; json_patch) const;\n</code></pre> <p>JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JSON document. With this function, a JSON Patch is applied to the current JSON value by executing all operations from the patch. This function applies a JSON patch in place and returns void.</p>"},{"location":"api/basic_json/patch_inplace/#parameters","title":"Parameters","text":"<code>json_patch</code> (in) JSON patch document"},{"location":"api/basic_json/patch_inplace/#exception-safety","title":"Exception safety","text":"<p>No guarantees, value may be corrupted by an unsuccessful patch operation.</p>"},{"location":"api/basic_json/patch_inplace/#exceptions","title":"Exceptions","text":"<ul> <li>Throws <code>parse_error.104</code> if the JSON patch does not consist of   an array of objects.</li> <li>Throws <code>parse_error.105</code> if the JSON patch is malformed (e.g.,   mandatory attributes are missing); example: <code>\"operation add must have member path\"</code>.</li> <li>Throws <code>out_of_range.401</code> if an array index is out of range.</li> <li>Throws <code>out_of_range.403</code> if a JSON pointer inside the patch   could not be resolved successfully in the current JSON value; example: <code>\"key baz not found\"</code>.</li> <li>Throws <code>out_of_range.405</code> if JSON pointer has no parent   (\"add\", \"remove\", \"move\")</li> <li>Throws <code>out_of_range.501</code> if \"test\" operation was   unsuccessful.</li> </ul>"},{"location":"api/basic_json/patch_inplace/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value and the length of the JSON patch. As usually the patch affects only a fraction of the JSON value, the complexity can usually be neglected.</p>"},{"location":"api/basic_json/patch_inplace/#notes","title":"Notes","text":"<p>Unlike <code>patch</code>, <code>patch_inplace</code> applies the operation \"in place\" and no copy of the JSON value is created. That makes it faster for large documents by avoiding the copy. However, the JSON value might be corrupted if the function throws an exception.</p>"},{"location":"api/basic_json/patch_inplace/#examples","title":"Examples","text":"Example <p>The following code shows how a JSON patch is applied to a value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // the original document\n    json doc = R\"(\n        {\n          \"baz\": \"qux\",\n          \"foo\": \"bar\"\n        }\n    )\"_json;\n\n    // the patch\n    json patch = R\"(\n        [\n          { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" },\n          { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] },\n          { \"op\": \"remove\", \"path\": \"/foo\"}\n        ]\n    )\"_json;\n\n    // output original document\n    std::cout &lt;&lt; \"Before\\n\" &lt;&lt; std::setw(4) &lt;&lt; doc &lt;&lt; std::endl;\n\n    // apply the patch\n    doc.patch_inplace(patch);\n\n    // output patched document\n    std::cout &lt;&lt; \"\\nAfter\\n\" &lt;&lt; std::setw(4) &lt;&lt; doc &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>Before\n{\n    \"baz\": \"qux\",\n    \"foo\": \"bar\"\n}\n\nAfter\n{\n    \"baz\": \"boo\",\n    \"hello\": [\n        \"world\"\n    ]\n}\n</code></pre>"},{"location":"api/basic_json/patch_inplace/#see-also","title":"See also","text":"<ul> <li>RFC 6902 (JSON Patch)</li> <li>RFC 6901 (JSON Pointer)</li> <li>patch applies a JSON Merge Patch</li> <li>merge_patch applies a JSON Merge Patch</li> </ul>"},{"location":"api/basic_json/patch_inplace/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/basic_json/push_back/","title":"nlohmann::basic_json::push_back","text":"<pre><code>// (1)\nvoid push_back(basic_json&amp;&amp; val);\nvoid push_back(const basic_json&amp; val);\n\n// (2)\nvoid push_back(const typename object_t::value_type&amp; val);\n\n// (3)\nvoid push_back(initializer_list_t init);\n</code></pre> <ol> <li> <p>Appends the given element <code>val</code> to the end of the JSON array. If the function is called on a JSON null value, an    empty array is created before appending <code>val</code>.</p> </li> <li> <p>Inserts the given element <code>val</code> to the JSON object. If the function is called on a JSON null value, an empty object    is created before inserting <code>val</code>.</p> </li> <li> <p>This function allows using <code>push_back</code> with an initializer list. In case</p> <ol> <li>the current value is an object,</li> <li>the initializer list <code>init</code> contains only two elements, and</li> <li>the first element of <code>init</code> is a string,</li> </ol> <p><code>init</code> is converted into an object element and added using <code>push_back(const typename object_t::value_type&amp;)</code>. Otherwise, <code>init</code> is converted to a JSON value and added using <code>push_back(basic_json&amp;&amp;)</code>.</p> </li> </ol>"},{"location":"api/basic_json/push_back/#iterator-invalidation","title":"Iterator invalidation","text":"<p>For all cases where an element is added to an array, a reallocation can happen, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated. Otherwise, only the <code>end()</code> iterator is invalidated.</p> <p>For <code>ordered_json</code>, also adding an element to an object can yield a reallocation which again invalidates all iterators and all references.</p>"},{"location":"api/basic_json/push_back/#parameters","title":"Parameters","text":"<code>val</code> (in) the value to add to the JSON array/object <code>init</code> (in) an initializer list"},{"location":"api/basic_json/push_back/#exceptions","title":"Exceptions","text":"<p>All functions can throw the following exception:   - Throws <code>type_error.308</code> when called on a type other than     JSON array or null; example: <code>\"cannot use push_back() with number\"</code></p>"},{"location":"api/basic_json/push_back/#complexity","title":"Complexity","text":"<ol> <li>Amortized constant.</li> <li>Logarithmic in the size of the container, O(log(<code>size()</code>)).</li> <li>Linear in the size of the initializer list <code>init</code>.</li> </ol>"},{"location":"api/basic_json/push_back/#notes","title":"Notes","text":"<p>(3) This function is required to resolve an ambiguous overload error, because pairs like <code>{\"key\", \"value\"}</code> can be both     interpreted as <code>object_t::value_type</code> or <code>std::initializer_list&lt;basic_json&gt;</code>, see     #235 for more information.</p>"},{"location":"api/basic_json/push_back/#examples","title":"Examples","text":"Example: (1) add element to array <p>The example shows how <code>push_back()</code> and <code>+=</code> can be used to add elements to a JSON array. Note how the <code>null</code> value was silently converted to a JSON array.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json array = {1, 2, 3, 4, 5};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values\n    array.push_back(6);\n    array += 7;\n    null += \"first\";\n    null += \"second\";\n\n    // print values\n    std::cout &lt;&lt; array &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[1,2,3,4,5]\nnull\n[1,2,3,4,5,6,7]\n[\"first\",\"second\"]\n</code></pre> Example: (2) add element to object <p>The example shows how <code>push_back()</code> and <code>+=</code> can be used to add elements to a JSON object. Note how the <code>null</code> value was silently converted to a JSON object.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json object = {{\"one\", 1}, {\"two\", 2}};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values\n    object.push_back(json::object_t::value_type(\"three\", 3));\n    object += json::object_t::value_type(\"four\", 4);\n    null += json::object_t::value_type(\"A\", \"a\");\n    null += json::object_t::value_type(\"B\", \"b\");\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\nnull\n{\"four\":4,\"one\":1,\"three\":3,\"two\":2}\n{\"A\":\"a\",\"B\":\"b\"}\n</code></pre> Example: (3) add to object from initializer list <p>The example shows how initializer lists are treated as objects when possible.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json object = {{\"one\", 1}, {\"two\", 2}};\n    json null;\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // add values:\n    object.push_back({\"three\", 3});  // object is extended\n    object += {\"four\", 4};           // object is extended\n    null.push_back({\"five\", 5});     // null is converted to array\n\n    // print values\n    std::cout &lt;&lt; object &lt;&lt; '\\n';\n    std::cout &lt;&lt; null &lt;&lt; '\\n';\n\n    // would throw:\n    //object.push_back({1, 2, 3});\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\nnull\n{\"four\":4,\"one\":1,\"three\":3,\"two\":2}\n[[\"five\",5]]\n</code></pre>"},{"location":"api/basic_json/push_back/#see-also","title":"See also","text":"<ul> <li>emplace_back add a value to an array</li> <li>operator+= add a value to an array/object</li> </ul>"},{"location":"api/basic_json/push_back/#version-history","title":"Version history","text":"<ol> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 2.0.0.</li> </ol>"},{"location":"api/basic_json/rbegin/","title":"nlohmann::basic_json::rbegin","text":"<pre><code>reverse_iterator rbegin() noexcept;\nconst_reverse_iterator rbegin() const noexcept;\n</code></pre> <p>Returns an iterator to the reverse-beginning; that is, the last element.</p> <p></p>"},{"location":"api/basic_json/rbegin/#return-value","title":"Return value","text":"<p>reverse iterator to the first element</p>"},{"location":"api/basic_json/rbegin/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/rbegin/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/rbegin/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>rbegin()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to the reverse-beginning\n    json::reverse_iterator it = array.rbegin();\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>5\n</code></pre>"},{"location":"api/basic_json/rbegin/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/rend/","title":"nlohmann::basic_json::rend","text":"<pre><code>reverse_iterator rend() noexcept;\nconst_reverse_iterator rend() const noexcept;\n</code></pre> <p>Returns an iterator to the reverse-end; that is, one before the first element. This element acts as a placeholder, attempting to access it results in undefined behavior.</p> <p></p>"},{"location":"api/basic_json/rend/#return-value","title":"Return value","text":"<p>reverse iterator to the element following the last element</p>"},{"location":"api/basic_json/rend/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/rend/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/rend/#examples","title":"Examples","text":"Example <p>The following code shows an example for <code>eend()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create an array value\n    json array = {1, 2, 3, 4, 5};\n\n    // get an iterator to the reverse-end\n    json::reverse_iterator it = array.rend();\n\n    // increment the iterator to point to the first element\n    --it;\n\n    // serialize the element that the iterator points to\n    std::cout &lt;&lt; *it &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>1\n</code></pre>"},{"location":"api/basic_json/rend/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/sax_parse/","title":"nlohmann::basic_json::sax_parse","text":"<pre><code>// (1)\ntemplate &lt;typename InputType, typename SAX&gt;\nstatic bool sax_parse(InputType&amp;&amp; i,\n                      SAX* sax,\n                      input_format_t format = input_format_t::json,\n                      const bool strict = true,\n                      const bool ignore_comments = false,\n                      const bool ignore_trailing_commas = false);\n\n// (2)\ntemplate&lt;class IteratorType, class SAX&gt;\nstatic bool sax_parse(IteratorType first, IteratorType last,\n                      SAX* sax,\n                      input_format_t format = input_format_t::json,\n                      const bool strict = true,\n                      const bool ignore_comments = false,\n                      const bool ignore_trailing_commas = false);\n</code></pre> <p>Read from input and generate SAX events</p> <ol> <li>Read from a compatible input.</li> <li> <p>Read from a pair of character iterators</p> <p>The value_type of the iterator must be an integral type with a size of 1, 2, or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16, and UTF-32.</p> </li> </ol> <p>The SAX event lister must follow the interface of <code>json_sax</code>.</p>"},{"location":"api/basic_json/sax_parse/#template-parameters","title":"Template parameters","text":"<code>InputType</code> <p>A compatible input, for instance:</p> <ul> <li>an <code>std::istream</code> object</li> <li>a <code>FILE</code> pointer</li> <li>a C-style array of characters</li> <li>a pointer to a null-terminated string of single byte characters</li> <li>an object <code>obj</code> for which <code>begin(obj)</code> and <code>end(obj)</code> produces a valid pair of   iterators.</li> </ul> <code>IteratorType</code> Description <code>SAX</code> Description"},{"location":"api/basic_json/sax_parse/#parameters","title":"Parameters","text":"<code>i</code> (in) Input to parse from <code>sax</code> (in) SAX event listener (must not be null) <code>format</code> (in) the format to parse (JSON, CBOR, MessagePack, or UBJSON) (optional, <code>input_format_t::json</code> by default), see  <code>input_format_t</code> for more information <code>strict</code> (in) whether the input has to be consumed completely (optional, <code>true</code> by default) <code>ignore_comments</code> (in) whether comments should be ignored and treated like whitespace (<code>true</code>) or yield a parse error (<code>false</code>); (optional, <code>false</code> by default) <code>ignore_trailing_commas</code> (in) whether trailing commas in arrays or objects should be ignored and treated like whitespace (<code>true</code>) or yield a parse error (<code>false</code>); (optional, <code>false</code> by default) <code>first</code> (in) iterator to the start of a character range <code>last</code> (in) iterator to the end of a character range"},{"location":"api/basic_json/sax_parse/#return-value","title":"Return value","text":"<p>return value of the last processed SAX event</p>"},{"location":"api/basic_json/sax_parse/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/sax_parse/#exceptions","title":"Exceptions","text":"<ul> <li>Throws <code>parse_error.101</code> in case of an unexpected token, or   empty input like a null <code>FILE*</code> or <code>char*</code> pointer.</li> <li>Throws <code>parse_error.102</code> if <code>to_unicode</code> fails or surrogate   error.</li> <li>Throws <code>parse_error.103</code> if <code>to_unicode</code> fails.</li> <li>Throws <code>other_error.502</code> if <code>sax</code> is a null pointer.</li> </ul>"},{"location":"api/basic_json/sax_parse/#complexity","title":"Complexity","text":"<p>Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the SAX consumer <code>sax</code> has a super-linear complexity.</p>"},{"location":"api/basic_json/sax_parse/#notes","title":"Notes","text":"<p>A UTF-8 byte order mark is silently ignored.</p>"},{"location":"api/basic_json/sax_parse/#examples","title":"Examples","text":"Example <p>The example below demonstrates the <code>sax_parse()</code> function reading from string and processing the events with a user-defined SAX event consumer.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/basic_json/sax_parse/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> <li>Ignoring comments via <code>ignore_comments</code> added in version 3.9.0.</li> <li>Added <code>ignore_trailing_commas</code> in version 3.12.1.</li> <li>Added <code>json.exception.other_error.502</code> exception in version 3.12.1.</li> </ul> <p>Deprecation</p> <p>Overload (2) replaces calls to <code>sax_parse</code> with a pair of iterators as their first parameter which has been deprecated in version 3.8.0. This overload will be removed in version 4.0.0. Please replace all calls like <code>sax_parse({ptr, ptr+len});</code> with <code>sax_parse(ptr, ptr+len);</code>.</p>"},{"location":"api/basic_json/size/","title":"nlohmann::basic_json::size","text":"<pre><code>size_type size() const noexcept;\n</code></pre> <p>Returns the number of elements in a JSON value.</p>"},{"location":"api/basic_json/size/#return-value","title":"Return value","text":"<p>The return value depends on the different types and is defined as follows:</p> Value type return value null <code>0</code> boolean <code>1</code> string <code>1</code> number <code>1</code> binary <code>1</code> object result of function object_t::size() array result of function array_t::size()"},{"location":"api/basic_json/size/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/basic_json/size/#complexity","title":"Complexity","text":"<p>Constant, as long as <code>array_t</code> and <code>object_t</code> satisfy the Container concept; that is, their <code>size()</code> functions have constant complexity.</p>"},{"location":"api/basic_json/size/#notes","title":"Notes","text":"<p>This function does not return the length of a string stored as JSON value -- it returns the number of elements in the JSON value which is <code>1</code> in the case of a string.</p>"},{"location":"api/basic_json/size/#examples","title":"Examples","text":"Example <p>The following code calls <code>size()</code> on the different value types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = 17;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_object_empty(json::value_t::object);\n    json j_array = {1, 2, 4, 8, 16};\n    json j_array_empty(json::value_t::array);\n    json j_string = \"Hello, world\";\n\n    // call size()\n    std::cout &lt;&lt; j_null.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object_empty.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array_empty.size() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string.size() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>0\n1\n1\n1\n2\n0\n5\n0\n1\n</code></pre>"},{"location":"api/basic_json/size/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended to return <code>1</code> for binary types in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/start_pos/","title":"nlohmann::basic_json::start_pos","text":"<pre><code>#if JSON_DIAGNOSTIC_POSITIONS\nconstexpr std::size_t start_pos() const noexcept;\n#endif\n</code></pre> <p>Returns the position of the first character in the JSON string from which the value was parsed from.</p> JSON type return value object position of the opening <code>{</code> array position of the opening <code>[</code> string position of the opening <code>\"</code> number position of the first character boolean position of <code>t</code> for <code>true</code> and <code>f</code> for <code>false</code> null position of <code>n</code>"},{"location":"api/basic_json/start_pos/#return-value","title":"Return value","text":"<p>the position of the first character of the value in the parsed JSON string, if the value was created by the <code>parse</code> function, or <code>std::string::npos</code> if the value was constructed otherwise</p>"},{"location":"api/basic_json/start_pos/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/start_pos/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/start_pos/#notes","title":"Notes","text":"<p>Note</p> <p>The function is only available if macro <code>JSON_DIAGNOSTIC_POSITIONS</code> has been defined to <code>1</code> before including the library header.</p> <p>Invalidation</p> <p>The returned positions are only valid as long as the JSON value is not changed. The positions are not updated when the JSON value is changed.</p>"},{"location":"api/basic_json/start_pos/#examples","title":"Examples","text":"Example <pre><code>#include &lt;iostream&gt;\n\n#define JSON_DIAGNOSTIC_POSITIONS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string json_string = R\"(\n    {\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\n    )\";\n    json j = json::parse(json_string);\n\n    std::cout &lt;&lt; \"Root diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos: \" &lt;&lt; j.start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j.end_pos() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"{\\n        \\\"address\\\": {\\n            \\\"street\\\": \\\"Fake Street\\\",\\n            \\\"housenumber\\\": 1\\n        }\\n    }\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j.start_pos(), j.end_pos() - j.start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"address diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"{            \\\"street\\\": \\\"Fake Street\\\",\\n            \\\"housenumber\\\": 1\\n        }\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"].start_pos(), j[\"address\"].end_pos() - j[\"address\"].start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"street diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"][\"street\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"][\"street\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"\\\"Fake Street\\\"\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"][\"street\"].start_pos(), j[\"address\"][\"street\"].end_pos() - j[\"address\"][\"street\"].start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"housenumber diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"][\"housenumber\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"][\"housenumber\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"1\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"][\"housenumber\"].start_pos(), j[\"address\"][\"housenumber\"].end_pos() - j[\"address\"][\"housenumber\"].start_pos()) &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>Root diagnostic positions: \n    start_pos: 5\n    end_pos:109\nOriginal string: \n{\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\nParsed string: \n{\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\n\naddress diagnostic positions: \n    start_pos:26\n    end_pos:103\n\nOriginal string: \n{            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\nParsed string: \n{\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n\nstreet diagnostic positions: \n    start_pos:50\n    end_pos:63\n\nOriginal string: \n\"Fake Street\"\nParsed string: \n\"Fake Street\"\n\nhousenumber diagnostic positions: \n    start_pos:92\n    end_pos:93\n\nOriginal string: \n1\nParsed string: \n1\n</code></pre> <p>The output shows the start/end positions of all the objects and fields in the JSON string.</p>"},{"location":"api/basic_json/start_pos/#see-also","title":"See also","text":"<ul> <li>end_pos to access the end position</li> <li>JSON_DIAGNOSTIC_POSITIONS for an overview of the diagnostic positions</li> </ul>"},{"location":"api/basic_json/start_pos/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.12.0.</li> </ul>"},{"location":"api/basic_json/std_hash/","title":"std::hash&lt;nlohmann::basic_json&gt;","text":"<pre><code>namespace std {\n    struct hash&lt;nlohmann::basic_json&gt;;\n}\n</code></pre> <p>Return a hash value for a JSON object. The hash function tries to rely on <code>std::hash</code> where possible. Furthermore, the type of the JSON value is taken into account to have different hash values for <code>null</code>, <code>0</code>, <code>0U</code>, and <code>false</code>, etc.</p>"},{"location":"api/basic_json/std_hash/#examples","title":"Examples","text":"Example <p>The example shows how to calculate hash values for different JSON values.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    std::cout &lt;&lt; \"hash(null) = \" &lt;&lt; std::hash&lt;json&gt; {}(json(nullptr)) &lt;&lt; '\\n'\n              &lt;&lt; \"hash(false) = \" &lt;&lt; std::hash&lt;json&gt; {}(json(false)) &lt;&lt; '\\n'\n              &lt;&lt; \"hash(0) = \" &lt;&lt; std::hash&lt;json&gt; {}(json(0)) &lt;&lt; '\\n'\n              &lt;&lt; \"hash(0U) = \" &lt;&lt; std::hash&lt;json&gt; {}(json(0U)) &lt;&lt; '\\n'\n              &lt;&lt; \"hash(\\\"\\\") = \" &lt;&lt; std::hash&lt;json&gt; {}(json(\"\")) &lt;&lt; '\\n'\n              &lt;&lt; \"hash({}) = \" &lt;&lt; std::hash&lt;json&gt; {}(json::object()) &lt;&lt; '\\n'\n              &lt;&lt; \"hash([]) = \" &lt;&lt; std::hash&lt;json&gt; {}(json::array()) &lt;&lt; '\\n'\n              &lt;&lt; \"hash({\\\"hello\\\": \\\"world\\\"}) = \" &lt;&lt; std::hash&lt;json&gt; {}(\"{\\\"hello\\\": \\\"world\\\"}\"_json)\n              &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>hash(null) = 2654435769\nhash(false) = 2654436030\nhash(0) = 2654436095\nhash(0U) = 2654436156\nhash(\"\") = 6142509191626859748\nhash({}) = 2654435832\nhash([]) = 2654435899\nhash({\"hello\": \"world\"}) = 4469488738203676328\n</code></pre> <p>Note the output is platform-dependent.</p>"},{"location":"api/basic_json/std_hash/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended for arbitrary basic_json types in version 3.10.5.</li> </ul>"},{"location":"api/basic_json/std_swap/","title":"std::swap&lt;basic_json&gt;","text":"<pre><code>namespace std {\n    void swap(nlohmann::basic_json&amp; j1, nlohmann::basic_json&amp; j2);\n}\n</code></pre> <p>Exchanges the values of two JSON objects.</p>"},{"location":"api/basic_json/std_swap/#parameters","title":"Parameters","text":"<code>j1</code> (in, out) value to be replaced by <code>j2</code> <code>j2</code> (in, out) value to be replaced by <code>j1</code>"},{"location":"api/basic_json/std_swap/#possible-implementation","title":"Possible implementation","text":"<pre><code>void swap(nlohmann::basic_json&amp; j1, nlohmann::basic_json&amp; j2)\n{\n    j1.swap(j2);\n}\n</code></pre>"},{"location":"api/basic_json/std_swap/#examples","title":"Examples","text":"Example <p>The following code shows how two values are swapped with <code>std::swap</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j1 = {{\"one\", 1}, {\"two\", 2}};\n    json j2 = {1, 2, 4, 8, 16};\n\n    std::cout &lt;&lt; \"j1 = \" &lt;&lt; j1 &lt;&lt; \" | j2 = \" &lt;&lt; j2 &lt;&lt; '\\n';\n\n    // swap values\n    std::swap(j1, j2);\n\n    std::cout &lt;&lt; \"j1 = \" &lt;&lt; j1 &lt;&lt; \" | j2 = \" &lt;&lt; j2 &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>j1 = {\"one\":1,\"two\":2} | j2 = [1,2,4,8,16]\nj1 = [1,2,4,8,16] | j2 = {\"one\":1,\"two\":2}\n</code></pre>"},{"location":"api/basic_json/std_swap/#see-also","title":"See also","text":"<ul> <li>swap</li> </ul>"},{"location":"api/basic_json/std_swap/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Extended for arbitrary basic_json types in version 3.10.5.</li> </ul>"},{"location":"api/basic_json/string_t/","title":"nlohmann::basic_json::string_t","text":"<pre><code>using string_t = StringType;\n</code></pre> <p>The type used to store JSON strings.</p> <p>RFC 8259 describes JSON strings as follows:</p> <p>A string is a sequence of zero or more Unicode characters.</p> <p>To store objects in C++, a type is defined by the template parameter described below. Unicode values are split by the JSON class into byte-sized characters during deserialization.</p>"},{"location":"api/basic_json/string_t/#template-parameters","title":"Template parameters","text":"<code>StringType</code> the container to store strings (e.g., <code>std::string</code>). Note this container is used for keys/names in objects, see object_t."},{"location":"api/basic_json/string_t/#notes","title":"Notes","text":""},{"location":"api/basic_json/string_t/#default-type","title":"Default type","text":"<p>With the default values for <code>StringType</code> (<code>std::string</code>), the default value for <code>string_t</code> is <code>std::string</code>.</p>"},{"location":"api/basic_json/string_t/#encoding","title":"Encoding","text":"<p>Strings are stored in UTF-8 encoding. Therefore, functions like <code>std::string::size()</code> or <code>std::string::length()</code> return the number of bytes in the string rather than the number of characters or glyphs.</p>"},{"location":"api/basic_json/string_t/#string-comparison","title":"String comparison","text":"<p>RFC 8259 states:</p> <p>Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that <code>\"a\\\\b\"</code> and <code>\"a\\u005Cb\"</code> are not equal.</p> <p>This implementation is interoperable as it does compare strings code unit by code unit.</p>"},{"location":"api/basic_json/string_t/#storage","title":"Storage","text":"<p>String values are stored as pointers in a <code>basic_json</code> type. That is, for any access to string values, a pointer of type <code>string_t*</code> must be dereferenced.</p>"},{"location":"api/basic_json/string_t/#examples","title":"Examples","text":"Example <p>The following code shows that <code>string_t</code> is by default, a typedef to <code>std::string</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;std::string, json::string_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>true\n</code></pre>"},{"location":"api/basic_json/string_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/basic_json/swap/","title":"nlohmann::basic_json::swap","text":"<pre><code>// (1)\nvoid swap(reference other) noexcept;\n\n// (2)\nvoid swap(reference left, reference right) noexcept;\n\n// (3)\nvoid swap(array_t&amp; other);\n\n// (4)\nvoid swap(object_t&amp; other);\n\n// (5)\nvoid swap(string_t&amp; other);\n\n// (6)\nvoid swap(binary_t&amp; other);\n\n// (7)\nvoid swap(typename binary_t::container_type&amp; other);\n</code></pre> <ol> <li>Exchanges the contents of the JSON value with those of <code>other</code>. Does not invoke any move, copy, or swap operations on    individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated. </li> <li>Exchanges the contents of the JSON value from <code>left</code> with those of <code>right</code>. Does not invoke any move, copy, or swap    operations on individual elements. All iterators and references remain valid. The past-the-end iterator is    invalidated. Implemented as a friend function callable via ADL.</li> <li>Exchanges the contents of a JSON array with those of <code>other</code>. Does not invoke any move, copy, or swap operations on    individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated. </li> <li>Exchanges the contents of a JSON object with those of <code>other</code>. Does not invoke any move, copy, or swap operations on    individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</li> <li>Exchanges the contents of a JSON string with those of <code>other</code>. Does not invoke any move, copy, or swap operations on    individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</li> <li>Exchanges the contents of a binary value with those of <code>other</code>. Does not invoke any move, copy, or swap operations on    individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</li> <li>Exchanges the contents of a binary value with those of <code>other</code>. Does not invoke any move, copy, or swap operations on    individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated. Unlike    version (6), no binary subtype is involved.</li> </ol>"},{"location":"api/basic_json/swap/#parameters","title":"Parameters","text":"<code>other</code> (in, out) value to exchange the contents with <code>left</code> (in, out) value to exchange the contents with <code>right</code> (in, out) value to exchange the contents with"},{"location":"api/basic_json/swap/#exceptions","title":"Exceptions","text":"<ol> <li>No-throw guarantee: this function never throws exceptions.</li> <li>No-throw guarantee: this function never throws exceptions.</li> <li>Throws <code>type_error.310</code> if called on JSON values other than    arrays; example: <code>\"cannot use swap() with boolean\"</code></li> <li>Throws <code>type_error.310</code> if called on JSON values other than    objects; example: <code>\"cannot use swap() with boolean\"</code></li> <li>Throws <code>type_error.310</code> if called on JSON values other than    strings; example: <code>\"cannot use swap() with boolean\"</code></li> <li>Throws <code>type_error.310</code> if called on JSON values other than    binaries; example: <code>\"cannot use swap() with boolean\"</code></li> <li>Throws <code>type_error.310</code> if called on JSON values other than    binaries; example: <code>\"cannot use swap() with boolean\"</code></li> </ol>"},{"location":"api/basic_json/swap/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/swap/#examples","title":"Examples","text":"Example: Swap JSON value (1, 2) <p>The example below shows how JSON values can be swapped with <code>swap()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create two JSON values\n    json j1 = {1, 2, 3, 4, 5};\n    json j2 = {{\"pi\", 3.141592653589793}, {\"e\", 2.718281828459045}};\n\n    // swap the values\n    j1.swap(j2);\n\n    // output the values\n    std::cout &lt;&lt; \"j1 = \" &lt;&lt; j1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"j2 = \" &lt;&lt; j2 &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>j1 = {\"e\":2.718281828459045,\"pi\":3.141592653589793}\nj2 = [1,2,3,4,5]\n</code></pre> Example: Swap array (3) <p>The example below shows how arrays can be swapped with <code>swap()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON value\n    json value = {{\"array\", {1, 2, 3, 4}}};\n\n    // create an array_t\n    json::array_t array = {\"Snap\", \"Crackle\", \"Pop\"};\n\n    // swap the array stored in the JSON value\n    value[\"array\"].swap(array);\n\n    // output the values\n    std::cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"array = \" &lt;&lt; array &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>value = {\"array\":[\"Snap\",\"Crackle\",\"Pop\"]}\narray = [1,2,3,4]\n</code></pre> Example: Swap object (4) <p>The example below shows how objects can be swapped with <code>swap()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON value\n    json value = { {\"translation\", {{\"one\", \"eins\"}, {\"two\", \"zwei\"}}} };\n\n    // create an object_t\n    json::object_t object = {{\"cow\", \"Kuh\"}, {\"dog\", \"Hund\"}};\n\n    // swap the object stored in the JSON value\n    value[\"translation\"].swap(object);\n\n    // output the values\n    std::cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"object = \" &lt;&lt; object &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>value = {\"translation\":{\"cow\":\"Kuh\",\"dog\":\"Hund\"}}\nobject = {\"one\":\"eins\",\"two\":\"zwei\"}\n</code></pre> Example: Swap string (5) <p>The example below shows how strings can be swapped with <code>swap()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON value\n    json value = { \"the good\", \"the bad\", \"the ugly\" };\n\n    // create string_t\n    json::string_t string = \"the fast\";\n\n    // swap the object stored in the JSON value\n    value[1].swap(string);\n\n    // output the values\n    std::cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"string = \" &lt;&lt; string &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>value = [\"the good\",\"the fast\",\"the ugly\"]\nstring = the bad\n</code></pre> Example: Swap string (6) <p>The example below shows how binary values can be swapped with <code>swap()</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a binary value\n    json value = json::binary({1, 2, 3});\n\n    // create a binary_t\n    json::binary_t binary = {{4, 5, 6}};\n\n    // swap the object stored in the JSON value\n    value.swap(binary);\n\n    // output the values\n    std::cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"binary = \" &lt;&lt; json(binary) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>value = {\"bytes\":[4,5,6],\"subtype\":null}\nbinary = {\"bytes\":[1,2,3],\"subtype\":null}\n</code></pre>"},{"location":"api/basic_json/swap/#see-also","title":"See also","text":"<ul> <li>std::swap&lt;basic_json&gt;</li> </ul>"},{"location":"api/basic_json/swap/#version-history","title":"Version history","text":"<ol> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 1.0.0.</li> <li>Since version 3.8.0.</li> <li>Since version 3.8.0.</li> </ol>"},{"location":"api/basic_json/to_bjdata/","title":"nlohmann::basic_json::to_bjdata","text":"<pre><code>// (1)\nstatic std::vector&lt;std::uint8_t&gt; to_bjdata(const basic_json&amp; j,\n                                           const bool use_size = false,\n                                           const bool use_type = false,\n                                           const bjdata_version_t version = bjdata_version_t::draft2);\n\n// (2)\nstatic void to_bjdata(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o,\n                      const bool use_size = false, const bool use_type = false,\n                      const bjdata_version_t version = bjdata_version_t::draft2);\nstatic void to_bjdata(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o,\n                      const bool use_size = false, const bool use_type = false,\n                      const bjdata_version_t version = bjdata_version_t::draft2);\n</code></pre> <p>Serializes a given JSON value <code>j</code> to a byte vector using the BJData (Binary JData) serialization format. BJData aims to be more compact than JSON itself, yet more efficient to parse.</p> <ol> <li>Returns a byte vector containing the BJData serialization.</li> <li>Writes the BJData serialization to an output adapter.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/to_bjdata/#parameters","title":"Parameters","text":"<code>j</code> (in) JSON value to serialize <code>o</code> (in) output adapter to write serialization to <code>use_size</code> (in) whether to add size annotations to container types; optional, <code>false</code> by default. <code>use_type</code> (in) whether to add type annotations to container types (must be combined with <code>use_size = true</code>); optional, <code>false</code> by default. <code>version</code> (in) which version of BJData to use (see note on \"Binary values\" on BJData); optional, <code>bjdata_version_t::draft2</code> by default."},{"location":"api/basic_json/to_bjdata/#return-value","title":"Return value","text":"<ol> <li>BJData serialization as byte vector</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/to_bjdata/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/to_bjdata/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value <code>j</code>.</p>"},{"location":"api/basic_json/to_bjdata/#examples","title":"Examples","text":"Example <p>The example shows the serialization of a JSON value to a byte vector in BJData format.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\n// function to print BJData's diagnostic format\nvoid print_byte(uint8_t byte)\n{\n    if (32 &lt; byte and byte &lt; 128)\n    {\n        std::cout &lt;&lt; (char)byte;\n    }\n    else\n    {\n        std::cout &lt;&lt; (int)byte;\n    }\n}\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": false})\"_json;\n\n    // serialize it to BJData\n    std::vector&lt;std::uint8_t&gt; v = json::to_bjdata(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // create an array of numbers\n    json array = {1, 2, 3, 4, 5, 6, 7, 8};\n\n    // serialize it to BJData using default representation\n    std::vector&lt;std::uint8_t&gt; v_array = json::to_bjdata(array);\n    // serialize it to BJData using size optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size = json::to_bjdata(array, true);\n    // serialize it to BJData using type optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size_and_type = json::to_bjdata(array, true, true);\n\n    // print the vector contents\n    for (auto&amp; byte : v_array)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size_and_type)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{i7compactTi6schemaF}\n[i1i2i3i4i5i6i7i8]\n[#i8i1i2i3i4i5i6i7i8\n[$i#i812345678\n</code></pre>"},{"location":"api/basic_json/to_bjdata/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> <li>BJData version parameter (for draft3 binary encoding) added in version 3.12.0.</li> </ul>"},{"location":"api/basic_json/to_bson/","title":"nlohmann::basic_json::to_bson","text":"<pre><code>// (1)\nstatic std::vector&lt;std::uint8_t&gt; to_bson(const basic_json&amp; j);\n\n// (2)\nstatic void to_bson(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o);\nstatic void to_bson(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o);\n</code></pre> <p>BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are stored as a single entity (a so-called document).</p> <ol> <li>Returns a byte vector containing the BSON serialization.</li> <li>Writes the BSON serialization to an output adapter.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/to_bson/#parameters","title":"Parameters","text":"<code>j</code> (in) JSON value to serialize <code>o</code> (in) output adapter to write serialization to"},{"location":"api/basic_json/to_bson/#return-value","title":"Return value","text":"<ol> <li>BSON serialization as a byte vector</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/to_bson/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/to_bson/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value <code>j</code>.</p>"},{"location":"api/basic_json/to_bson/#examples","title":"Examples","text":"Example <p>The example shows the serialization of a JSON value to a byte vector in BSON format.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": 0})\"_json;\n\n    // serialize it to BSON\n    std::vector&lt;std::uint8_t&gt; v = json::to_bson(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        std::cout &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)byte &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>0x1b 0x00 0x00 0x00 0x08 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0x00 0x01 0x10 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 0x00 0x00 0x00 0x00 0x00 \n</code></pre>"},{"location":"api/basic_json/to_bson/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.4.0.</li> </ul>"},{"location":"api/basic_json/to_cbor/","title":"nlohmann::basic_json::to_cbor","text":"<pre><code>// (1)\nstatic std::vector&lt;std::uint8_t&gt; to_cbor(const basic_json&amp; j);\n\n// (2)\nstatic void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o);\nstatic void to_cbor(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o);\n</code></pre> <p>Serializes a given JSON value <code>j</code> to a byte vector using the CBOR (Concise Binary Object Representation) serialization format. CBOR is a binary serialization format that aims to be more compact than JSON itself, yet more efficient to parse.</p> <ol> <li>Returns a byte vector containing the CBOR serialization.</li> <li>Writes the CBOR serialization to an output adapter.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/to_cbor/#parameters","title":"Parameters","text":"<code>j</code> (in) JSON value to serialize <code>o</code> (in) output adapter to write serialization to"},{"location":"api/basic_json/to_cbor/#return-value","title":"Return value","text":"<ol> <li>CBOR serialization as a byte vector</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/to_cbor/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/to_cbor/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value <code>j</code>.</p>"},{"location":"api/basic_json/to_cbor/#examples","title":"Examples","text":"Example <p>The example shows the serialization of a JSON value to a byte vector in CBOR format.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": 0})\"_json;\n\n    // serialize it to CBOR\n    std::vector&lt;std::uint8_t&gt; v = json::to_cbor(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        std::cout &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)byte &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>0xa2 0x67 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xf5 0x66 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 \n</code></pre>"},{"location":"api/basic_json/to_cbor/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.9.</li> <li>Compact representation of floating-point numbers added in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/to_msgpack/","title":"nlohmann::basic_json::to_msgpack","text":"<pre><code>// (1)\nstatic std::vector&lt;std::uint8_t&gt; to_msgpack(const basic_json&amp; j);\n\n// (2)\nstatic void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o);\nstatic void to_msgpack(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o);\n</code></pre> <p>Serializes a given JSON value <code>j</code> to a byte vector using the MessagePack serialization format. MessagePack is a binary serialization format that aims to be more compact than JSON itself, yet more efficient to parse.</p> <ol> <li>Returns a byte vector containing the MessagePack serialization.</li> <li>Writes the MessagePack serialization to an output adapter.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/to_msgpack/#parameters","title":"Parameters","text":"<code>j</code> (in) JSON value to serialize <code>o</code> (in) output adapter to write serialization to"},{"location":"api/basic_json/to_msgpack/#return-value","title":"Return value","text":"<ol> <li>MessagePack serialization as a byte vector</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/to_msgpack/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/to_msgpack/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value <code>j</code>.</p>"},{"location":"api/basic_json/to_msgpack/#examples","title":"Examples","text":"Example <p>The example shows the serialization of a JSON value to a byte vector in MessagePack format.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": 0})\"_json;\n\n    // serialize it to MessagePack\n    std::vector&lt;std::uint8_t&gt; v = json::to_msgpack(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        std::cout &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)byte &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>0x82 0xa7 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xc3 0xa6 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 \n</code></pre>"},{"location":"api/basic_json/to_msgpack/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.9.</li> </ul>"},{"location":"api/basic_json/to_string/","title":"to_string(basic_json)","text":"<pre><code>template &lt;typename BasicJsonType&gt;\nstd::string to_string(const BasicJsonType&amp; j);\n</code></pre> <p>This function implements a user-defined to_string for JSON objects.</p>"},{"location":"api/basic_json/to_string/#template-parameters","title":"Template parameters","text":"<code>BasicJsonType</code> a specialization of <code>basic_json</code>"},{"location":"api/basic_json/to_string/#return-value","title":"Return value","text":"<p>string containing the serialization of the JSON value</p>"},{"location":"api/basic_json/to_string/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</p>"},{"location":"api/basic_json/to_string/#exceptions","title":"Exceptions","text":"<p>Throws <code>type_error.316</code> if a string stored inside the JSON value is not UTF-8 encoded</p>"},{"location":"api/basic_json/to_string/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/to_string/#possible-implementation","title":"Possible implementation","text":"<pre><code>template &lt;typename BasicJsonType&gt;\nstd::string to_string(const BasicJsonType&amp; j)\n{\n    return j.dump();\n}\n</code></pre>"},{"location":"api/basic_json/to_string/#examples","title":"Examples","text":"Example <p>The following code shows how the library's <code>to_string()</code> function integrates with others, allowing argument-dependent lookup.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing std::to_string;\n\nint main()\n{\n    // create values\n    json j = {{\"one\", 1}, {\"two\", 2}};\n    int i = 42;\n\n    // use ADL to select best to_string function\n    auto j_str = to_string(j);  // calling nlohmann::to_string\n    auto i_str = to_string(i);  // calling std::to_string\n\n    // serialize without indentation\n    std::cout &lt;&lt; j_str &lt;&lt; \"\\n\\n\"\n              &lt;&lt; i_str &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\"one\":1,\"two\":2}\n\n42\n</code></pre>"},{"location":"api/basic_json/to_string/#see-also","title":"See also","text":"<ul> <li>dump</li> </ul>"},{"location":"api/basic_json/to_string/#version-history","title":"Version history","text":"<p>Added in version 3.7.0.</p>"},{"location":"api/basic_json/to_ubjson/","title":"nlohmann::basic_json::to_ubjson","text":"<pre><code>// (1)\nstatic std::vector&lt;std::uint8_t&gt; to_ubjson(const basic_json&amp; j,\n                                           const bool use_size = false,\n                                           const bool use_type = false);\n\n// (2)\nstatic void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;std::uint8_t&gt; o,\n                      const bool use_size = false, const bool use_type = false);\nstatic void to_ubjson(const basic_json&amp; j, detail::output_adapter&lt;char&gt; o,\n                      const bool use_size = false, const bool use_type = false);\n</code></pre> <p>Serializes a given JSON value <code>j</code> to a byte vector using the UBJSON (Universal Binary JSON) serialization format. UBJSON aims to be more compact than JSON itself, yet more efficient to parse.</p> <ol> <li>Returns a byte vector containing the UBJSON serialization.</li> <li>Writes the UBJSON serialization to an output adapter.</li> </ol> <p>The exact mapping and its limitations are described on a dedicated page.</p>"},{"location":"api/basic_json/to_ubjson/#parameters","title":"Parameters","text":"<code>j</code> (in) JSON value to serialize <code>o</code> (in) output adapter to write serialization to <code>use_size</code> (in) whether to add size annotations to container types; optional, <code>false</code> by default. <code>use_type</code> (in) whether to add type annotations to container types (must be combined with <code>use_size = true</code>); optional, <code>false</code> by default."},{"location":"api/basic_json/to_ubjson/#return-value","title":"Return value","text":"<ol> <li>UBJSON serialization as a byte vector</li> <li>(none)</li> </ol>"},{"location":"api/basic_json/to_ubjson/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes in the JSON value.</p>"},{"location":"api/basic_json/to_ubjson/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value <code>j</code>.</p>"},{"location":"api/basic_json/to_ubjson/#examples","title":"Examples","text":"Example <p>The example shows the serialization of a JSON value to a byte vector in UBJSON format.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\n// function to print UBJSON's diagnostic format\nvoid print_byte(uint8_t byte)\n{\n    if (32 &lt; byte and byte &lt; 128)\n    {\n        std::cout &lt;&lt; (char)byte;\n    }\n    else\n    {\n        std::cout &lt;&lt; (int)byte;\n    }\n}\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": false})\"_json;\n\n    // serialize it to UBJSON\n    std::vector&lt;std::uint8_t&gt; v = json::to_ubjson(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // create an array of numbers\n    json array = {1, 2, 3, 4, 5, 6, 7, 8};\n\n    // serialize it to UBJSON using default representation\n    std::vector&lt;std::uint8_t&gt; v_array = json::to_ubjson(array);\n    // serialize it to UBJSON using size optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size = json::to_ubjson(array, true);\n    // serialize it to UBJSON using type optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size_and_type = json::to_ubjson(array, true, true);\n\n    // print the vector contents\n    for (auto&amp; byte : v_array)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size_and_type)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{i7compactTi6schemaF}\n[i1i2i3i4i5i6i7i8]\n[#i8i1i2i3i4i5i6i7i8\n[$i#i812345678\n</code></pre>"},{"location":"api/basic_json/to_ubjson/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.1.0.</li> </ul>"},{"location":"api/basic_json/type/","title":"nlohmann::basic_json::type","text":"<pre><code>constexpr value_t type() const noexcept;\n</code></pre> <p>Return the type of the JSON value as a value from the <code>value_t</code> enumeration.</p>"},{"location":"api/basic_json/type/#return-value","title":"Return value","text":"<p>the type of the JSON value</p> Value type return value <code>null</code> <code>value_t::null</code> boolean <code>value_t::boolean</code> string <code>value_t::string</code> number (integer) <code>value_t::number_integer</code> number (unsigned integer) <code>value_t::number_unsigned</code> number (floating-point) <code>value_t::number_float</code> object <code>value_t::object</code> array <code>value_t::array</code> binary <code>value_t::binary</code> discarded <code>value_t::discarded</code>"},{"location":"api/basic_json/type/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/type/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/type/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>type()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = -17;\n    json j_number_unsigned = 42u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call type()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; (j_null.type() == json::value_t::null) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_boolean.type() == json::value_t::boolean) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_number_integer.type() == json::value_t::number_integer) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_number_unsigned.type() == json::value_t::number_unsigned) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_number_float.type() == json::value_t::number_float) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_object.type() == json::value_t::object) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_array.type() == json::value_t::array) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_string.type() == json::value_t::string) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n</code></pre>"},{"location":"api/basic_json/type/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Added unsigned integer type in version 2.0.0.</li> <li>Added binary type in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/type_error/","title":"nlohmann::basic_json::type_error","text":"<pre><code>class type_error : public exception;\n</code></pre> <p>This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics.</p> <p>Exceptions have ids 3xx (see list of type errors).</p> <pre><code>classDiagram\n  direction LR\n\n    class std_exception [\"std::exception\"] {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class json_exception [\"basic_json::exception\"] {\n        +const int id\n        +const char* what() const\n    }\n\n    class json_parse_error [\"basic_json::parse_error\"] {\n        +const std::size_t byte\n    }\n\n    class json_invalid_iterator [\"basic_json::invalid_iterator\"]\n    class json_type_error [\"basic_json::type_error\"]\n    class json_out_of_range [\"basic_json::out_of_range\"]\n    class json_other_error [\"basic_json::other_error\"]\n\n    std_exception &lt;|-- json_exception\n    json_exception &lt;|-- json_parse_error\n    json_exception &lt;|-- json_invalid_iterator\n    json_exception &lt;|-- json_type_error\n    json_exception &lt;|-- json_out_of_range\n    json_exception &lt;|-- json_other_error\n\n    style json_type_error fill:#CCCCFF</code></pre>"},{"location":"api/basic_json/type_error/#member-functions","title":"Member functions","text":"<ul> <li>what - returns explanatory string</li> </ul>"},{"location":"api/basic_json/type_error/#member-variables","title":"Member variables","text":"<ul> <li>id - the id of the exception</li> </ul>"},{"location":"api/basic_json/type_error/#examples","title":"Examples","text":"Example <p>The following code shows how a <code>type_error</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // calling push_back() on a string value\n        json j = \"string\";\n        j.push_back(\"another string\");\n    }\n    catch (const json::type_error&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.type_error.308] cannot use push_back() with string\nexception id: 308\n</code></pre>"},{"location":"api/basic_json/type_error/#see-also","title":"See also","text":"<ul> <li>List of type errors</li> <li><code>parse_error</code> for exceptions indicating a parse error</li> <li><code>invalid_iterator</code> for exceptions indicating errors with iterators</li> <li><code>out_of_range</code> for exceptions indicating access out of the defined range</li> <li><code>other_error</code> for exceptions indicating other library errors</li> </ul>"},{"location":"api/basic_json/type_error/#version-history","title":"Version history","text":"<ul> <li>Since version 3.0.0.</li> </ul>"},{"location":"api/basic_json/type_name/","title":"nlohmann::basic_json::type_name","text":"<pre><code>const char* type_name() const noexcept;\n</code></pre> <p>Returns the type name as string to be used in error messages -- usually to indicate that a function was called on a wrong JSON type.</p>"},{"location":"api/basic_json/type_name/#return-value","title":"Return value","text":"<p>a string representation of the type (<code>value_t</code>):</p> Value type return value <code>null</code> <code>\"null\"</code> boolean <code>\"boolean\"</code> string <code>\"string\"</code> number (integer, unsigned integer, floating-point) <code>\"number\"</code> object <code>\"object\"</code> array <code>\"array\"</code> binary <code>\"binary\"</code> discarded <code>\"discarded\"</code>"},{"location":"api/basic_json/type_name/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/type_name/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/basic_json/type_name/#examples","title":"Examples","text":"Example <p>The following code exemplifies <code>type_name()</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = -17;\n    json j_number_unsigned = 42u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call type_name()\n    std::cout &lt;&lt; j_null &lt;&lt; \" is a \" &lt;&lt; j_null.type_name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_boolean &lt;&lt; \" is a \" &lt;&lt; j_boolean.type_name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_integer &lt;&lt; \" is a \" &lt;&lt; j_number_integer.type_name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_unsigned &lt;&lt; \" is a \" &lt;&lt; j_number_unsigned.type_name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_number_float &lt;&lt; \" is a \" &lt;&lt; j_number_float.type_name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_object &lt;&lt; \" is an \" &lt;&lt; j_object.type_name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_array &lt;&lt; \" is an \" &lt;&lt; j_array.type_name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; j_string &lt;&lt; \" is a \" &lt;&lt; j_string.type_name() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>null is a null\ntrue is a boolean\n-17 is a number\n42 is a number\n23.42 is a number\n{\"one\":1,\"two\":2} is an object\n[1,2,4,8,16] is an array\n\"Hello, world\" is a string\n</code></pre>"},{"location":"api/basic_json/type_name/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Part of the public API version since 2.1.0.</li> <li>Changed return value to <code>const char*</code> and added <code>noexcept</code> in version 3.0.0.</li> <li>Added support for binary type in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/unflatten/","title":"nlohmann::basic_json::unflatten","text":"<pre><code>basic_json unflatten() const;\n</code></pre> <p>The function restores the arbitrary nesting of a JSON value that has been flattened before using the <code>flatten()</code> function. The JSON value must meet certain constraints:</p> <ol> <li>The value must be an object.</li> <li>The keys must be JSON pointers (see RFC 6901)</li> <li>The mapped values must be primitive JSON types.</li> </ol>"},{"location":"api/basic_json/unflatten/#return-value","title":"Return value","text":"<p>the original JSON from a flattened version</p>"},{"location":"api/basic_json/unflatten/#exception-safety","title":"Exception safety","text":"<p>Strong exception safety: if an exception occurs, the original value stays intact.</p>"},{"location":"api/basic_json/unflatten/#exceptions","title":"Exceptions","text":"<p>The function can throw the following exceptions:</p> <ul> <li>Throws <code>type_error.314</code> if value is not an object</li> <li>Throws <code>type_error.315</code> if object values are not primitive</li> </ul>"},{"location":"api/basic_json/unflatten/#complexity","title":"Complexity","text":"<p>Linear in the size of the JSON value.</p>"},{"location":"api/basic_json/unflatten/#notes","title":"Notes","text":"<p>Empty objects and arrays are flattened by <code>flatten()</code> to <code>null</code> values and cannot unflattened to their original type. Apart from this example, for a JSON value <code>j</code>, the following is always true: <code>j == j.flatten().unflatten()</code>.</p>"},{"location":"api/basic_json/unflatten/#examples","title":"Examples","text":"Example <p>The following code shows how a flattened JSON object is unflattened into the original nested JSON object.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON value\n    json j_flattened =\n    {\n        {\"/answer/everything\", 42},\n        {\"/happy\", true},\n        {\"/list/0\", 1},\n        {\"/list/1\", 0},\n        {\"/list/2\", 2},\n        {\"/name\", \"Niels\"},\n        {\"/nothing\", nullptr},\n        {\"/object/currency\", \"USD\"},\n        {\"/object/value\", 42.99},\n        {\"/pi\", 3.141}\n    };\n\n    // call unflatten()\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_flattened.unflatten() &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"answer\": {\n        \"everything\": 42\n    },\n    \"happy\": true,\n    \"list\": [\n        1,\n        0,\n        2\n    ],\n    \"name\": \"Niels\",\n    \"nothing\": null,\n    \"object\": {\n        \"currency\": \"USD\",\n        \"value\": 42.99\n    },\n    \"pi\": 3.141\n}\n</code></pre>"},{"location":"api/basic_json/unflatten/#see-also","title":"See also","text":"<ul> <li>flatten the reverse function</li> </ul>"},{"location":"api/basic_json/unflatten/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> </ul>"},{"location":"api/basic_json/update/","title":"nlohmann::basic_json::update","text":"<pre><code>// (1)\nvoid update(const_reference j, bool merge_objects = false);\n\n// (2)\nvoid update(const_iterator first, const_iterator last, bool merge_objects = false);\n</code></pre> <ol> <li>Inserts all values from JSON object <code>j</code>.</li> <li>Inserts all values from range <code>[first, last)</code></li> </ol> <p>When <code>merge_objects</code> is <code>false</code> (default), existing keys are overwritten. When <code>merge_objects</code> is <code>true</code>, recursively merges objects with common keys.</p> <p>The function is motivated by Python's dict.update function.</p>"},{"location":"api/basic_json/update/#iterator-invalidation","title":"Iterator invalidation","text":"<p>For <code>ordered_json</code>, adding a value to an object can yield a reallocation, in which case all iterators (including the <code>end()</code> iterator) and all references to the elements are invalidated.</p>"},{"location":"api/basic_json/update/#parameters","title":"Parameters","text":"<code>j</code> (in) JSON object to read values from <code>merge_objects</code> (in) when <code>true</code>, existing keys are not overwritten, but contents of objects are merged recursively (default: <code>false</code>) <code>first</code> (in) the beginning of the range of elements to insert <code>last</code> (in) the end of the range of elements to insert"},{"location":"api/basic_json/update/#exceptions","title":"Exceptions","text":"<ol> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.312</code> if called on JSON values other than   objects; example: <code>\"cannot use update() with string\"</code></li> </ul> </li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.312</code> if called on JSON values other than   objects; example: <code>\"cannot use update() with string\"</code></li> <li>Throws <code>invalid_iterator.202</code> if called on an   iterator which does not belong to the current JSON value; example: <code>\"iterator does not fit current value\"</code></li> <li>Throws <code>invalid_iterator.210</code> if <code>first</code> and <code>last</code>   do not belong to the same JSON value; example: <code>\"iterators do not fit\"</code></li> </ul> </li> </ol>"},{"location":"api/basic_json/update/#complexity","title":"Complexity","text":"<ol> <li>O(N*log(size() + N)), where N is the number of elements to insert.</li> <li>O(N*log(size() + N)), where N is the number of elements to insert.</li> </ol>"},{"location":"api/basic_json/update/#examples","title":"Examples","text":"Example <p>The example shows how <code>update()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create two JSON objects\n    json o1 = R\"( {\"color\": \"red\", \"price\": 17.99, \"names\": {\"de\": \"Flugzeug\"}} )\"_json;\n    json o2 = R\"( {\"color\": \"blue\", \"speed\": 100, \"names\": {\"en\": \"plane\"}} )\"_json;\n    json o3 = o1;\n\n    // add all keys from o2 to o1 (updating \"color\", replacing \"names\")\n    o1.update(o2);\n\n    // add all keys from o2 to o1 (updating \"color\", merging \"names\")\n    o3.update(o2, true);\n\n    // output updated object o1 and o3\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; o1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; o3 &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"color\": \"blue\",\n  \"names\": {\n    \"en\": \"plane\"\n  },\n  \"price\": 17.99,\n  \"speed\": 100\n}\n{\n  \"color\": \"blue\",\n  \"names\": {\n    \"de\": \"Flugzeug\",\n    \"en\": \"plane\"\n  },\n  \"price\": 17.99,\n  \"speed\": 100\n}\n</code></pre> Example <p>The example shows how <code>update()</code> is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create two JSON objects\n    json o1 = R\"( {\"color\": \"red\", \"price\": 17.99, \"names\": {\"de\": \"Flugzeug\"}} )\"_json;\n    json o2 = R\"( {\"color\": \"blue\", \"speed\": 100, \"names\": {\"en\": \"plane\"}} )\"_json;\n    json o3 = o1;\n\n    // add all keys from o2 to o1 (updating \"color\", replacing \"names\")\n    o1.update(o2.begin(), o2.end());\n\n    // add all keys from o2 to o1 (updating \"color\", merging \"names\")\n    o3.update(o2.begin(), o2.end(), true);\n\n    // output updated object o1 and o3\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; o1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; o3 &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"color\": \"blue\",\n  \"names\": {\n    \"en\": \"plane\"\n  },\n  \"price\": 17.99,\n  \"speed\": 100\n}\n{\n  \"color\": \"blue\",\n  \"names\": {\n    \"de\": \"Flugzeug\",\n    \"en\": \"plane\"\n  },\n  \"price\": 17.99,\n  \"speed\": 100\n}\n</code></pre> Example <p>One common use case for this function is the handling of user settings. Assume your application can be configured in some aspects:</p> <pre><code>{\n    \"color\": \"red\",\n    \"active\": true,\n    \"name\": {\"de\": \"Maus\", \"en\": \"mouse\"}\n}\n</code></pre> <p>The user may override the default settings selectively:</p> <pre><code>{\n    \"color\": \"blue\",\n    \"name\": {\"es\": \"rat\u00f3n\"},\n}\n</code></pre> <p>Then <code>update</code> manages the merging of default settings and user settings:</p> <pre><code>auto user_settings = json::parse(\"config.json\");\nauto effective_settings = get_default_settings();\neffective_settings.update(user_settings);\n</code></pre> <p>Now <code>effective_settings</code> contains the default settings, but those keys set by the user are overwritten:</p> <pre><code>{\n    \"color\": \"blue\",\n    \"active\": true,\n    \"name\": {\"es\": \"rat\u00f3n\"}\n}\n</code></pre> <p>Note existing keys were just overwritten. To merge objects, <code>merge_objects</code> setting should be set to <code>true</code>:</p> <pre><code>auto user_settings = json::parse(\"config.json\");\nauto effective_settings = get_default_settings();\neffective_settings.update(user_settings, true);\n</code></pre> <pre><code>{\n    \"color\": \"blue\",\n    \"active\": true,\n    \"name\": {\"de\": \"Maus\", \"en\": \"mouse\", \"es\": \"rat\u00f3n\"}\n}\n</code></pre>"},{"location":"api/basic_json/update/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.0.0.</li> <li>Added <code>merge_objects</code> parameter in 3.10.5.</li> </ul>"},{"location":"api/basic_json/value/","title":"nlohmann::basic_json::value","text":"<pre><code>// (1)\ntemplate&lt;class ValueType&gt;\nValueType value(const typename object_t::key_type&amp; key,\n                ValueType&amp;&amp; default_value) const;\n\n// (2)\ntemplate&lt;class ValueType, class KeyType&gt;\nValueType value(KeyType&amp;&amp; key,\n                ValueType&amp;&amp; default_value) const;\n\n// (3)\ntemplate&lt;class ValueType&gt;\nValueType value(const json_pointer&amp; ptr,\n                const ValueType&amp; default_value) const;\n</code></pre> <ol> <li> <p>Returns either a copy of an object's element at the specified key <code>key</code> or a given default value if no element with    key <code>key</code> exists.</p> <p>The function is basically equivalent to executing <pre><code>try {\n   return at(key);\n} catch(out_of_range) {\n   return default_value;\n}\n</code></pre></p> </li> <li> <p>See 1. This overload is only available if <code>KeyType</code> is comparable with <code>typename object_t::key_type</code> and    <code>typename object_comparator_t::is_transparent</code> denotes a type.</p> </li> <li> <p>Returns either a copy of an object's element at the specified JSON pointer <code>ptr</code> or a given default value if no value    at <code>ptr</code> exists.</p> <p>The function is basically equivalent to executing <pre><code>try {\n   return at(ptr);\n} catch(out_of_range) {\n   return default_value;\n}\n</code></pre></p> </li> </ol> <p>Differences to <code>at</code> and <code>operator[]</code></p> <ul> <li>Unlike <code>at</code>, this function does not throw if the given <code>key</code>/<code>ptr</code> was not found.</li> <li>Unlike <code>operator[]</code>, this function does not implicitly add an element to the position defined by  <code>key</code>/<code>ptr</code> key. This function is furthermore also applicable to const objects.</li> </ul>"},{"location":"api/basic_json/value/#template-parameters","title":"Template parameters","text":"<code>KeyType</code> A type for an object key other than <code>json_pointer</code> that is comparable with <code>string_t</code> using  <code>object_comparator_t</code>. This can also be a string view (C++17). <code>ValueType</code> type compatible to JSON values, for instance <code>int</code> for JSON integer numbers, <code>bool</code> for JSON booleans, or <code>std::vector</code> types for JSON arrays. Note the type of the expected value at <code>key</code>/<code>ptr</code> and the default value <code>default_value</code> must be compatible."},{"location":"api/basic_json/value/#parameters","title":"Parameters","text":"<code>key</code> (in) key of the element to access <code>default_value</code> (in) the value to return if <code>key</code>/<code>ptr</code> found no value <code>ptr</code> (in) a JSON pointer to the element to access"},{"location":"api/basic_json/value/#return-value","title":"Return value","text":"<ol> <li>copy of the element at key <code>key</code> or <code>default_value</code> if <code>key</code> is not found</li> <li>copy of the element at key <code>key</code> or <code>default_value</code> if <code>key</code> is not found</li> <li>copy of the element at JSON Pointer <code>ptr</code> or <code>default_value</code> if no value for <code>ptr</code> is found</li> </ol>"},{"location":"api/basic_json/value/#exception-safety","title":"Exception safety","text":"<p>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</p>"},{"location":"api/basic_json/value/#exceptions","title":"Exceptions","text":"<ol> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.302</code> if <code>default_value</code> does not match   the type of the value at <code>key</code></li> <li>Throws <code>type_error.306</code> if the JSON value is not an object;   in that case, using <code>value()</code> with a key makes no sense.</li> </ul> </li> <li>See 1.</li> <li>The function can throw the following exceptions:<ul> <li>Throws <code>type_error.302</code> if <code>default_value</code> does not match   the type of the value at <code>ptr</code></li> <li>Throws <code>type_error.306</code> if the JSON value is not an object;   in that case, using <code>value()</code> with a key makes no sense.</li> </ul> </li> </ol>"},{"location":"api/basic_json/value/#complexity","title":"Complexity","text":"<ol> <li>Logarithmic in the size of the container.</li> <li>Logarithmic in the size of the container.</li> <li>Logarithmic in the size of the container.</li> </ol>"},{"location":"api/basic_json/value/#notes","title":"Notes","text":"<p>Return type</p> <p>The value function is a template, and the return type of the function is determined by the type of the provided default value unless otherwise specified. This can have unexpected effects. In the example below, we store a 64-bit unsigned integer. We get exactly that value when using <code>operator[]</code>. However, when we call <code>value</code> and provide <code>0</code> as default value, then <code>-1</code> is returned. The occurs, because <code>0</code> has type <code>int</code> which overflows when handling the value <code>18446744073709551615</code>.</p> <p>To address this issue, either provide a correctly typed default value or use the template parameter to specify the desired return type. Note that this issue occurs even when a value is stored at the provided key, and the default value is not used as the return value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j = json::parse(R\"({\"uint64\": 18446744073709551615})\");\n\n    std::cout &lt;&lt; \"operator[]:                \" &lt;&lt; j[\"uint64\"] &lt;&lt; '\\n'\n              &lt;&lt; \"default value (int):       \" &lt;&lt; j.value(\"uint64\", 0) &lt;&lt; '\\n'\n              &lt;&lt; \"default value (uint64_t):  \" &lt;&lt; j.value(\"uint64\", std::uint64_t(0)) &lt;&lt; '\\n'\n              &lt;&lt; \"explicit return value type: \" &lt;&lt; j.value&lt;std::uint64_t&gt;(\"uint64\", 0) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>operator[]:                18446744073709551615\ndefault value (int):       -1\ndefault value (uint64_t):  18446744073709551615\nexplicit return value type: 18446744073709551615\n</code></pre>"},{"location":"api/basic_json/value/#examples","title":"Examples","text":"Example: (1) access specified object element with default value <p>The example below shows how object elements can be queried with a default value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object with different entry types\n    json j =\n    {\n        {\"integer\", 1},\n        {\"floating\", 42.23},\n        {\"string\", \"hello world\"},\n        {\"boolean\", true},\n        {\"object\", {{\"key1\", 1}, {\"key2\", 2}}},\n        {\"array\", {1, 2, 3}}\n    };\n\n    // access existing values\n    int v_integer = j.value(\"integer\", 0);\n    double v_floating = j.value(\"floating\", 47.11);\n\n    // access nonexisting values and rely on default value\n    std::string v_string = j.value(\"nonexisting\", \"oops\");\n    bool v_boolean = j.value(\"nonexisting\", false);\n\n    // output values\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; v_integer &lt;&lt; \" \" &lt;&lt; v_floating\n              &lt;&lt; \" \" &lt;&lt; v_string &lt;&lt; \" \" &lt;&lt; v_boolean &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>1 42.23 oops false\n</code></pre> Example: (2) access specified object element using string_view with default value <p>The example below shows how object elements can be queried with a default value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string_view&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing namespace std::string_view_literals;\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON object with different entry types\n    json j =\n    {\n        {\"integer\", 1},\n        {\"floating\", 42.23},\n        {\"string\", \"hello world\"},\n        {\"boolean\", true},\n        {\"object\", {{\"key1\", 1}, {\"key2\", 2}}},\n        {\"array\", {1, 2, 3}}\n    };\n\n    // access existing values\n    int v_integer = j.value(\"integer\"sv, 0);\n    double v_floating = j.value(\"floating\"sv, 47.11);\n\n    // access nonexisting values and rely on default value\n    std::string v_string = j.value(\"nonexisting\"sv, \"oops\");\n    bool v_boolean = j.value(\"nonexisting\"sv, false);\n\n    // output values\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; v_integer &lt;&lt; \" \" &lt;&lt; v_floating\n              &lt;&lt; \" \" &lt;&lt; v_string &lt;&lt; \" \" &lt;&lt; v_boolean &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>1 42.23 oops false\n</code></pre> Example: (3) access specified object element via JSON Pointer with default value <p>The example below shows how object elements can be queried with a default value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON object with different entry types\n    json j =\n    {\n        {\"integer\", 1},\n        {\"floating\", 42.23},\n        {\"string\", \"hello world\"},\n        {\"boolean\", true},\n        {\"object\", {{\"key1\", 1}, {\"key2\", 2}}},\n        {\"array\", {1, 2, 3}}\n    };\n\n    // access existing values\n    int v_integer = j.value(\"/integer\"_json_pointer, 0);\n    double v_floating = j.value(\"/floating\"_json_pointer, 47.11);\n\n    // access nonexisting values and rely on default value\n    std::string v_string = j.value(\"/nonexisting\"_json_pointer, \"oops\");\n    bool v_boolean = j.value(\"/nonexisting\"_json_pointer, false);\n\n    // output values\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; v_integer &lt;&lt; \" \" &lt;&lt; v_floating\n              &lt;&lt; \" \" &lt;&lt; v_string &lt;&lt; \" \" &lt;&lt; v_boolean &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>1 42.23 oops false\n</code></pre>"},{"location":"api/basic_json/value/#see-also","title":"See also","text":"<ul> <li>see <code>at</code> for access by reference with range checking</li> <li>see <code>operator[]</code> for unchecked access by reference</li> </ul>"},{"location":"api/basic_json/value/#version-history","title":"Version history","text":"<ol> <li>Added in version 1.0.0. Changed parameter <code>default_value</code> type from <code>const ValueType&amp;</code> to <code>ValueType&amp;&amp;</code> in version 3.11.0.</li> <li>Added in version 3.11.0. Made <code>ValueType</code> the first template parameter in version 3.11.2.</li> <li>Added in version 2.0.2.</li> </ol>"},{"location":"api/basic_json/value_t/","title":"nlohmann::basic_json::value_t","text":"<pre><code>enum class value_t : std::uint8_t {\n    null,\n    object,\n    array,\n    string,\n    boolean,\n    number_integer,\n    number_unsigned,\n    number_float,\n    binary,\n    discarded\n};\n</code></pre> <p>This enumeration collects the different JSON types. It is internally used to distinguish the stored values, and the functions <code>is_null</code>, <code>is_object</code>, <code>is_array</code>, <code>is_string</code>, <code>is_boolean</code>, <code>is_number</code> (with <code>is_number_integer</code>, <code>is_number_unsigned</code>, and <code>is_number_float</code>), <code>is_discarded</code>, <code>is_binary</code>, <code>is_primitive</code>, and <code>is_structured</code> rely on it.</p>"},{"location":"api/basic_json/value_t/#notes","title":"Notes","text":"<p>Ordering</p> <p>The order of types is as follows:</p> <ol> <li><code>null</code></li> <li><code>boolean</code></li> <li><code>number_integer</code>, <code>number_unsigned</code>, <code>number_float</code></li> <li><code>object</code></li> <li><code>array</code></li> <li><code>string</code></li> <li><code>binary</code></li> </ol> <p><code>discarded</code> is unordered.</p> <p>Types of numbers</p> <p>There are three enumerators for numbers (<code>number_integer</code>, <code>number_unsigned</code>, and <code>number_float</code>) to distinguish between different types of numbers:</p> <ul> <li><code>number_unsigned_t</code> for unsigned integers</li> <li><code>number_integer_t</code> for signed integers</li> <li><code>number_float_t</code> for floating-point numbers or to approximate integers which do not fit     into the limits of their respective type</li> </ul> <p>Comparison operators</p> <p><code>operator&lt;</code> and <code>operator&lt;=&gt;</code> (since C++20) are overloaded and compare according to the ordering described above. Until C++20 all other relational and equality operators yield results according to the integer value of each enumerator. Since C++20 some compilers consider the rewritten candidates generated from <code>operator&lt;=&gt;</code> during overload resolution, while others do not. For predictable and portable behavior use:</p> <ul> <li><code>operator&lt;</code> or <code>operator&lt;=&gt;</code> when wanting to compare according to the order described above</li> <li><code>operator==</code> or <code>operator!=</code> when wanting to compare according to each enumerators integer value</li> </ul>"},{"location":"api/basic_json/value_t/#examples","title":"Examples","text":"Example <p>The following code how <code>type()</code> queries the <code>value_t</code> for all JSON types.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create JSON values\n    json j_null;\n    json j_boolean = true;\n    json j_number_integer = -17;\n    json j_number_unsigned = 42u;\n    json j_number_float = 23.42;\n    json j_object = {{\"one\", 1}, {\"two\", 2}};\n    json j_array = {1, 2, 4, 8, 16};\n    json j_string = \"Hello, world\";\n\n    // call type()\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; (j_null.type() == json::value_t::null) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_boolean.type() == json::value_t::boolean) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_number_integer.type() == json::value_t::number_integer) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_number_unsigned.type() == json::value_t::number_unsigned) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_number_float.type() == json::value_t::number_float) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_object.type() == json::value_t::object) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_array.type() == json::value_t::array) &lt;&lt; '\\n';\n    std::cout &lt;&lt; (j_string.type() == json::value_t::string) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\n</code></pre>"},{"location":"api/basic_json/value_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> <li>Added unsigned integer type in version 2.0.0.</li> <li>Added binary type in version 3.8.0.</li> </ul>"},{"location":"api/basic_json/~basic_json/","title":"nlohmann::basic_json::~basic_json","text":"<pre><code>~basic_json() noexcept;\n</code></pre> <p>Destroys the JSON value and frees all allocated memory.</p>"},{"location":"api/basic_json/~basic_json/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this member function never throws exceptions.</p>"},{"location":"api/basic_json/~basic_json/#complexity","title":"Complexity","text":"<p>Linear.</p>"},{"location":"api/basic_json/~basic_json/#version-history","title":"Version history","text":"<ul> <li>Added in version 1.0.0.</li> </ul>"},{"location":"api/byte_container_with_subtype/","title":"nlohmann::byte_container_with_subtype","text":"<pre><code>template&lt;typename BinaryType&gt;\nclass byte_container_with_subtype : public BinaryType;\n</code></pre> <p>This type extends the template parameter <code>BinaryType</code> provided to <code>basic_json</code> with a subtype used by BSON and MessagePack. This type exists so that the user does not have to specify a type themselves with a specific naming scheme in order to override the binary type.</p>"},{"location":"api/byte_container_with_subtype/#template-parameters","title":"Template parameters","text":"<code>BinaryType</code> container to store bytes (<code>std::vector&lt;std::uint8_t&gt;</code> by default)"},{"location":"api/byte_container_with_subtype/#member-types","title":"Member types","text":"<ul> <li>container_type - the type of the underlying container (<code>BinaryType</code>)</li> <li>subtype_type - the type of the subtype (<code>std::uint64_t</code>)</li> </ul>"},{"location":"api/byte_container_with_subtype/#member-functions","title":"Member functions","text":"<ul> <li>(constructor)</li> <li>operator== - comparison: equal</li> <li>operator!= - comparison: not equal</li> <li>set_subtype - sets the binary subtype</li> <li>subtype - return the binary subtype</li> <li>has_subtype - return whether the value has a subtype</li> <li>clear_subtype - clears the binary subtype</li> </ul>"},{"location":"api/byte_container_with_subtype/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.8.0.</li> <li>Changed the type of subtypes to <code>std::uint64_t</code> in 3.10.0.</li> </ul>"},{"location":"api/byte_container_with_subtype/byte_container_with_subtype/","title":"nlohmann::byte_container_with_subtype::byte_container_with_subtype","text":"<pre><code>// (1)\nbyte_container_with_subtype();\n\n// (2)\nbyte_container_with_subtype(const container_type&amp; container);\nbyte_container_with_subtype(container_type&amp;&amp; container);\n\n// (3)\nbyte_container_with_subtype(const container_type&amp; container, subtype_type subtype);\nbyte_container_with_subtype(container_type&amp;&amp; container, subtype_type subtype);\n</code></pre> <ol> <li>Create an empty binary container without a subtype.</li> <li>Create a binary container without a subtype.</li> <li>Create a binary container with a subtype.</li> </ol>"},{"location":"api/byte_container_with_subtype/byte_container_with_subtype/#parameters","title":"Parameters","text":"<code>container</code> (in) binary container <code>subtype</code> (in) subtype"},{"location":"api/byte_container_with_subtype/byte_container_with_subtype/#examples","title":"Examples","text":"Example <p>The example below demonstrates how byte containers can be created.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// define a byte container based on std::vector\nusing byte_container_with_subtype = nlohmann::byte_container_with_subtype&lt;std::vector&lt;std::uint8_t&gt;&gt;;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // (1) create empty container\n    auto c1 = byte_container_with_subtype();\n\n    std::vector&lt;std::uint8_t&gt; bytes = {{0xca, 0xfe, 0xba, 0xbe}};\n\n    // (2) create container\n    auto c2 = byte_container_with_subtype(bytes);\n\n    // (3) create container with subtype\n    auto c3 = byte_container_with_subtype(bytes, 42);\n\n    std::cout &lt;&lt; json(c1) &lt;&lt; \"\\n\" &lt;&lt; json(c2) &lt;&lt; \"\\n\" &lt;&lt; json(c3) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\"bytes\":[],\"subtype\":null}\n{\"bytes\":[202,254,186,190],\"subtype\":null}\n{\"bytes\":[202,254,186,190],\"subtype\":42}\n</code></pre>"},{"location":"api/byte_container_with_subtype/byte_container_with_subtype/#version-history","title":"Version history","text":"<p>Since version 3.8.0.</p>"},{"location":"api/byte_container_with_subtype/clear_subtype/","title":"nlohmann::byte_container_with_subtype::clear_subtype","text":"<pre><code>void clear_subtype() noexcept;\n</code></pre> <p>Clears the binary subtype and flags the value as not having a subtype, which has implications for serialization; for instance, MessagePack will prefer the bin family over the ext family.</p>"},{"location":"api/byte_container_with_subtype/clear_subtype/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/byte_container_with_subtype/clear_subtype/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/byte_container_with_subtype/clear_subtype/#examples","title":"Examples","text":"Example <p>The example below demonstrates how <code>clear_subtype</code> can remove subtypes.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// define a byte container based on std::vector\nusing byte_container_with_subtype = nlohmann::byte_container_with_subtype&lt;std::vector&lt;std::uint8_t&gt;&gt;;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::vector&lt;std::uint8_t&gt; bytes = {{0xca, 0xfe, 0xba, 0xbe}};\n\n    // create container with subtype\n    auto c1 = byte_container_with_subtype(bytes, 42);\n\n    std::cout &lt;&lt; \"before calling clear_subtype(): \" &lt;&lt; json(c1) &lt;&lt; '\\n';\n\n    c1.clear_subtype();\n\n    std::cout &lt;&lt; \"after calling clear_subtype(): \" &lt;&lt; json(c1) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>before calling clear_subtype(): {\"bytes\":[202,254,186,190],\"subtype\":42}\nafter calling clear_subtype(): {\"bytes\":[202,254,186,190],\"subtype\":null}\n</code></pre>"},{"location":"api/byte_container_with_subtype/clear_subtype/#version-history","title":"Version history","text":"<p>Since version 3.8.0.</p>"},{"location":"api/byte_container_with_subtype/has_subtype/","title":"nlohmann::byte_container_with_subtype::has_subtype","text":"<pre><code>constexpr bool has_subtype() const noexcept;\n</code></pre> <p>Returns whether the value has a subtype.</p>"},{"location":"api/byte_container_with_subtype/has_subtype/#return-value","title":"Return value","text":"<p>whether the value has a subtype</p>"},{"location":"api/byte_container_with_subtype/has_subtype/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/byte_container_with_subtype/has_subtype/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/byte_container_with_subtype/has_subtype/#examples","title":"Examples","text":"Example <p>The example below demonstrates how <code>has_subtype</code> can check whether a subtype was set.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// define a byte container based on std::vector\nusing byte_container_with_subtype = nlohmann::byte_container_with_subtype&lt;std::vector&lt;std::uint8_t&gt;&gt;;\n\nint main()\n{\n    std::vector&lt;std::uint8_t&gt; bytes = {{0xca, 0xfe, 0xba, 0xbe}};\n\n    // create container\n    auto c1 = byte_container_with_subtype(bytes);\n\n    // create container with subtype\n    auto c2 = byte_container_with_subtype(bytes, 42);\n\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"c1.has_subtype() = \" &lt;&lt; c1.has_subtype()\n              &lt;&lt; \"\\nc2.has_subtype() = \" &lt;&lt; c2.has_subtype() &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>c1.has_subtype() = false\nc2.has_subtype() = true\n</code></pre>"},{"location":"api/byte_container_with_subtype/has_subtype/#version-history","title":"Version history","text":"<p>Since version 3.8.0.</p>"},{"location":"api/byte_container_with_subtype/set_subtype/","title":"nlohmann::byte_container_with_subtype::set_subtype","text":"<pre><code>void set_subtype(subtype_type subtype) noexcept;\n</code></pre> <p>Sets the binary subtype of the value, also flags a binary JSON value as having a subtype, which has implications for serialization.</p>"},{"location":"api/byte_container_with_subtype/set_subtype/#parameters","title":"Parameters","text":"<code>subtype</code> (in) subtype to set"},{"location":"api/byte_container_with_subtype/set_subtype/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/byte_container_with_subtype/set_subtype/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/byte_container_with_subtype/set_subtype/#examples","title":"Examples","text":"Example <p>The example below demonstrates how a subtype can be set with <code>set_subtype</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// define a byte container based on std::vector\nusing byte_container_with_subtype = nlohmann::byte_container_with_subtype&lt;std::vector&lt;std::uint8_t&gt;&gt;;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::vector&lt;std::uint8_t&gt; bytes = {{0xca, 0xfe, 0xba, 0xbe}};\n\n    // create container without subtype\n    auto c = byte_container_with_subtype(bytes);\n\n    std::cout &lt;&lt; \"before calling set_subtype(42): \" &lt;&lt; json(c) &lt;&lt; '\\n';\n\n    // set the subtype\n    c.set_subtype(42);\n\n    std::cout &lt;&lt; \"after calling set_subtype(42): \" &lt;&lt; json(c) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>before calling set_subtype(42): {\"bytes\":[202,254,186,190],\"subtype\":null}\nafter calling set_subtype(42): {\"bytes\":[202,254,186,190],\"subtype\":42}\n</code></pre>"},{"location":"api/byte_container_with_subtype/set_subtype/#version-history","title":"Version history","text":"<p>Since version 3.8.0.</p>"},{"location":"api/byte_container_with_subtype/subtype/","title":"nlohmann::byte_container_with_subtype::subtype","text":"<pre><code>constexpr subtype_type subtype() const noexcept;\n</code></pre> <p>Returns the numerical subtype of the value if it has a subtype. If it does not have a subtype, this function will return <code>subtype_type(-1)</code> as a sentinel value.</p>"},{"location":"api/byte_container_with_subtype/subtype/#return-value","title":"Return value","text":"<p>the numerical subtype of the binary value, or <code>subtype_type(-1)</code> if no subtype is set</p>"},{"location":"api/byte_container_with_subtype/subtype/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/byte_container_with_subtype/subtype/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/byte_container_with_subtype/subtype/#examples","title":"Examples","text":"Example <p>The example below demonstrates how the subtype can be retrieved with <code>subtype</code>. Note how <code>subtype_type(-1)</code> is returned for container <code>c1</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// define a byte container based on std::vector\nusing byte_container_with_subtype = nlohmann::byte_container_with_subtype&lt;std::vector&lt;std::uint8_t&gt;&gt;;\n\nint main()\n{\n    std::vector&lt;std::uint8_t&gt; bytes = {{0xca, 0xfe, 0xba, 0xbe}};\n\n    // create container\n    auto c1 = byte_container_with_subtype(bytes);\n\n    // create container with subtype\n    auto c2 = byte_container_with_subtype(bytes, 42);\n\n    std::cout &lt;&lt; \"c1.subtype() = \" &lt;&lt; c1.subtype()\n              &lt;&lt; \"\\nc2.subtype() = \" &lt;&lt; c2.subtype() &lt;&lt; std::endl;\n\n    // in case no subtype is set, return special value\n    assert(c1.subtype() == static_cast&lt;byte_container_with_subtype::subtype_type&gt;(-1));\n}\n</code></pre> <p>Output:</p> <pre><code>c1.subtype() = 18446744073709551615\nc2.subtype() = 42\n</code></pre>"},{"location":"api/byte_container_with_subtype/subtype/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.8.0</li> <li>Fixed return value to properly return <code>subtype_type(-1)</code> as documented in version 3.10.0.</li> </ul>"},{"location":"api/json_pointer/","title":"nlohmann::json_pointer","text":"<pre><code>template&lt;typename RefStringType&gt;\nclass json_pointer;\n</code></pre> <p>A JSON pointer defines a string syntax for identifying a specific value within a JSON document. It can be used with functions <code>at</code> and <code>operator[]</code>. Furthermore, JSON pointers are the base for JSON patches.</p>"},{"location":"api/json_pointer/#template-parameters","title":"Template parameters","text":"<code>RefStringType</code> the string type used for the reference tokens making up the JSON pointer <p>Deprecation</p> <p>For backwards compatibility <code>RefStringType</code> may also be a specialization of <code>basic_json</code> in which case <code>string_t</code> will be deduced as <code>basic_json::string_t</code>. This feature is deprecated and may be removed in a future major version.</p>"},{"location":"api/json_pointer/#member-types","title":"Member types","text":"<ul> <li>string_t - the string type used for the reference tokens</li> </ul>"},{"location":"api/json_pointer/#member-functions","title":"Member functions","text":"<ul> <li>(constructor)</li> <li>to_string - return a string representation of the JSON pointer</li> <li>operator string_t - return a string representation of the JSON pointer</li> <li>operator== - compare: equal</li> <li>operator!= - compare: not equal</li> <li>operator/= - append to the end of the JSON pointer</li> <li>operator/ - create JSON Pointer by appending</li> <li>parent_pointer - returns the parent of this JSON pointer</li> <li>pop_back - remove the last reference token</li> <li>back - return last reference token</li> <li>push_back - append an unescaped token at the end of the pointer</li> <li>empty - return whether the pointer points to the root document</li> </ul>"},{"location":"api/json_pointer/#literals","title":"Literals","text":"<ul> <li>operator\"\"_json_pointer - user-defined string literal for JSON pointers</li> </ul>"},{"location":"api/json_pointer/#see-also","title":"See also","text":"<ul> <li>RFC 6901</li> </ul>"},{"location":"api/json_pointer/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> <li>Changed template parameter from <code>basic_json</code> to string type in version 3.11.0.</li> </ul>"},{"location":"api/json_pointer/back/","title":"nlohmann::json_pointer::back","text":"<pre><code>const string_t&amp; back() const;\n</code></pre> <p>Return the last reference token.</p>"},{"location":"api/json_pointer/back/#return-value","title":"Return value","text":"<p>Last reference token.</p>"},{"location":"api/json_pointer/back/#exceptions","title":"Exceptions","text":"<p>Throws out_of_range.405 if the JSON pointer has no parent.</p>"},{"location":"api/json_pointer/back/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/json_pointer/back/#examples","title":"Examples","text":"Example <p>The example shows the usage of <code>back</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON Pointers\n    json::json_pointer ptr1(\"/foo\");\n    json::json_pointer ptr2(\"/foo/0\");\n\n    // call empty()\n    std::cout &lt;&lt; \"last reference token of \\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\" is \\\"\" &lt;&lt; ptr1.back() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"last reference token of \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\" is \\\"\" &lt;&lt; ptr2.back() &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>last reference token of \"/foo\" is \"foo\"\nlast reference token of \"/foo/0\" is \"0\"\n</code></pre>"},{"location":"api/json_pointer/back/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.6.0.</li> <li>Changed return type to <code>string_t</code> in version 3.11.0.</li> </ul>"},{"location":"api/json_pointer/empty/","title":"nlohmann::json_pointer::empty","text":"<pre><code>bool empty() const noexcept;\n</code></pre> <p>Return whether the pointer points to the root document.</p>"},{"location":"api/json_pointer/empty/#return-value","title":"Return value","text":"<p><code>true</code> iff the JSON pointer points to the root document.</p>"},{"location":"api/json_pointer/empty/#exception-safety","title":"Exception safety","text":"<p>No-throw guarantee: this function never throws exceptions.</p>"},{"location":"api/json_pointer/empty/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/json_pointer/empty/#examples","title":"Examples","text":"Example <p>The example shows the result of <code>empty</code> for different JSON Pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON Pointers\n    json::json_pointer ptr0;\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n    json::json_pointer ptr3(\"/foo/0\");\n\n    // call empty()\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\": \" &lt;&lt; ptr0.empty() &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\": \" &lt;&lt; ptr1.empty() &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\": \" &lt;&lt; ptr2.empty() &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr3 &lt;&lt; \"\\\": \" &lt;&lt; ptr3.empty() &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>\"\": true\n\"\": true\n\"/foo\": false\n\"/foo/0\": false\n</code></pre>"},{"location":"api/json_pointer/empty/#version-history","title":"Version history","text":"<p>Added in version 3.6.0.</p>"},{"location":"api/json_pointer/json_pointer/","title":"nlohmann::json_pointer::json_pointer","text":"<pre><code>explicit json_pointer(const string_t&amp; s = \"\");\n</code></pre> <p>Create a JSON pointer according to the syntax described in Section 3 of RFC6901.</p>"},{"location":"api/json_pointer/json_pointer/#parameters","title":"Parameters","text":"<code>s</code> (in) string representing the JSON pointer; if omitted, the empty string is assumed which references the whole JSON value"},{"location":"api/json_pointer/json_pointer/#exceptions","title":"Exceptions","text":"<ul> <li>Throws parse_error.107 if the given JSON pointer <code>s</code> is    nonempty and does not begin with a slash (<code>/</code>); see example below.</li> <li>Throws parse_error.108 if a tilde (<code>~</code>) in the given JSON   pointer <code>s</code> is not followed by <code>0</code> (representing <code>~</code>) or <code>1</code> (representing <code>/</code>); see example below.</li> </ul>"},{"location":"api/json_pointer/json_pointer/#examples","title":"Examples","text":"Example <p>The example shows the construction several valid JSON pointers as well as the exceptional behavior.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // correct JSON pointers\n    json::json_pointer p1;\n    json::json_pointer p2(\"\");\n    json::json_pointer p3(\"/\");\n    json::json_pointer p4(\"//\");\n    json::json_pointer p5(\"/foo/bar\");\n    json::json_pointer p6(\"/foo/bar/-\");\n    json::json_pointer p7(\"/foo/~0\");\n    json::json_pointer p8(\"/foo/~1\");\n\n    // error: JSON pointer does not begin with a slash\n    try\n    {\n        json::json_pointer p9(\"foo\");\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // error: JSON pointer uses escape symbol ~ not followed by 0 or 1\n    try\n    {\n        json::json_pointer p10(\"/foo/~\");\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n\n    // error: JSON pointer uses escape symbol ~ not followed by 0 or 1\n    try\n    {\n        json::json_pointer p11(\"/foo/~3\");\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'foo'\n[json.exception.parse_error.108] parse error: escape character '~' must be followed with '0' or '1'\n[json.exception.parse_error.108] parse error: escape character '~' must be followed with '0' or '1'\n</code></pre>"},{"location":"api/json_pointer/json_pointer/#version-history","title":"Version history","text":"<ul> <li>Added in version 2.0.0.</li> <li>Changed type of <code>s</code> to <code>string_t</code> in version 3.11.0.</li> </ul>"},{"location":"api/json_pointer/operator_eq/","title":"nlohmann::json_pointer::operator==","text":"<pre><code>// until C++20\ntemplate&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;\nbool operator==(\n    const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,\n    const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept;            // (1)\n\ntemplate&lt;typename RefStringTypeLhs, typename StringType&gt;\nbool operator==(\n    const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,\n    const StringType&amp; rhs);                                         // (2)\n\ntemplate&lt;typename RefStringTypeRhs, typename StringType&gt;\nbool operator==(\n    const StringType&amp; lhs,\n    const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs);                     // (2)\n\n// since C++20\nclass json_pointer {\n    template&lt;typename RefStringTypeRhs&gt;\n    bool operator==(\n        const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) const noexcept;  // (1)\n\n    bool operator==(const string_t&amp; rhs) const;                     // (2)\n};\n</code></pre> <ol> <li> <p>Compares two JSON pointers for equality by comparing their reference tokens.</p> </li> <li> <p>Compares a JSON pointer and a string or a string and a JSON pointer for equality by converting the string to a JSON    pointer and comparing the JSON pointers according to 1.</p> </li> </ol>"},{"location":"api/json_pointer/operator_eq/#template-parameters","title":"Template parameters","text":"<code>RefStringTypeLhs</code>, <code>RefStringTypeRhs</code> the string type of the left-hand side or right-hand side JSON pointer, respectively <code>StringType</code> the string type derived from the <code>json_pointer</code> operand (<code>json_pointer::string_t</code>)"},{"location":"api/json_pointer/operator_eq/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider <code>rhs</code> (in) second value to consider"},{"location":"api/json_pointer/operator_eq/#return-value","title":"Return value","text":"<p>whether the values <code>lhs</code>/<code>*this</code> and <code>rhs</code> are equal</p>"},{"location":"api/json_pointer/operator_eq/#exception-safety","title":"Exception safety","text":"<ol> <li>No-throw guarantee: this function never throws exceptions.</li> <li>Strong exception safety: if an exception occurs, the original value stays intact.</li> </ol>"},{"location":"api/json_pointer/operator_eq/#exceptions","title":"Exceptions","text":"<ol> <li>(none)</li> <li>The function can throw the following exceptions:</li> <li>Throws parse_error.107 if the given JSON pointer <code>s</code> is      nonempty and does not begin with a slash (<code>/</code>); see example below.</li> <li>Throws parse_error.108 if a tilde (<code>~</code>) in the given JSON      pointer <code>s</code> is not followed by <code>0</code> (representing <code>~</code>) or <code>1</code> (representing <code>/</code>); see example below.</li> </ol>"},{"location":"api/json_pointer/operator_eq/#complexity","title":"Complexity","text":"<p>Constant if <code>lhs</code> and <code>rhs</code> differ in the number of reference tokens, otherwise linear in the number of reference tokens.</p>"},{"location":"api/json_pointer/operator_eq/#notes","title":"Notes","text":"<p>Deprecation</p> <p>Overload 2 is deprecated and will be removed in a future major version release.</p>"},{"location":"api/json_pointer/operator_eq/#examples","title":"Examples","text":"Example: (1) Comparing JSON pointers <p>The example demonstrates comparing JSON pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON pointers\n    json::json_pointer ptr0;\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n\n    // compare JSON pointers\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\": \" &lt;&lt; (ptr0 == ptr0) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\": \" &lt;&lt; (ptr0 == ptr1) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\": \" &lt;&lt; (ptr1 == ptr2) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\": \" &lt;&lt; (ptr2 == ptr2) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>\"\" == \"\": true\n\"\" == \"\": true\n\"\" == \"/foo\": false\n\"/foo\" == \"/foo\": true\n</code></pre> Example: (2) Comparing JSON pointers and strings <p>The example demonstrates comparing JSON pointers and strings, and when doing so may raise an exception.</p> <pre><code>#include &lt;exception&gt;\n#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON pointers\n    json::json_pointer ptr0;\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n\n    // different strings\n    std::string str0(\"\");\n    std::string str1(\"/foo\");\n    std::string str2(\"bar\");\n\n    // compare JSON pointers and strings\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; str0 &lt;&lt; \"\\\": \" &lt;&lt; (ptr0 == str0) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; str0 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\": \" &lt;&lt; (str0 == ptr1) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; str1 &lt;&lt; \"\\\": \" &lt;&lt; (ptr2 == str1) &lt;&lt; std::endl;\n\n    try\n    {\n        std::cout &lt;&lt; \"\\\"\" &lt;&lt; str2 &lt;&lt; \"\\\" == \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\": \" &lt;&lt; (str2 == ptr2) &lt;&lt; std::endl;\n    }\n    catch (const json::parse_error&amp; ex)\n    {\n        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"\" == \"\": true\n\"\" == \"\": true\n\"/foo\" == \"/foo\": true\n\"bar\" == \"/foo\": [json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'bar'\n</code></pre>"},{"location":"api/json_pointer/operator_eq/#version-history","title":"Version history","text":"<ol> <li>Added in version 2.1.0. Added C++20 member functions in version 3.11.2.</li> <li>Added for backward compatibility and deprecated in version 3.11.2.</li> </ol>"},{"location":"api/json_pointer/operator_ne/","title":"nlohmann::json_pointer::operator!=","text":"<pre><code>// until C++20\ntemplate&lt;typename RefStringTypeLhs, typename RefStringTypeRhs&gt;\nbool operator!=(\n    const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,\n    const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs) noexcept;  // (1)\n\ntemplate&lt;typename RefStringTypeLhs, typename StringType&gt;\nbool operator!=(\n    const json_pointer&lt;RefStringTypeLhs&gt;&amp; lhs,\n    const StringType&amp; rhs);                               // (2)\n\ntemplate&lt;typename RefStringTypeRhs, typename StringType&gt;\nbool operator!=(\n    const StringType&amp; lhs,\n    const json_pointer&lt;RefStringTypeRhs&gt;&amp; rhs);           // (2)\n</code></pre> <ol> <li> <p>Compares two JSON pointers for inequality by comparing their reference tokens.</p> </li> <li> <p>Compares a JSON pointer and a string or a string and a JSON pointer for inequality by converting the string to a    JSON pointer and comparing the JSON pointers according to 1.</p> </li> </ol>"},{"location":"api/json_pointer/operator_ne/#template-parameters","title":"Template parameters","text":"<code>RefStringTypeLhs</code>, <code>RefStringTypeRhs</code> the string type of the left-hand side or right-hand side JSON pointer, respectively <code>StringType</code> the string type derived from the <code>json_pointer</code> operand (<code>json_pointer::string_t</code>)"},{"location":"api/json_pointer/operator_ne/#parameters","title":"Parameters","text":"<code>lhs</code> (in) first value to consider <code>rhs</code> (in) second value to consider"},{"location":"api/json_pointer/operator_ne/#return-value","title":"Return value","text":"<p>whether the values <code>lhs</code>/<code>*this</code> and <code>rhs</code> are not equal</p>"},{"location":"api/json_pointer/operator_ne/#exception-safety","title":"Exception safety","text":"<ol> <li>No-throw guarantee: this function never throws exceptions.</li> <li>Strong exception safety: if an exception occurs, the original value stays intact.</li> </ol>"},{"location":"api/json_pointer/operator_ne/#exceptions","title":"Exceptions","text":"<ol> <li>(none)</li> <li>The function can throw the following exceptions:</li> <li>Throws parse_error.107 if the given JSON pointer <code>s</code> is      nonempty and does not begin with a slash (<code>/</code>); see example below.</li> <li>Throws parse_error.108 if a tilde (<code>~</code>) in the given JSON      pointer <code>s</code> is not followed by <code>0</code> (representing <code>~</code>) or <code>1</code> (representing <code>/</code>); see example below.</li> </ol>"},{"location":"api/json_pointer/operator_ne/#complexity","title":"Complexity","text":"<p>Constant if <code>lhs</code> and <code>rhs</code> differ in the number of reference tokens, otherwise linear in the number of reference tokens.</p>"},{"location":"api/json_pointer/operator_ne/#notes","title":"Notes","text":"<p>Operator overload resolution</p> <p>Since C++20 overload resolution will consider the rewritten candidate generated from <code>operator==</code>.</p> <p>Deprecation</p> <p>Overload 2 is deprecated and will be removed in a future major version release.</p>"},{"location":"api/json_pointer/operator_ne/#examples","title":"Examples","text":"Example: (1) Comparing JSON pointers <p>The example demonstrates comparing JSON pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON pointers\n    json::json_pointer ptr0;\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n\n    // compare JSON pointers\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\": \" &lt;&lt; (ptr0 != ptr0) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\": \" &lt;&lt; (ptr0 != ptr1) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\": \" &lt;&lt; (ptr1 != ptr2) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\": \" &lt;&lt; (ptr2 != ptr2) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>\"\" != \"\": false\n\"\" != \"\": false\n\"\" != \"/foo\": true\n\"/foo\" != \"/foo\": false\n</code></pre> Example: (2) Comparing JSON pointers and strings <p>The example demonstrates comparing JSON pointers and strings, and when doing so may raise an exception.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON pointers\n    json::json_pointer ptr0;\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n\n    // different strings\n    std::string str0(\"\");\n    std::string str1(\"/foo\");\n    std::string str2(\"bar\");\n\n    // compare JSON pointers and strings\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr0 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; str0 &lt;&lt; \"\\\": \" &lt;&lt; (ptr0 != str0) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; str0 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\": \" &lt;&lt; (str0 != ptr1) &lt;&lt; '\\n'\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; str1 &lt;&lt; \"\\\": \" &lt;&lt; (ptr2 != str1) &lt;&lt; std::endl;\n\n    try\n    {\n        std::cout &lt;&lt; \"\\\"\" &lt;&lt; str2 &lt;&lt; \"\\\" != \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\": \" &lt;&lt; (str2 != ptr2) &lt;&lt; std::endl;\n    }\n    catch (const json::parse_error&amp; ex)\n    {\n        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>\"\" != \"\": false\n\"\" != \"\": false\n\"/foo\" != \"/foo\": false\n\"bar\" != \"/foo\": [json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'bar'\n</code></pre>"},{"location":"api/json_pointer/operator_ne/#version-history","title":"Version history","text":"<ol> <li>Added in version 2.1.0.</li> <li>Added for backward compatibility and deprecated in version 3.11.2.</li> </ol>"},{"location":"api/json_pointer/operator_slash/","title":"nlohmann::json_pointer::operator/","text":"<pre><code>// (1)\njson_pointer operator/(const json_pointer&amp; lhs, const json_pointer&amp; rhs);\n\n// (2)\njson_pointer operator/(const json_pointer&amp; lhs, string_t token);\n\n// (3)\njson_pointer operator/(const json_pointer&amp; lhs, std::size_t array_idx);\n</code></pre> <ol> <li>create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer</li> <li>create a new JSON pointer by appending the unescaped token at the end of the JSON pointer</li> <li>create a new JSON pointer by appending the array-index-token at the end of the JSON pointer</li> </ol>"},{"location":"api/json_pointer/operator_slash/#parameters","title":"Parameters","text":"<code>lhs</code> (in) JSON pointer <code>rhs</code> (in) JSON pointer to append <code>token</code> (in) reference token to append <code>array_idx</code> (in) array index to append"},{"location":"api/json_pointer/operator_slash/#return-value","title":"Return value","text":"<ol> <li>a new JSON pointer with <code>rhs</code> appended to <code>lhs</code></li> <li>a new JSON pointer with unescaped <code>token</code> appended to <code>lhs</code></li> <li>a new JSON pointer with <code>array_idx</code> appended to <code>lhs</code></li> </ol>"},{"location":"api/json_pointer/operator_slash/#complexity","title":"Complexity","text":"<ol> <li>Linear in the length of <code>lhs</code> and <code>rhs</code>.</li> <li>Linear in the length of <code>lhs</code>.</li> <li>Linear in the length of <code>lhs</code>.</li> </ol>"},{"location":"api/json_pointer/operator_slash/#examples","title":"Examples","text":"Example <p>The example shows the usage of <code>operator/</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON pointer\n    json::json_pointer ptr(\"/foo\");\n\n    // append a JSON Pointer\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr / json::json_pointer(\"/bar/baz\") &lt;&lt; \"\\\"\\n\";\n\n    // append a string\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr / \"fob\" &lt;&lt; \"\\\"\\n\";\n\n    // append an array index\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr / 42 &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>\"/foo/bar/baz\"\n\"/foo/fob\"\n\"/foo/42\"\n</code></pre>"},{"location":"api/json_pointer/operator_slash/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.6.0.</li> <li>Added in version 3.6.0. Changed type of <code>token</code> to <code>string_t</code> in version 3.11.0.</li> <li>Added in version 3.6.0.</li> </ol>"},{"location":"api/json_pointer/operator_slasheq/","title":"nlohmann::json_pointer::operator/=","text":"<pre><code>// (1)\njson_pointer&amp; operator/=(const json_pointer&amp; ptr);\n\n// (2)\njson_pointer&amp; operator/=(string_t token);\n\n// (3)\njson_pointer&amp; operator/=(std::size_t array_idx)\n</code></pre> <ol> <li>append another JSON pointer at the end of this JSON pointer</li> <li>append an unescaped reference token at the end of this JSON pointer</li> <li>append an array index at the end of this JSON pointer</li> </ol>"},{"location":"api/json_pointer/operator_slasheq/#parameters","title":"Parameters","text":"<code>ptr</code> (in) JSON pointer to append <code>token</code> (in) reference token to append <code>array_idx</code> (in) array index to append"},{"location":"api/json_pointer/operator_slasheq/#return-value","title":"Return value","text":"<ol> <li>JSON pointer with <code>ptr</code> appended</li> <li>JSON pointer with <code>token</code> appended without escaping <code>token</code></li> <li>JSON pointer with <code>array_idx</code> appended</li> </ol>"},{"location":"api/json_pointer/operator_slasheq/#complexity","title":"Complexity","text":"<ol> <li>Linear in the length of <code>ptr</code>.</li> <li>Amortized constant.</li> <li>Amortized constant.</li> </ol>"},{"location":"api/json_pointer/operator_slasheq/#examples","title":"Examples","text":"Example <p>The example shows the usage of <code>operator/=</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create a JSON pointer\n    json::json_pointer ptr(\"/foo\");\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    // append a JSON Pointer\n    ptr /= json::json_pointer(\"/bar/baz\");\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    // append a string\n    ptr /= \"fob\";\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    // append an array index\n    ptr /= 42;\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>\"/foo\"\n\"/foo/bar/baz\"\n\"/foo/bar/baz/fob\"\n\"/foo/bar/baz/fob/42\"\n</code></pre>"},{"location":"api/json_pointer/operator_slasheq/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.6.0.</li> <li>Added in version 3.6.0. Changed type of <code>token</code> to <code>string_t</code> in version 3.11.0.</li> <li>Added in version 3.6.0.</li> </ol>"},{"location":"api/json_pointer/operator_string_t/","title":"nlohmann::json_pointer::operator string_t","text":"<pre><code>operator string_t() const\n</code></pre> <p>Return a string representation of the JSON pointer.</p>"},{"location":"api/json_pointer/operator_string_t/#return-value","title":"Return value","text":"<p>A string representation of the JSON pointer</p>"},{"location":"api/json_pointer/operator_string_t/#possible-implementation","title":"Possible implementation","text":"<pre><code>operator string_t() const\n{\n    return to_string();\n}\n</code></pre>"},{"location":"api/json_pointer/operator_string_t/#notes","title":"Notes","text":"<p>Deprecation</p> <p>This function is deprecated in favor of <code>to_string</code> and will be removed in a future major version release.</p>"},{"location":"api/json_pointer/operator_string_t/#examples","title":"Examples","text":"Example <p>The example shows how JSON Pointers can be implicitly converted to strings.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON Pointers\n    json::json_pointer ptr1(\"/foo/0\");\n    json::json_pointer ptr2(\"/a~1b\");\n\n    // implicit conversion to string\n    std::string s;\n    s += ptr1;\n    s += \"\\n\";\n    s += ptr2;\n\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>/foo/0\n/a~1b\n</code></pre>"},{"location":"api/json_pointer/operator_string_t/#see-also","title":"See also","text":"<ul> <li>string_t- type for strings</li> </ul>"},{"location":"api/json_pointer/operator_string_t/#version-history","title":"Version history","text":"<ul> <li>Since version 2.0.0.</li> <li>Changed type to <code>string_t</code> and deprecated in version 3.11.0.</li> </ul>"},{"location":"api/json_pointer/parent_pointer/","title":"nlohmann::json_pointer::parent_pointer","text":"<pre><code>json_pointer parent_pointer() const;\n</code></pre> <p>Returns the parent of this JSON pointer.</p>"},{"location":"api/json_pointer/parent_pointer/#return-value","title":"Return value","text":"<p>Parent of this JSON pointer; in case this JSON pointer is the root, the root itself is returned.</p>"},{"location":"api/json_pointer/parent_pointer/#complexity","title":"Complexity","text":"<p>Linear in the length of the JSON pointer.</p>"},{"location":"api/json_pointer/parent_pointer/#examples","title":"Examples","text":"Example <p>The example shows the result of <code>parent_pointer</code> for different JSON Pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON Pointers\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n    json::json_pointer ptr3(\"/foo/0\");\n\n    // call parent_pointer()\n    std::cout &lt;&lt; std::boolalpha\n              &lt;&lt; \"parent of \\\"\" &lt;&lt; ptr1 &lt;&lt; \"\\\" is \\\"\" &lt;&lt; ptr1.parent_pointer() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"parent of \\\"\" &lt;&lt; ptr2 &lt;&lt; \"\\\" is \\\"\" &lt;&lt; ptr2.parent_pointer() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"parent of \\\"\" &lt;&lt; ptr3 &lt;&lt; \"\\\" is \\\"\" &lt;&lt; ptr3.parent_pointer() &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>parent of \"\" is \"\"\nparent of \"/foo\" is \"\"\nparent of \"/foo/0\" is \"/foo\"\n</code></pre>"},{"location":"api/json_pointer/parent_pointer/#version-history","title":"Version history","text":"<p>Added in version 3.6.0.</p>"},{"location":"api/json_pointer/pop_back/","title":"nlohmann::json_pointer::pop_back","text":"<pre><code>void pop_back();\n</code></pre> <p>Remove the last reference token.</p>"},{"location":"api/json_pointer/pop_back/#exceptions","title":"Exceptions","text":"<p>Throws out_of_range.405 if the JSON pointer has no parent.</p>"},{"location":"api/json_pointer/pop_back/#complexity","title":"Complexity","text":"<p>Constant.</p>"},{"location":"api/json_pointer/pop_back/#examples","title":"Examples","text":"Example <p>The example shows the usage of <code>pop_back</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create empty JSON Pointer\n    json::json_pointer ptr(\"/foo/bar/baz\");\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    // call pop_back()\n    ptr.pop_back();\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    ptr.pop_back();\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    ptr.pop_back();\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>\"/foo/bar/baz\"\n\"/foo/bar\"\n\"/foo\"\n\"\"\n</code></pre>"},{"location":"api/json_pointer/pop_back/#version-history","title":"Version history","text":"<p>Added in version 3.6.0.</p>"},{"location":"api/json_pointer/push_back/","title":"nlohmann::json_pointer::push_back","text":"<pre><code>void push_back(const string_t&amp; token);\n\nvoid push_back(string_t&amp;&amp; token);\n</code></pre> <p>Append an unescaped token at the end of the reference pointer.</p>"},{"location":"api/json_pointer/push_back/#parameters","title":"Parameters","text":"<code>token</code> (in) token to add"},{"location":"api/json_pointer/push_back/#complexity","title":"Complexity","text":"<p>Amortized constant.</p>"},{"location":"api/json_pointer/push_back/#examples","title":"Examples","text":"Example <p>The example shows the result of <code>push_back</code> for different JSON Pointers.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create empty JSON Pointer\n    json::json_pointer ptr;\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    // call push_back()\n    ptr.push_back(\"foo\");\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    ptr.push_back(\"0\");\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n\n    ptr.push_back(\"bar\");\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr &lt;&lt; \"\\\"\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>\"\"\n\"/foo\"\n\"/foo/0\"\n\"/foo/0/bar\"\n</code></pre>"},{"location":"api/json_pointer/push_back/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.6.0.</li> <li>Changed type of <code>token</code> to <code>string_t</code> in version 3.11.0.</li> </ul>"},{"location":"api/json_pointer/string_t/","title":"nlohmann::json_pointer::string_t","text":"<pre><code>using string_t = RefStringType;\n</code></pre> <p>The string type used for the reference tokens making up the JSON pointer.</p> <p>See <code>basic_json::string_t</code> for more information.</p>"},{"location":"api/json_pointer/string_t/#examples","title":"Examples","text":"Example <p>The example shows the type <code>string_t</code> and its relation to <code>basic_json::string_t</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json::json_pointer::string_t s = \"This is a string.\";\n\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;json::json_pointer::string_t, json::string_t&gt;::value &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>This is a string.\ntrue\n</code></pre>"},{"location":"api/json_pointer/string_t/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/json_pointer/to_string/","title":"nlohmann::json_pointer::to_string","text":"<pre><code>string_t to_string() const;\n</code></pre> <p>Return a string representation of the JSON pointer.</p>"},{"location":"api/json_pointer/to_string/#return-value","title":"Return value","text":"<p>A string representation of the JSON pointer</p>"},{"location":"api/json_pointer/to_string/#notes","title":"Notes","text":"<p>For each JSON pointer <code>ptr</code>, it holds:</p> <pre><code>ptr == json_pointer(ptr.to_string());\n</code></pre>"},{"location":"api/json_pointer/to_string/#examples","title":"Examples","text":"Example <p>The example shows the result of <code>to_string</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // different JSON Pointers\n    json::json_pointer ptr1(\"\");\n    json::json_pointer ptr2(\"/foo\");\n    json::json_pointer ptr3(\"/foo/0\");\n    json::json_pointer ptr4(\"/\");\n    json::json_pointer ptr5(\"/a~1b\");\n    json::json_pointer ptr6(\"/c%d\");\n    json::json_pointer ptr7(\"/e^f\");\n    json::json_pointer ptr8(\"/g|h\");\n    json::json_pointer ptr9(\"/i\\\\j\");\n    json::json_pointer ptr10(\"/k\\\"l\");\n    json::json_pointer ptr11(\"/ \");\n    json::json_pointer ptr12(\"/m~0n\");\n\n    std::cout &lt;&lt; \"\\\"\" &lt;&lt; ptr1.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr2.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr3.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr4.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr5.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr6.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr7.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr8.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr9.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr10.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr11.to_string() &lt;&lt; \"\\\"\\n\"\n              &lt;&lt; \"\\\"\" &lt;&lt; ptr12.to_string() &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>\"\"\n\"/foo\"\n\"/foo/0\"\n\"/\"\n\"/a~1b\"\n\"/c%d\"\n\"/e^f\"\n\"/g|h\"\n\"/i\\j\"\n\"/k\"l\"\n\"/ \"\n\"/m~0n\"\n</code></pre>"},{"location":"api/json_pointer/to_string/#version-history","title":"Version history","text":"<ul> <li>Since version 2.0.0.</li> <li>Changed return type to <code>string_t</code> in version 3.11.0.</li> </ul>"},{"location":"api/json_sax/","title":"nlohmann::json_sax","text":"<pre><code>template&lt;typename BasicJsonType&gt;\nstruct json_sax;\n</code></pre> <p>This class describes the SAX interface used by sax_parse. Each function is called in different situations while the input is parsed. The boolean return value informs the parser whether to continue processing the input.</p>"},{"location":"api/json_sax/#template-parameters","title":"Template parameters","text":"<code>BasicJsonType</code> a specialization of <code>basic_json</code>"},{"location":"api/json_sax/#member-types","title":"Member types","text":"<ul> <li>number_integer_t - <code>BasicJsonType</code>'s type for numbers (integer)</li> <li>number_unsigned_t - <code>BasicJsonType</code>'s type for numbers (unsigned)</li> <li>number_float_t - <code>BasicJsonType</code>'s type for numbers (floating-point)</li> <li>string_t - <code>BasicJsonType</code>'s type for strings</li> <li>binary_t - <code>BasicJsonType</code>'s type for binary arrays</li> </ul>"},{"location":"api/json_sax/#member-functions","title":"Member functions","text":"<ul> <li>binary (virtual) - a binary value was read</li> <li>boolean (virtual) - a boolean value was read</li> <li>end_array (virtual) - the end of an array was read</li> <li>end_object (virtual) - the end of an object was read</li> <li>key (virtual) - an object key was read</li> <li>null (virtual) - a null value was read</li> <li>number_float (virtual) - a floating-point number was read</li> <li>number_integer (virtual) - an integer number was read</li> <li>number_unsigned (virtual) - an unsigned integer number was read</li> <li>parse_error (virtual) - a parse error occurred</li> <li>start_array (virtual) - the beginning of an array was read</li> <li>start_object (virtual) - the beginning of an object was read</li> <li>string (virtual) - a string value was read</li> </ul>"},{"location":"api/json_sax/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> <li>Support for binary values (<code>binary_t</code>, <code>binary</code>) added in version 3.8.0.</li> </ul>"},{"location":"api/json_sax/binary/","title":"nlohmann::json_sax::binary","text":"<pre><code>virtual bool binary(binary_t&amp; val) = 0;\n</code></pre> <p>A binary value was read.</p>"},{"location":"api/json_sax/binary/#parameters","title":"Parameters","text":"<code>val</code> (in) binary value"},{"location":"api/json_sax/binary/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/binary/#notes","title":"Notes","text":"<p>It is safe to move the passed binary value.</p>"},{"location":"api/json_sax/binary/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // CBOR byte string\n    std::vector&lt;std::uint8_t&gt; vec = {{0x44, 0xcA, 0xfe, 0xba, 0xbe}};\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse CBOR\n    bool result = json::sax_parse(vec, &amp;sec, json::input_format_t::cbor);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>binary(val=[...])\n\nresult: true\n</code></pre>"},{"location":"api/json_sax/binary/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.8.0.</li> </ul>"},{"location":"api/json_sax/boolean/","title":"nlohmann::json_sax::boolean","text":"<pre><code>virtual bool boolean(bool val) = 0;\n</code></pre> <p>A boolean value was read.</p>"},{"location":"api/json_sax/boolean/#parameters","title":"Parameters","text":"<code>val</code> (in) boolean value"},{"location":"api/json_sax/boolean/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/boolean/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/boolean/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/end_array/","title":"nlohmann::json_sax::end_array","text":"<pre><code>virtual bool end_array() = 0;\n</code></pre> <p>The end of an array was read.</p>"},{"location":"api/json_sax/end_array/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/end_array/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/end_array/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/end_object/","title":"nlohmann::json_sax::end_object","text":"<pre><code>virtual bool end_object() = 0;\n</code></pre> <p>The end of an object was read.</p>"},{"location":"api/json_sax/end_object/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/end_object/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/end_object/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/key/","title":"nlohmann::json_sax::key","text":"<pre><code>virtual bool key(string_t&amp; val) = 0;\n</code></pre> <p>An object key was read.</p>"},{"location":"api/json_sax/key/#parameters","title":"Parameters","text":"<code>val</code> (in) object key"},{"location":"api/json_sax/key/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/key/#notes","title":"Notes","text":"<p>It is safe to move the passed object key value.</p>"},{"location":"api/json_sax/key/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/key/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/null/","title":"nlohmann::json_sax::null","text":"<pre><code>virtual bool null() = 0;\n</code></pre> <p>A null value was read.</p>"},{"location":"api/json_sax/null/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/null/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/null/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/number_float/","title":"nlohmann::json_sax::number_float","text":"<pre><code>virtual bool number_float(number_float_t val, const string_t&amp; s) = 0;\n</code></pre> <p>A floating-point number was read.</p>"},{"location":"api/json_sax/number_float/#parameters","title":"Parameters","text":"<code>val</code> (in) floating-point value <code>s</code> (in) string representation of the original input"},{"location":"api/json_sax/number_float/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/number_float/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/number_float/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/number_integer/","title":"nlohmann::json_sax::number_integer","text":"<pre><code>virtual bool number_integer(number_integer_t val) = 0;\n</code></pre> <p>An integer number was read.</p>"},{"location":"api/json_sax/number_integer/#parameters","title":"Parameters","text":"<code>val</code> (in) integer value"},{"location":"api/json_sax/number_integer/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/number_integer/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/number_integer/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/number_unsigned/","title":"nlohmann::json_sax::number_unsigned","text":"<pre><code>virtual bool number_unsigned(number_unsigned_t val) = 0;\n</code></pre> <p>An unsigned integer number was read.</p>"},{"location":"api/json_sax/number_unsigned/#parameters","title":"Parameters","text":"<code>val</code> (in) unsigned integer value"},{"location":"api/json_sax/number_unsigned/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/number_unsigned/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/number_unsigned/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/parse_error/","title":"nlohmann::json_sax::parse_error","text":"<pre><code>virtual bool parse_error(std::size_t position,\n                         const std::string&amp; last_token,\n                         const detail::exception&amp; ex) = 0;\n</code></pre> <p>A parse error occurred.</p>"},{"location":"api/json_sax/parse_error/#parameters","title":"Parameters","text":"<code>position</code> (in) the position in the input where the error occurs <code>last_token</code> (in) the last read token <code>ex</code> (in) an exception object describing the error"},{"location":"api/json_sax/parse_error/#return-value","title":"Return value","text":"<p>Whether parsing should proceed (must return <code>false</code>).</p>"},{"location":"api/json_sax/parse_error/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/parse_error/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/start_array/","title":"nlohmann::json_sax::start_array","text":"<pre><code>virtual bool start_array(std::size_t elements) = 0;\n</code></pre> <p>The beginning of an array was read.</p>"},{"location":"api/json_sax/start_array/#parameters","title":"Parameters","text":"<code>elements</code> (in) number of object elements or <code>-1</code> if unknown"},{"location":"api/json_sax/start_array/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/start_array/#notes","title":"Notes","text":"<p>Binary formats may report the number of elements.</p>"},{"location":"api/json_sax/start_array/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/start_array/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/start_object/","title":"nlohmann::json_sax::start_object","text":"<pre><code>virtual bool start_object(std::size_t elements) = 0;\n</code></pre> <p>The beginning of an object was read.</p>"},{"location":"api/json_sax/start_object/#parameters","title":"Parameters","text":"<code>elements</code> (in) number of object elements or <code>-1</code> if unknown"},{"location":"api/json_sax/start_object/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/start_object/#notes","title":"Notes","text":"<p>Binary formats may report the number of elements.</p>"},{"location":"api/json_sax/start_object/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/start_object/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/json_sax/string/","title":"nlohmann::json_sax::string","text":"<pre><code>virtual bool string(string_t&amp; val) = 0;\n</code></pre> <p>A string value was read.</p>"},{"location":"api/json_sax/string/#parameters","title":"Parameters","text":"<code>val</code> (in) string value"},{"location":"api/json_sax/string/#return-value","title":"Return value","text":"<p>Whether parsing should proceed.</p>"},{"location":"api/json_sax/string/#notes","title":"Notes","text":"<p>It is safe to move the passed string value.</p>"},{"location":"api/json_sax/string/#examples","title":"Examples","text":"Example <p>The example below shows how the SAX interface is used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n// a simple event consumer that collects string representations of the passed\n// values; note inheriting from json::json_sax_t is not required, but can\n// help not to forget a required function\nclass sax_event_consumer : public json::json_sax_t\n{\n  public:\n    std::vector&lt;std::string&gt; events;\n\n    bool null() override\n    {\n        events.push_back(\"null()\");\n        return true;\n    }\n\n    bool boolean(bool val) override\n    {\n        events.push_back(\"boolean(val=\" + std::string(val ? \"true\" : \"false\") + \")\");\n        return true;\n    }\n\n    bool number_integer(number_integer_t val) override\n    {\n        events.push_back(\"number_integer(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_unsigned(number_unsigned_t val) override\n    {\n        events.push_back(\"number_unsigned(val=\" + std::to_string(val) + \")\");\n        return true;\n    }\n\n    bool number_float(number_float_t val, const string_t&amp; s) override\n    {\n        events.push_back(\"number_float(val=\" + std::to_string(val) + \", s=\" + s + \")\");\n        return true;\n    }\n\n    bool string(string_t&amp; val) override\n    {\n        events.push_back(\"string(val=\" + val + \")\");\n        return true;\n    }\n\n    bool start_object(std::size_t elements) override\n    {\n        events.push_back(\"start_object(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_object() override\n    {\n        events.push_back(\"end_object()\");\n        return true;\n    }\n\n    bool start_array(std::size_t elements) override\n    {\n        events.push_back(\"start_array(elements=\" + std::to_string(elements) + \")\");\n        return true;\n    }\n\n    bool end_array() override\n    {\n        events.push_back(\"end_array()\");\n        return true;\n    }\n\n    bool key(string_t&amp; val) override\n    {\n        events.push_back(\"key(val=\" + val + \")\");\n        return true;\n    }\n\n    bool binary(json::binary_t&amp; val) override\n    {\n        events.push_back(\"binary(val=[...])\");\n        return true;\n    }\n\n    bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex) override\n    {\n        events.push_back(\"parse_error(position=\" + std::to_string(position) + \", last_token=\" + last_token + \",\\n            ex=\" + std::string(ex.what()) + \")\");\n        return false;\n    }\n};\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, -38793],\n            \"DeletionDate\": null,\n            \"Distance\": 12.723374634\n        }\n    }]\n    )\";\n\n    // create a SAX event consumer object\n    sax_event_consumer sec;\n\n    // parse JSON\n    bool result = json::sax_parse(text, &amp;sec);\n\n    // output the recorded events\n    for (auto&amp; event : sec.events)\n    {\n        std::cout &lt;&lt; event &lt;&lt; \"\\n\";\n    }\n\n    // output the result of sax_parse\n    std::cout &lt;&lt; \"\\nresult: \" &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>start_object(elements=18446744073709551615)\nkey(val=Image)\nstart_object(elements=18446744073709551615)\nkey(val=Width)\nnumber_unsigned(val=800)\nkey(val=Height)\nnumber_unsigned(val=600)\nkey(val=Title)\nstring(val=View from 15th Floor)\nkey(val=Thumbnail)\nstart_object(elements=18446744073709551615)\nkey(val=Url)\nstring(val=http://www.example.com/image/481989943)\nkey(val=Height)\nnumber_unsigned(val=125)\nkey(val=Width)\nnumber_unsigned(val=100)\nend_object()\nkey(val=Animated)\nboolean(val=false)\nkey(val=IDs)\nstart_array(elements=18446744073709551615)\nnumber_unsigned(val=116)\nnumber_unsigned(val=943)\nnumber_unsigned(val=234)\nnumber_integer(val=-38793)\nend_array()\nkey(val=DeletionDate)\nnull()\nkey(val=Distance)\nnumber_float(val=12.723375, s=12.723374634)\nend_object()\nend_object()\nparse_error(position=460, last_token=12.723374634&lt;U+000A&gt;        }&lt;U+000A&gt;    }],\n            ex=[json.exception.parse_error.101] parse error at line 17, column 6: syntax error while parsing value - unexpected ']'; expected end of input)\n\nresult: false\n</code></pre>"},{"location":"api/json_sax/string/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.2.0.</li> </ul>"},{"location":"api/macros/","title":"Macros","text":"<p>Some aspects of the library can be configured by defining preprocessor macros before including the <code>json.hpp</code> header. See also the macro overview page.</p>"},{"location":"api/macros/#runtime-assertions","title":"Runtime assertions","text":"<ul> <li>JSON_ASSERT(x) - control behavior of runtime assertions</li> </ul>"},{"location":"api/macros/#exceptions","title":"Exceptions","text":"<ul> <li>JSON_CATCH_USER(exception)JSON_THROW_USER(exception)JSON_TRY_USER - control exceptions</li> <li>JSON_DIAGNOSTICS - control extended diagnostics</li> <li>JSON_DIAGNOSTIC_POSITIONS - access positions of elements</li> <li>JSON_NOEXCEPTION - switch off exceptions</li> </ul>"},{"location":"api/macros/#language-support","title":"Language support","text":"<ul> <li>JSON_HAS_CPP_11JSON_HAS_CPP_14JSON_HAS_CPP_17JSON_HAS_CPP_20 - set supported C++ standard</li> <li>JSON_HAS_FILESYSTEMJSON_HAS_EXPERIMENTAL_FILESYSTEM - control <code>std::filesystem</code> support</li> <li>JSON_HAS_RANGES - control <code>std::ranges</code> support</li> <li>JSON_HAS_THREE_WAY_COMPARISON - control 3-way comparison support</li> <li>JSON_NO_IO - switch off functions relying on certain C++ I/O headers</li> <li>JSON_SKIP_UNSUPPORTED_COMPILER_CHECK - do not warn about unsupported compilers</li> <li>JSON_USE_GLOBAL_UDLS - place user-defined string literals (UDLs) into the global namespace</li> </ul>"},{"location":"api/macros/#library-version","title":"Library version","text":"<ul> <li>JSON_SKIP_LIBRARY_VERSION_CHECK - skip library version check</li> <li>NLOHMANN_JSON_VERSION_MAJORNLOHMANN_JSON_VERSION_MINORNLOHMANN_JSON_VERSION_PATCH   - library version information</li> </ul>"},{"location":"api/macros/#library-namespace","title":"Library namespace","text":"<ul> <li>NLOHMANN_JSON_NAMESPACE - full name of the <code>nlohmann</code> namespace</li> <li>NLOHMANN_JSON_NAMESPACE_BEGINNLOHMANN_JSON_NAMESPACE_END - open and   close the library namespace</li> <li>NLOHMANN_JSON_NAMESPACE_NO_VERSION - disable the version component of   the inline namespace</li> </ul>"},{"location":"api/macros/#type-conversions","title":"Type conversions","text":"<ul> <li>JSON_DISABLE_ENUM_SERIALIZATION - switch off default serialization/deserialization functions for enums</li> <li>JSON_USE_IMPLICIT_CONVERSIONS - control implicit conversions</li> </ul>"},{"location":"api/macros/#comparison-behavior","title":"Comparison behavior","text":"<ul> <li>JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON -   control comparison of discarded values</li> </ul>"},{"location":"api/macros/#serializationdeserialization-macros","title":"Serialization/deserialization macros","text":""},{"location":"api/macros/#enums","title":"Enums","text":"<ul> <li>NLOHMANN_JSON_SERIALIZE_ENUM - serialize/deserialize an enum</li> </ul>"},{"location":"api/macros/#classes-and-structs","title":"Classes and structs","text":"<ul> <li>NLOHMANN_DEFINE_TYPE_INTRUSIVE - serialize/deserialize a non-derived class   with private members</li> <li>NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT - serialize/deserialize a   non-derived class with private members; uses default values</li> <li>NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE - serialize a non-derived class   with private members</li> <li>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE - serialize/deserialize a non-derived   class</li> <li>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT - serialize/deserialize a   non-derived class; uses default values</li> <li> <p>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE - serialize a   non-derived class</p> </li> <li> <p>NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE - serialize/deserialize a derived class   with private members</p> </li> <li>NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT - serialize/deserialize a   derived class with private members; uses default values</li> <li>NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE - serialize a derived   class with private members</li> <li>NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE - serialize/deserialize a derived   class</li> <li>NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT - serialize/deserialize   a derived class; uses default values</li> <li>NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE - serialize a derived   class</li> </ul>"},{"location":"api/macros/json_assert/","title":"JSON_ASSERT","text":"<pre><code>#define JSON_ASSERT(x) /* value */\n</code></pre> <p>This macro controls which code is executed for runtime assertions of the library.</p>"},{"location":"api/macros/json_assert/#parameters","title":"Parameters","text":"<code>x</code> (in) expression of a scalar type"},{"location":"api/macros/json_assert/#default-definition","title":"Default definition","text":"<p>The default value is <code>assert(x)</code>.</p> <pre><code>#define JSON_ASSERT(x) assert(x)\n</code></pre> <p>Therefore, assertions can be switched off by defining <code>NDEBUG</code>.</p>"},{"location":"api/macros/json_assert/#notes","title":"Notes","text":"<ul> <li>The library uses numerous assertions to guarantee invariants and to abort in case of otherwise undefined behavior   (e.g., when calling operator[] with a missing object key on a <code>const</code> object). See   page runtime assertions for more information.</li> <li>Defining the macro to code that does not call <code>std::abort</code> may leave the library in an undefined state.</li> <li>The macro is undefined outside the library.</li> </ul>"},{"location":"api/macros/json_assert/#examples","title":"Examples","text":"Example 1: default behavior <p>The following code will trigger an assertion at runtime:</p> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    const json j = {{\"key\", \"value\"}};\n    auto v = j[\"missing\"];\n}\n</code></pre> <p>Output:</p> <pre><code>Assertion failed: (m_value.object-&gt;find(key) != m_value.object-&gt;end()), function operator[], file json.hpp, line 2144.\n</code></pre> Example 2: user-defined behavior <p>The assertion reporting can be changed by defining <code>JSON_ASSERT(x)</code> differently.</p> <pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#define JSON_ASSERT(x) if(!(x)){fprintf(stderr, \"assertion error in %s\\n\", __FUNCTION__); std::abort();}\n\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    const json j = {{\"key\", \"value\"}};\n    auto v = j[\"missing\"];\n}\n</code></pre> <p>Output:</p> <pre><code>assertion error in operator[]\n</code></pre>"},{"location":"api/macros/json_assert/#see-also","title":"See also","text":"<ul> <li>Runtime Assertions - overview documentation</li> </ul>"},{"location":"api/macros/json_assert/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.9.0.</li> </ul>"},{"location":"api/macros/json_diagnostic_positions/","title":"JSON_DIAGNOSTIC_POSITIONS","text":"<pre><code>#define JSON_DIAGNOSTIC_POSITIONS /* value */\n</code></pre> <p>This macro enables position diagnostics for generated JSON objects.</p> <p>When enabled, two new member functions <code>start_pos()</code> and <code>end_pos()</code> are added to <code>basic_json</code> values. If the value was created by calling the<code>parse</code> function, then these functions allow querying the byte positions of the value in the input it was parsed from. In case the value was constructed by other means, <code>std::string::npos</code> is returned.</p> <p><code>start_pos()</code> returns the position of the first character of a given value in the original JSON string, while <code>end_pos()</code> returns the position of the character following the last character. For objects and arrays, the first and last characters correspond to the opening or closing braces/brackets, respectively. For primitive values, the first and last character represents the opening and closing quotes (strings) or the first and last character of the field's numerical or predefined value (<code>true</code>, <code>false</code>, <code>null</code>), respectively.</p> JSON type return value <code>start_pos()</code> return value <code>end_pos()</code> object position of the opening <code>{</code> position after the closing <code>}</code> array position of the opening <code>[</code> position after the closing <code>]</code> string position of the opening <code>\"</code> position after the closing <code>\"</code> number position of the first character position after the last character boolean position of <code>t</code> for <code>true</code> and <code>f</code> for <code>false</code> position after <code>e</code> null position of <code>n</code> position after <code>l</code> <p>Given the above, <code>end_pos()</code><code>-</code><code>start_pos()</code> for a JSON value provides the length of the parsed JSON string for that value, including the opening or closing braces, brackets, or quotes.</p> <p>Note that enabling this macro increases the size of every JSON value by two <code>std::size_t</code> fields and adds slight runtime overhead to parsing, copying JSON value objects, and the generation of error messages for exceptions. It also causes these values to be reported in those error messages.</p>"},{"location":"api/macros/json_diagnostic_positions/#default-definition","title":"Default definition","text":"<p>The default value is <code>0</code> (position diagnostics are switched off).</p> <pre><code>#define JSON_DIAGNOSTIC_POSITIONS 0\n</code></pre> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/json_diagnostic_positions/#notes","title":"Notes","text":"<p>CMake option</p> <p>Diagnostic positions can also be controlled with the CMake option <code>JSON_Diagnostic_Positions</code> (<code>OFF</code> by default) which defines <code>JSON_DIAGNOSTIC_POSITIONS</code> accordingly.</p> <p>Availability</p> <p>Diagnostic positions are only available if the value was created by the <code>parse</code> function. The <code>sax_parse</code> function or all other means to create a JSON value do not set the diagnostic positions and <code>start_pos()</code> and <code>end_pos()</code> will only return <code>std::string::npos</code> for these values.</p> <p>Invalidation</p> <p>The returned positions are only valid as long as the JSON value is not changed. The positions are not updated when the JSON value is changed.</p>"},{"location":"api/macros/json_diagnostic_positions/#examples","title":"Examples","text":"Example: retrieving positions <pre><code>#include &lt;iostream&gt;\n\n#define JSON_DIAGNOSTIC_POSITIONS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string json_string = R\"(\n    {\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\n    )\";\n    json j = json::parse(json_string);\n\n    std::cout &lt;&lt; \"Root diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos: \" &lt;&lt; j.start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j.end_pos() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"{\\n        \\\"address\\\": {\\n            \\\"street\\\": \\\"Fake Street\\\",\\n            \\\"housenumber\\\": 1\\n        }\\n    }\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j.start_pos(), j.end_pos() - j.start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"address diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"{            \\\"street\\\": \\\"Fake Street\\\",\\n            \\\"housenumber\\\": 1\\n        }\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"].start_pos(), j[\"address\"].end_pos() - j[\"address\"].start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"street diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"][\"street\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"][\"street\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"\\\"Fake Street\\\"\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"][\"street\"].start_pos(), j[\"address\"][\"street\"].end_pos() - j[\"address\"][\"street\"].start_pos()) &lt;&lt; \"\\n\\n\";\n\n    std::cout &lt;&lt; \"housenumber diagnostic positions: \\n\";\n    std::cout &lt;&lt; \"\\tstart_pos:\" &lt;&lt; j[\"address\"][\"housenumber\"].start_pos() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"\\tend_pos:\" &lt;&lt; j[\"address\"][\"housenumber\"].end_pos() &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"Original string: \\n\";\n    std::cout &lt;&lt; \"1\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed string: \\n\";\n    std::cout &lt;&lt; json_string.substr(j[\"address\"][\"housenumber\"].start_pos(), j[\"address\"][\"housenumber\"].end_pos() - j[\"address\"][\"housenumber\"].start_pos()) &lt;&lt; \"\\n\\n\";\n}\n</code></pre> <p>Output:</p> <pre><code>Root diagnostic positions: \n    start_pos: 5\n    end_pos:109\nOriginal string: \n{\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\nParsed string: \n{\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n    }\n\naddress diagnostic positions: \n    start_pos:26\n    end_pos:103\n\nOriginal string: \n{            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\nParsed string: \n{\n            \"street\": \"Fake Street\",\n            \"housenumber\": 1\n        }\n\nstreet diagnostic positions: \n    start_pos:50\n    end_pos:63\n\nOriginal string: \n\"Fake Street\"\nParsed string: \n\"Fake Street\"\n\nhousenumber diagnostic positions: \n    start_pos:92\n    end_pos:93\n\nOriginal string: \n1\nParsed string: \n1\n</code></pre> <p>The output shows the start/end positions of all the objects and fields in the JSON string.</p> Example 2: using only diagnostic positions in exceptions <pre><code>#include &lt;iostream&gt;\n\n#define JSON_DIAGNOSTIC_POSITIONS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n/* Demonstration of type error exception with diagnostic positions support enabled */\nint main()\n{\n    //Invalid json string - housenumber type must be int instead of string\n    const std::string json_invalid_string = R\"(\n    {\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": \"1\"\n        }\n    }\n    )\";\n    json j = json::parse(json_invalid_string);\n    try\n    {\n        int housenumber = j[\"address\"][\"housenumber\"];\n        std::cout &lt;&lt; housenumber;\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.type_error.302] (bytes 92-95) type must be number, but is string\n</code></pre> <pre><code>The output shows the exception with start/end positions only.\n</code></pre> Example 3: using extended diagnostics with positions enabled in exceptions <pre><code>#include &lt;iostream&gt;\n\n#define JSON_DIAGNOSTICS 1\n#define JSON_DIAGNOSTIC_POSITIONS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n/* Demonstration of type error exception with diagnostic positions support enabled */\nint main()\n{\n    //Invalid json string - housenumber type must be int instead of string\n    const std::string json_invalid_string = R\"(\n    {\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": \"1\"\n        }\n    }\n    )\";\n    json j = json::parse(json_invalid_string);\n    try\n    {\n        int housenumber = j[\"address\"][\"housenumber\"];\n        std::cout &lt;&lt; housenumber;\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.type_error.302] (/address/housenumber) (bytes 92-95) type must be number, but is string\n</code></pre> <pre><code>The output shows the exception with diagnostic path info and start/end positions.\n</code></pre>"},{"location":"api/macros/json_diagnostic_positions/#see-also","title":"See also","text":"<ul> <li> JSON_Diagnostic_Positions - CMake option to control the macro</li> <li>JSON_DIAGNOSTICS - macro to control extended diagnostics</li> </ul>"},{"location":"api/macros/json_diagnostic_positions/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.12.0.</li> </ul>"},{"location":"api/macros/json_diagnostics/","title":"JSON_DIAGNOSTICS","text":"<pre><code>#define JSON_DIAGNOSTICS /* value */\n</code></pre> <p>This macro enables extended diagnostics for exception messages. Possible values are <code>1</code> to enable or <code>0</code> to disable (default).</p> <p>When enabled, exception messages contain a JSON Pointer to the JSON value that triggered the exception. Note that enabling this macro increases the size of every JSON value by one pointer and adds some runtime overhead.</p>"},{"location":"api/macros/json_diagnostics/#default-definition","title":"Default definition","text":"<p>The default value is <code>0</code> (extended diagnostics are switched off).</p> <pre><code>#define JSON_DIAGNOSTICS 0\n</code></pre> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/json_diagnostics/#notes","title":"Notes","text":"<p>ABI compatibility</p> <p>As of version 3.11.0, this macro is no longer required to be defined consistently throughout a codebase to avoid One Definition Rule (ODR) violations, as the value of this macro is encoded in the namespace, resulting in distinct symbol names. </p> <p>This allows different parts of a codebase to use different versions or configurations of this library without causing improper behavior.</p> <p>Where possible, it is still recommended that all code define this the same way for maximum interoperability.</p> <p>CMake option</p> <p>Diagnostic messages can also be controlled with the CMake option <code>JSON_Diagnostics</code> (<code>OFF</code> by default) which defines <code>JSON_DIAGNOSTICS</code> accordingly.</p>"},{"location":"api/macros/json_diagnostics/#examples","title":"Examples","text":"Example 1: default behavior <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j;\n    j[\"address\"][\"street\"] = \"Fake Street\";\n    j[\"address\"][\"housenumber\"] = \"12\";\n\n    try\n    {\n        int housenumber = j[\"address\"][\"housenumber\"];\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.type_error.302] type must be number, but is string\n</code></pre> <p>This exception can be hard to debug if storing the value <code>\"12\"</code> and accessing it is further apart.</p> Example 2: extended diagnostic messages <pre><code>#include &lt;iostream&gt;\n\n# define JSON_DIAGNOSTICS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j;\n    j[\"address\"][\"street\"] = \"Fake Street\";\n    j[\"address\"][\"housenumber\"] = \"12\";\n\n    try\n    {\n        int housenumber = j[\"address\"][\"housenumber\"];\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.type_error.302] (/address/housenumber) type must be number, but is string\n</code></pre> <p>Now the exception message contains a JSON Pointer <code>/address/housenumber</code> that indicates which value has the wrong type.</p> Example 3: using only diagnostic positions in exceptions <pre><code>#include &lt;iostream&gt;\n\n#define JSON_DIAGNOSTIC_POSITIONS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\n/* Demonstration of type error exception with diagnostic positions support enabled */\nint main()\n{\n    //Invalid json string - housenumber type must be int instead of string\n    const std::string json_invalid_string = R\"(\n    {\n        \"address\": {\n            \"street\": \"Fake Street\",\n            \"housenumber\": \"1\"\n        }\n    }\n    )\";\n    json j = json::parse(json_invalid_string);\n    try\n    {\n        int housenumber = j[\"address\"][\"housenumber\"];\n        std::cout &lt;&lt; housenumber;\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <p><pre><code>[json.exception.type_error.302] (bytes 92-95) type must be number, but is string\n</code></pre>     The output shows the exception with start/end positions only.</p>"},{"location":"api/macros/json_diagnostics/#see-also","title":"See also","text":"<ul> <li> JSON_Diagnostics - CMake option to control the macro</li> <li>JSON_DIAGNOSTIC_POSITIONS - macro to access positions of elements</li> </ul>"},{"location":"api/macros/json_diagnostics/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.10.0.</li> <li>As of version 3.11.0, the definition is allowed to vary between translation units.</li> </ul>"},{"location":"api/macros/json_disable_enum_serialization/","title":"JSON_DISABLE_ENUM_SERIALIZATION","text":"<pre><code>#define JSON_DISABLE_ENUM_SERIALIZATION /* value */\n</code></pre> <p>When defined to <code>1</code>, default serialization and deserialization functions for enums are excluded and have to be provided by the user, for example, using <code>NLOHMANN_JSON_SERIALIZE_ENUM</code> (see arbitrary type conversions for more details).</p> <p>Parsing or serializing an enum will result in a compiler error.</p> <p>This works for both unscoped and scoped enums.</p>"},{"location":"api/macros/json_disable_enum_serialization/#default-definition","title":"Default definition","text":"<p>The default value is <code>0</code>.</p> <pre><code>#define JSON_DISABLE_ENUM_SERIALIZATION 0\n</code></pre>"},{"location":"api/macros/json_disable_enum_serialization/#notes","title":"Notes","text":"<p>CMake option</p> <p>Enum serialization can also be controlled with the CMake option <code>JSON_DisableEnumSerialization</code> (<code>OFF</code> by default) which defines <code>JSON_DISABLE_ENUM_SERIALIZATION</code> accordingly.</p>"},{"location":"api/macros/json_disable_enum_serialization/#examples","title":"Examples","text":"Example 1: Disabled behavior <p>The code below forces the library not to create default serialization/deserialization functions <code>from_json</code> and <code>to_json</code>, meaning the code below does not compile.</p> <pre><code>#define JSON_DISABLE_ENUM_SERIALIZATION 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nenum class Choice\n{\n    first,\n    second,\n};\n\nint main()\n{\n    // normally invokes to_json serialization function but with JSON_DISABLE_ENUM_SERIALIZATION defined, it does not\n    const json j = Choice::first; \n\n    // normally invokes from_json parse function but with JSON_DISABLE_ENUM_SERIALIZATION defined, it does not\n    Choice ch = j.template get&lt;Choice&gt;();\n}\n</code></pre> Example 2: Serialize enum macro <p>The code below forces the library not to create default serialization/deserialization functions <code>from_json</code> and <code>to_json</code>, but uses <code>NLOHMANN_JSON_SERIALIZE_ENUM</code> to parse and serialize the enum.</p> <pre><code>#define JSON_DISABLE_ENUM_SERIALIZATION 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nenum class Choice\n{\n    first,\n    second,\n};\n\nNLOHMANN_JSON_SERIALIZE_ENUM(Choice,\n{\n    { Choice::first, \"first\" },\n    { Choice::second, \"second\" },\n})\n\nint main()\n{\n    // uses user-defined to_json function defined by macro\n    const json j = Choice::first; \n\n    // uses user-defined from_json function defined by macro\n    Choice ch = j.template get&lt;Choice&gt;();\n}\n</code></pre> Example 3: User-defined serialization/deserialization functions <p>The code below forces the library not to create default serialization/deserialization functions <code>from_json</code> and <code>to_json</code>, but uses user-defined functions to parse and serialize the enum.</p> <pre><code>#define JSON_DISABLE_ENUM_SERIALIZATION 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nenum class Choice\n{\n    first,\n    second,\n};\n\nvoid from_json(const json&amp; j, Choice&amp; ch)\n{\n    auto value = j.template get&lt;std::string&gt;();\n    if (value == \"first\")\n    {\n        ch = Choice::first;\n    }\n    else if (value == \"second\")\n    {\n        ch = Choice::second;\n    }\n}\n\nvoid to_json(json&amp; j, const Choice&amp; ch)\n{\n    auto value = j.template get&lt;std::string&gt;();\n    if (value == \"first\")\n    {\n        ch = Choice::first;\n    }\n    else if (value == \"second\")\n    {\n        ch = Choice::second;\n    }\n}\n\nint main()\n{\n    // uses user-defined to_json function\n    const json j = Choice::first; \n\n    // uses user-defined from_json function\n    Choice ch = j.template get&lt;Choice&gt;();\n}\n</code></pre>"},{"location":"api/macros/json_disable_enum_serialization/#see-also","title":"See also","text":"<ul> <li> JSON_DisableEnumSerialization - CMake option to control   the macro</li> <li><code>NLOHMANN_JSON_SERIALIZE_ENUM</code> - serialize/deserialize an enum</li> </ul>"},{"location":"api/macros/json_disable_enum_serialization/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/macros/json_has_cpp_11/","title":"JSON_HAS_CPP_11, JSON_HAS_CPP_14, JSON_HAS_CPP_17, JSON_HAS_CPP_20","text":"<pre><code>#define JSON_HAS_CPP_11\n#define JSON_HAS_CPP_14\n#define JSON_HAS_CPP_17\n#define JSON_HAS_CPP_20\n</code></pre> <p>The library targets C++11, but also supports some features introduced in later C++ versions (e.g., <code>std::string_view</code> support for C++17). For these new features, the library implements some preprocessor checks to determine the C++ standard. By defining any of these symbols, the internal check is overridden and the provided C++ version is unconditionally assumed. This can be helpful for compilers that only implement parts of the standard and would be detected incorrectly.</p>"},{"location":"api/macros/json_has_cpp_11/#default-definition","title":"Default definition","text":"<p>The default value is detected based on preprocessor macros such as <code>__cplusplus</code>, <code>_HAS_CXX17</code>, or <code>_MSVC_LANG</code>.</p>"},{"location":"api/macros/json_has_cpp_11/#notes","title":"Notes","text":"<ul> <li><code>JSON_HAS_CPP_11</code> is always defined.</li> <li>All macros are undefined outside the library.</li> </ul>"},{"location":"api/macros/json_has_cpp_11/#examples","title":"Examples","text":"Example <p>The code below forces the library to use the C++14 standard:</p> <pre><code>#define JSON_HAS_CPP_14 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_has_cpp_11/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.10.5.</li> </ul>"},{"location":"api/macros/json_has_filesystem/","title":"JSON_HAS_FILESYSTEM / JSON_HAS_EXPERIMENTAL_FILESYSTEM","text":"<pre><code>#define JSON_HAS_FILESYSTEM /* value */\n#define JSON_HAS_EXPERIMENTAL_FILESYSTEM /* value */\n</code></pre> <p>When compiling with C++17, the library provides conversions from and to <code>std::filesystem::path</code>. As compiler support for filesystem is limited, the library tries to detect whether <code>&lt;filesystem&gt;</code>/<code>std::filesystem</code> (<code>JSON_HAS_FILESYSTEM</code>) or <code>&lt;experimental/filesystem&gt;</code>/<code>std::experimental::filesystem</code> (<code>JSON_HAS_EXPERIMENTAL_FILESYSTEM</code>) should be used. To override the built-in check, define <code>JSON_HAS_FILESYSTEM</code> or <code>JSON_HAS_EXPERIMENTAL_FILESYSTEM</code> to <code>1</code>.</p>"},{"location":"api/macros/json_has_filesystem/#default-definition","title":"Default definition","text":"<p>The default value is detected based on the preprocessor macros <code>__cpp_lib_filesystem</code>, <code>__cpp_lib_experimental_filesystem</code>, <code>__has_include(&lt;filesystem&gt;)</code>, or <code>__has_include(&lt;experimental/filesystem&gt;)</code>.</p>"},{"location":"api/macros/json_has_filesystem/#notes","title":"Notes","text":"<ul> <li>Note that older compilers or older versions of libstd++ also require the library <code>stdc++fs</code> to be linked to for   filesystem support.</li> <li>Both macros are undefined outside the library.</li> </ul>"},{"location":"api/macros/json_has_filesystem/#examples","title":"Examples","text":"Example <p>The code below forces the library to use the header <code>&lt;experimental/filesystem&gt;</code>.</p> <pre><code>#define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_has_filesystem/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.10.5.</li> </ul>"},{"location":"api/macros/json_has_ranges/","title":"JSON_HAS_RANGES","text":"<pre><code>#define JSON_HAS_RANGES /* value */\n</code></pre> <p>This macro indicates whether the standard library has any support for ranges. Implies support for concepts. Possible values are <code>1</code> when supported or <code>0</code> when unsupported.</p>"},{"location":"api/macros/json_has_ranges/#default-definition","title":"Default definition","text":"<p>The default value is detected based on the preprocessor macro <code>__cpp_lib_ranges</code>.</p> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/json_has_ranges/#examples","title":"Examples","text":"Example <p>The code below forces the library to enable support for ranges:</p> <pre><code>#define JSON_HAS_RANGES 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_has_ranges/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/macros/json_has_static_rtti/","title":"JSON_HAS_STATIC_RTTI","text":"<pre><code>#define JSON_HAS_STATIC_RTTI /* value */\n</code></pre> <p>This macro indicates whether the standard library has any support for RTTI (run time type information). Possible values are <code>1</code> when supported or <code>0</code> when unsupported.</p>"},{"location":"api/macros/json_has_static_rtti/#default-definition","title":"Default definition","text":"<p>The default value is detected based on the preprocessor macro <code>_HAS_STATIC_RTTI</code>.</p> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/json_has_static_rtti/#examples","title":"Examples","text":"Example <p>The code below forces the library to enable support for libraries with RTTI dependence:</p> <pre><code>#define JSON_HAS_STATIC_RTTI 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_has_static_rtti/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.3.</li> </ul>"},{"location":"api/macros/json_has_three_way_comparison/","title":"JSON_HAS_THREE_WAY_COMPARISON","text":"<pre><code>#define JSON_HAS_THREE_WAY_COMPARISON /* value */\n</code></pre> <p>This macro indicates whether the compiler and standard library support 3-way comparison. Possible values are <code>1</code> when supported or <code>0</code> when unsupported.</p>"},{"location":"api/macros/json_has_three_way_comparison/#default-definition","title":"Default definition","text":"<p>The default value is detected based on the preprocessor macros <code>__cpp_impl_three_way_comparison</code> and <code>__cpp_lib_three_way_comparison</code>.</p> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/json_has_three_way_comparison/#examples","title":"Examples","text":"Example <p>The code below forces the library to use 3-way comparison:</p> <pre><code>#define JSON_HAS_THREE_WAY_COMPARISON 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_has_three_way_comparison/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/macros/json_no_io/","title":"JSON_NO_IO","text":"<pre><code>#define JSON_NO_IO\n</code></pre> <p>When defined, headers <code>&lt;cstdio&gt;</code>, <code>&lt;ios&gt;</code>, <code>&lt;iosfwd&gt;</code>, <code>&lt;istream&gt;</code>, and <code>&lt;ostream&gt;</code> are not included and parse functions relying on these headers are excluded. This is relevant for environments where these I/O functions are disallowed for security reasons (e.g., Intel Software Guard Extensions (SGX)).</p>"},{"location":"api/macros/json_no_io/#default-definition","title":"Default definition","text":"<p>By default, <code>JSON_NO_IO</code> is not defined.</p> <pre><code>#undef JSON_NO_IO\n</code></pre>"},{"location":"api/macros/json_no_io/#examples","title":"Examples","text":"Example <p>The code below forces the library not to use the headers <code>&lt;cstdio&gt;</code>, <code>&lt;ios&gt;</code>, <code>&lt;iosfwd&gt;</code>, <code>&lt;istream&gt;</code>, and <code>&lt;ostream&gt;</code>.</p> <pre><code>#define JSON_NO_IO 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_no_io/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.10.0.</li> </ul>"},{"location":"api/macros/json_noexception/","title":"JSON_NOEXCEPTION","text":"<pre><code>#define JSON_NOEXCEPTION\n</code></pre> <p>Exceptions can be switched off by defining the symbol <code>JSON_NOEXCEPTION</code>. When defining <code>JSON_NOEXCEPTION</code>, <code>try</code> is replaced by <code>if (true)</code>, <code>catch</code> is replaced by <code>if (false)</code>, and <code>throw</code> is replaced by <code>std::abort()</code>.</p> <p>The same effect is achieved by setting the compiler flag <code>-fno-exceptions</code>.</p>"},{"location":"api/macros/json_noexception/#default-definition","title":"Default definition","text":"<p>By default, the macro is not defined.</p> <pre><code>#undef JSON_NOEXCEPTION\n</code></pre>"},{"location":"api/macros/json_noexception/#notes","title":"Notes","text":"<p>The explanatory <code>what()</code> string of exceptions is not available for MSVC if exceptions are disabled, see #2824.</p>"},{"location":"api/macros/json_noexception/#examples","title":"Examples","text":"Example <p>The code below switches off exceptions in the library.</p> <pre><code>#define JSON_NOEXCEPTION 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_noexception/#see-also","title":"See also","text":"<ul> <li>Switch off exceptions for more information how to switch off exceptions</li> </ul>"},{"location":"api/macros/json_noexception/#version-history","title":"Version history","text":"<p>Added in version 2.1.0.</p>"},{"location":"api/macros/json_skip_library_version_check/","title":"JSON_SKIP_LIBRARY_VERSION_CHECK","text":"<pre><code>#define JSON_SKIP_LIBRARY_VERSION_CHECK\n</code></pre> <p>When defined, the library will not create a compiler warning when a different version of the library was already included.</p>"},{"location":"api/macros/json_skip_library_version_check/#default-definition","title":"Default definition","text":"<p>By default, the macro is not defined.</p> <pre><code>#undef JSON_SKIP_LIBRARY_VERSION_CHECK\n</code></pre>"},{"location":"api/macros/json_skip_library_version_check/#notes","title":"Notes","text":"<p>ABI compatibility</p> <p>Mixing different library versions in the same code can be a problem as the different versions may not be ABI compatible.</p>"},{"location":"api/macros/json_skip_library_version_check/#examples","title":"Examples","text":"<p>Example</p> <p>The following warning will be shown in case a different version of the library was already included:</p> <pre><code>Already included a different version of the library!\n</code></pre>"},{"location":"api/macros/json_skip_library_version_check/#version-history","title":"Version history","text":"<p>Added in version 3.11.0.</p>"},{"location":"api/macros/json_skip_unsupported_compiler_check/","title":"JSON_SKIP_UNSUPPORTED_COMPILER_CHECK","text":"<pre><code>#define JSON_SKIP_UNSUPPORTED_COMPILER_CHECK\n</code></pre> <p>When defined, the library will not create a compile error when a known unsupported compiler is detected. This allows  using the library with compilers that do not fully support C++11 and may only work if unsupported features are not used.</p>"},{"location":"api/macros/json_skip_unsupported_compiler_check/#default-definition","title":"Default definition","text":"<p>By default, the macro is not defined.</p> <pre><code>#undef JSON_SKIP_UNSUPPORTED_COMPILER_CHECK\n</code></pre>"},{"location":"api/macros/json_skip_unsupported_compiler_check/#examples","title":"Examples","text":"Example <p>The code below switches off the check whether the compiler is supported.</p> <pre><code>#define JSON_SKIP_UNSUPPORTED_COMPILER_CHECK 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_skip_unsupported_compiler_check/#version-history","title":"Version history","text":"<p>Added in version 3.2.0.</p>"},{"location":"api/macros/json_throw_user/","title":"JSON_CATCH_USER, JSON_THROW_USER, JSON_TRY_USER","text":"<pre><code>// (1)\n#define JSON_CATCH_USER(exception) /* value */\n// (2)\n#define JSON_THROW_USER(exception) /* value */\n// (3)\n#define JSON_TRY_USER /* value */\n</code></pre> <p>Controls how exceptions are handled by the library.</p> <ol> <li>This macro overrides <code>catch</code> calls inside the library.    The argument is the type of the exception to catch. As of version 3.8.0, the library only catches <code>std::out_of_range</code>    exceptions internally to rethrow them as <code>json::out_of_range</code> exceptions.    The macro is always followed by a scope.</li> <li>This macro overrides <code>throw</code> calls inside the library. The argument is the exception to be thrown. Note that    <code>JSON_THROW_USER</code> should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield    undefined behavior.</li> <li>This macro overrides <code>try</code> calls inside the library. It has no arguments and is always followed by a scope.</li> </ol>"},{"location":"api/macros/json_throw_user/#parameters","title":"Parameters","text":"<code>exception</code> (in) an exception type"},{"location":"api/macros/json_throw_user/#default-definition","title":"Default definition","text":"<p>By default, the macros map to their respective C++ keywords:</p> <pre><code>#define JSON_CATCH_USER(exception) catch(exception)\n#define JSON_THROW_USER(exception) throw exception\n#define JSON_TRY_USER              try\n</code></pre> <p>When exceptions are switched off, the <code>try</code> block is executed unconditionally, and throwing exceptions is replaced by calling <code>std::abort</code> to make reaching the <code>throw</code> branch abort the process.</p> <pre><code>#define JSON_THROW_USER(exception) std::abort()\n#define JSON_TRY_USER              if (true)\n#define JSON_CATCH_USER(exception) if (false)\n</code></pre>"},{"location":"api/macros/json_throw_user/#examples","title":"Examples","text":"Example <p>The code below switches off exceptions and creates a log entry with a detailed error message in case of errors.</p> <pre><code>#include &lt;iostream&gt;\n\n#define JSON_TRY_USER if(true)\n#define JSON_CATCH_USER(exception) if(false)\n#define JSON_THROW_USER(exception)                           \\\n    {std::clog &lt;&lt; \"Error in \" &lt;&lt; __FILE__ &lt;&lt; \":\" &lt;&lt; __LINE__ \\\n               &lt;&lt; \" (function \" &lt;&lt; __FUNCTION__ &lt;&lt; \") - \"    \\\n               &lt;&lt; (exception).what() &lt;&lt; std::endl;           \\\n     std::abort();}\n\n#include &lt;nlohmann/json.hpp&gt;\n</code></pre>"},{"location":"api/macros/json_throw_user/#see-also","title":"See also","text":"<ul> <li>Switch off exceptions for more information how to switch off exceptions</li> <li>JSON_NOEXCEPTION - switch off exceptions</li> </ul>"},{"location":"api/macros/json_throw_user/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.1.0.</li> </ul>"},{"location":"api/macros/json_use_global_udls/","title":"JSON_USE_GLOBAL_UDLS","text":"<pre><code>#define JSON_USE_GLOBAL_UDLS /* value */\n</code></pre> <p>When defined to <code>1</code>, the user-defined string literals (UDLs) are placed into the global namespace instead of <code>nlohmann::literals::json_literals</code>.</p>"},{"location":"api/macros/json_use_global_udls/#default-definition","title":"Default definition","text":"<p>The default value is <code>1</code>.</p> <pre><code>#define JSON_USE_GLOBAL_UDLS 1\n</code></pre> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/json_use_global_udls/#notes","title":"Notes","text":"<p>Future behavior change</p> <p>The user-defined string literals will be removed from the global namespace in the next major release of the library.</p> <p>To prepare existing code, define <code>JSON_USE_GLOBAL_UDLS</code> to <code>0</code> and bring the string literals into scope where needed. Refer to any of the string literals for details.</p> <p>CMake option</p> <p>The placement of user-defined string literals can also be controlled with the CMake option <code>JSON_GlobalUDLs</code> (<code>ON</code> by default) which defines <code>JSON_USE_GLOBAL_UDLS</code> accordingly.</p>"},{"location":"api/macros/json_use_global_udls/#examples","title":"Examples","text":"Example 1: Default behavior <p>The code below shows the default behavior using the <code>_json</code> UDL.</p> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n\n#include &lt;iostream&gt;\n\nint main()\n{\n    auto j = \"42\"_json;\n\n    std::cout &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>42\n</code></pre> Example 2: Namespaced UDLs <p>The code below shows how UDLs need to be brought into scope before using <code>_json</code> when <code>JSON_USE_GLOBAL_UDLS</code> is defined to <code>0</code>.</p> <pre><code>#define JSON_USE_GLOBAL_UDLS 0\n#include &lt;nlohmann/json.hpp&gt;\n\n#include &lt;iostream&gt;\n\nint main()\n{\n    // auto j = \"42\"_json; // This line would fail to compile,\n                           // because the UDLs are not in the global namespace\n\n    // Bring the UDLs into scope\n    using namespace nlohmann::json_literals;\n\n    auto j = \"42\"_json;\n\n    std::cout &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>42\n</code></pre>"},{"location":"api/macros/json_use_global_udls/#see-also","title":"See also","text":"<ul> <li><code>operator\"\"_json</code></li> <li><code>operator\"\"_json_pointer</code></li> <li> JSON_GlobalUDLs - CMake option to control the macro</li> </ul>"},{"location":"api/macros/json_use_global_udls/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/macros/json_use_implicit_conversions/","title":"JSON_USE_IMPLICIT_CONVERSIONS","text":"<pre><code>#define JSON_USE_IMPLICIT_CONVERSIONS /* value */\n</code></pre> <p>When defined to <code>0</code>, implicit conversions are switched off. By default, implicit conversions are switched on. The value directly affects <code>operator ValueType</code>.</p>"},{"location":"api/macros/json_use_implicit_conversions/#default-definition","title":"Default definition","text":"<p>By default, implicit conversions are enabled.</p> <pre><code>#define JSON_USE_IMPLICIT_CONVERSIONS 1\n</code></pre>"},{"location":"api/macros/json_use_implicit_conversions/#notes","title":"Notes","text":"<p>Future behavior change</p> <p>Implicit conversions will be switched off by default in the next major release of the library.</p> <p>You can prepare existing code by already defining <code>JSON_USE_IMPLICIT_CONVERSIONS</code> to <code>0</code> and replace any implicit conversions with calls to <code>get</code>.</p> <p>CMake option</p> <p>Implicit conversions can also be controlled with the CMake option <code>JSON_ImplicitConversions</code> (<code>ON</code> by default) which defines <code>JSON_USE_IMPLICIT_CONVERSIONS</code> accordingly.</p>"},{"location":"api/macros/json_use_implicit_conversions/#examples","title":"Examples","text":"Example <p>This is an example for an implicit conversion:</p> <pre><code>json j = \"Hello, world!\";\nstd::string s = j;\n</code></pre> <p>When <code>JSON_USE_IMPLICIT_CONVERSIONS</code> is defined to <code>0</code>, the code above does no longer compile. Instead, it must be written like this:</p> <pre><code>json j = \"Hello, world!\";\nauto s = j.template get&lt;std::string&gt;();\n</code></pre>"},{"location":"api/macros/json_use_implicit_conversions/#see-also","title":"See also","text":"<ul> <li>operator ValueType - get a value (implicit)</li> <li>get - get a value (explicit)</li> <li> JSON_ImplicitConversions - CMake option to control the macro</li> </ul>"},{"location":"api/macros/json_use_implicit_conversions/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.9.0.</li> </ul>"},{"location":"api/macros/json_use_legacy_discarded_value_comparison/","title":"JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON","text":"<pre><code>#define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON /* value */\n</code></pre> <p>This macro enables the (incorrect) legacy comparison behavior of discarded JSON values. Possible values are <code>1</code> to enable or <code>0</code> to disable (default).</p> <p>When enabled, comparisons involving at least one discarded JSON value yield results as follows:</p> Operator Result <code>==</code> <code>false</code> <code>!=</code> <code>true</code> <code>&lt;</code> <code>false</code> <code>&lt;=</code> <code>true</code> <code>&gt;=</code> <code>true</code> <code>&gt;</code> <code>false</code> <p>Otherwise, comparisons involving at least one discarded JSON value always yield <code>false</code>.</p>"},{"location":"api/macros/json_use_legacy_discarded_value_comparison/#default-definition","title":"Default definition","text":"<p>The default value is <code>0</code>.</p> <pre><code>#define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0\n</code></pre> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/json_use_legacy_discarded_value_comparison/#notes","title":"Notes","text":"<p>Inconsistent behavior in C++20 and beyond</p> <p>When targeting C++20 or above, enabling the legacy comparison behavior is strongly discouraged.</p> <ul> <li>The 3-way comparison operator (<code>&lt;=&gt;</code>) will always give the correct result     (<code>std::partial_ordering::unordered</code>) regardless of the value of     <code>JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON</code>.</li> <li>Overloads for the equality and relational operators emulate the legacy behavior.</li> </ul> <p>Code outside your control may use either 3-way comparison or the equality and relational operators, resulting in inconsistent and unpredictable behavior.</p> <p>See <code>operator&lt;=&gt;</code> for more information on 3-way comparison.</p> <p>Deprecation</p> <p>The legacy comparison behavior is deprecated and may be removed in a future major version release.</p> <p>New code should not depend on it and existing code should try to remove or rewrite expressions relying on it.</p> <p>CMake option</p> <p>Legacy comparison can also be controlled with the CMake option <code>JSON_LegacyDiscardedValueComparison</code> (<code>OFF</code> by default) which defines <code>JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON</code> accordingly.</p>"},{"location":"api/macros/json_use_legacy_discarded_value_comparison/#examples","title":"Examples","text":"Example <p>The code below switches on the legacy discarded value comparison behavior in the library.</p> <pre><code>#define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 1\n#include &lt;nlohmann/json.hpp&gt;\n\n...\n</code></pre>"},{"location":"api/macros/json_use_legacy_discarded_value_comparison/#see-also","title":"See also","text":"<ul> <li> JSON_LegacyDiscardedValueComparison - CMake option to control the macro</li> </ul>"},{"location":"api/macros/json_use_legacy_discarded_value_comparison/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0.</li> </ul>"},{"location":"api/macros/nlohmann_define_derived_type/","title":"NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE, NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT, NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE, NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE, NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT, NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE","text":"NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE, NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT,     NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE, NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE,     NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT, NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE <pre><code>// (1)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE(type, base_type, member...)\n// (2)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT(type, base_type, member...)\n// (3)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE(type, base_type, member...)\n\n// (4)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE(type, base_type, member...)\n// (5)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT(type, base_type, member...)\n// (6)\n#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(type, base_type, member...)\n</code></pre> <p>These macros can be used to simplify the serialization/deserialization of derived types if you want to use a JSON object as serialization and want to use the member variable names as object keys in that object.</p> <ul> <li>Macros 1, 2, and 3 are to be defined inside the class/struct to create code for. Like <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code>, they can access private members.</li> <li>Macros 4, 5, and 6 are to be defined outside the class/struct to create code for, but inside its namespace. Like <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</code>, they cannot access private members.</li> </ul> <p>The first parameter is the name of the derived class/struct, the second parameter is the name of the base class/struct and all remaining parameters name the members. The base type must be already serializable/deserializable.</p> <ul> <li>Macros 1 and 4 will use <code>at</code> during deserialization and will throw   <code>out_of_range.403</code> if a key is missing in the JSON object.</li> <li>Macros 2 and 5 will use <code>value</code> during deserialization and fall back to the default value for the    respective type of the member variable if a key in the JSON object is missing. The generated <code>from_json()</code> function    default constructs an object and uses its values as the defaults when calling the <code>value</code> function.</li> </ul> <p>Summary:</p> Need access to private members Need only de-serialization Allow missing values when de-serializing macro NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE"},{"location":"api/macros/nlohmann_define_derived_type/#parameters","title":"Parameters","text":"<code>type</code> (in) name of the type (class, struct) to serialize/deserialize <code>base_type</code> (in) name of the base type (class, struct) <code>type</code> is derived from <code>member</code> (in) name of the member variable to serialize/deserialize; up to 64 members can be given as a comma-separated list"},{"location":"api/macros/nlohmann_define_derived_type/#default-definition","title":"Default definition","text":"<p>Macros 1 and 2 add two friend functions to the class which take care of the serialization and deserialization:</p> <pre><code>template&lt;typename BasicJsonType&gt;\nfriend void to_json(BasicJsonType&amp;, const type&amp;);\ntemplate&lt;typename BasicJsonType&gt;\nfriend void from_json(const BasicJsonType&amp;, type&amp;);\n</code></pre> <p>Macros 4 and 5 add two functions to the namespace which take care of the serialization and deserialization:</p> <pre><code>template&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp;, const type&amp;);\ntemplate&lt;typename BasicJsonType&gt;\nvoid from_json(const BasicJsonType&amp;, type&amp;);\n</code></pre> <p>Macros 3 and 6 add one function to the namespace, which takes care of the serialization only:</p> <pre><code>template&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp;, const type&amp;);\n</code></pre> <p>In first two cases, they call the <code>to_json</code>/<code>from_json</code> functions of the base type before serializing/deserializing the members of the derived type:</p> <pre><code>class A { /* ... */ };\nclass B : public A { /* ... */ };\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp; j, const B&amp; b) {\n    nlohmann::to_json(j, static_cast&lt;const A&amp;&gt;(b));\n    // ...\n}\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid from_json(const BasicJsonType&amp; j, B&amp; b) {\n    nlohmann::from_json(j, static_cast&lt;A&amp;&gt;(b));\n    // ...\n}\n</code></pre> <p>In the third case, only <code>to_json</code> will be called:</p> <pre><code>class A { /* ... */ };\nclass B : public A { /* ... */ };\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp; j, const B&amp; b) {\n    nlohmann::to_json(j, static_cast&lt;const A&amp;&gt;(b));\n    // ...\n}\n</code></pre>"},{"location":"api/macros/nlohmann_define_derived_type/#notes","title":"Notes","text":"<p>Prerequisites</p> <ul> <li>Macros 1, 2, and 3 have the same prerequisites of NLOHMANN_DEFINE_TYPE_INTRUSIVE.</li> <li>Macros 4, 5, and 6 have the same prerequisites of NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE.</li> <li>Serialization/deserialization of base types must be defined.</li> </ul> <p>Implementation limits</p> <p>See Implementation limits for NLOHMANN_DEFINE_TYPE_INTRUSIVE and NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE, respectively.</p>"},{"location":"api/macros/nlohmann_define_derived_type/#examples","title":"Examples","text":"NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE <p>Consider the following complete example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing nlohmann::json;\n\nclass A\n{\n  private:\n    double Aa = 0.0;\n    double Ab = 0.0;\n\n  public:\n    A() = default;\n    A(double a, double b) : Aa(a), Ab(b) {}\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(A, Aa, Ab)\n};\n\nclass B : public A\n{\n  private:\n    int Ba = 0;\n    int Bb = 0;\n\n  public:\n    B() = default;\n    B(int a, int b, double aa, double ab) : A(aa, ab), Ba(a), Bb(b) {}\n    NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE(B, A, Ba, Bb)\n};\n\nint main()\n{\n    B example(23, 42, 3.142, 1.777);\n    json example_json = example;\n\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; example_json &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"Aa\": 3.142,\n    \"Ab\": 1.777,\n    \"Ba\": 23,\n    \"Bb\": 42\n}\n</code></pre> <p>Notes:</p> <ul> <li><code>A</code> and <code>B</code> are default-constructible. This is a requirement for using the macro.</li> <li><code>A</code> has private members and is not a derived class. Hence, macro <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code> is used.</li> <li>As <code>B</code> is a derived class, <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code> is not applicable, but   <code>NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE</code> must be used.</li> <li>The macro <code>NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE</code> is used inside the class use as   <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code>.</li> </ul>"},{"location":"api/macros/nlohmann_define_derived_type/#see-also","title":"See also","text":"<ul> <li>NLOHMANN_DEFINE_TYPE_INTRUSIVE / NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT /    NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE   for similar macros that can be defined inside a non-derived type.</li> <li>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE / NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT /    NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE   for similar macros that can be defined outside a non-derived type.</li> <li>Arbitrary Type Conversions for an overview.</li> </ul>"},{"location":"api/macros/nlohmann_define_derived_type/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.12.0.</li> <li>Added in version 3.12.0.</li> <li>Added in version 3.12.0.</li> <li>Added in version 3.12.0.</li> <li>Added in version 3.12.0.</li> <li>Added in version 3.12.0.</li> </ol>"},{"location":"api/macros/nlohmann_define_type_intrusive/","title":"NLOHMANN_DEFINE_TYPE_INTRUSIVE, NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT, NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE","text":"<pre><code>#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(type, member...)              // (1)\n#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(type, member...) // (2)\n#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE(type, member...) // (3)\n</code></pre> <p>These macros can be used to simplify the serialization/deserialization of types if you want to use a JSON object as serialization and want to use the member variable names as object keys in that object. The macro is to be defined inside the class/struct to create code for. Unlike <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</code>, it can access private members. The first parameter is the name of the class/struct, and all remaining parameters name the members.</p> <ol> <li>Will use <code>at</code> during deserialization and will throw   <code>out_of_range.403</code> if a key is missing in the JSON object.</li> <li>Will use <code>value</code> during deserialization and fall back to the default value for the    respective type of the member variable if a key in the JSON object is missing. The generated <code>from_json()</code> function    default constructs an object and uses its values as the defaults when calling the <code>value</code> function.</li> <li>Only defines the serialization. Useful in cases when the type does not have a default constructor and only serialization is required.</li> </ol> <p>Summary:</p> Need access to private members Need only de-serialization Allow missing values when de-serializing macro NLOHMANN_DEFINE_TYPE_INTRUSIVE NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE"},{"location":"api/macros/nlohmann_define_type_intrusive/#parameters","title":"Parameters","text":"<code>type</code> (in) name of the type (class, struct) to serialize/deserialize <code>member</code> (in) name of the member variable to serialize/deserialize; up to 64 members can be given as a comma-separated list"},{"location":"api/macros/nlohmann_define_type_intrusive/#default-definition","title":"Default definition","text":"<p>The macros add two friend functions to the class which take care of the serialization and deserialization:</p> <pre><code>template&lt;typename BasicJsonType&gt;\nfriend void to_json(BasicJsonType&amp;, const type&amp;);\ntemplate&lt;typename BasicJsonType&gt;\nfriend void from_json(const BasicJsonType&amp;, type&amp;); // except (3)\n</code></pre> <p>See the examples below for the concrete generated code.</p>"},{"location":"api/macros/nlohmann_define_type_intrusive/#notes","title":"Notes","text":"<p>Prerequisites</p> <ol> <li>The type <code>type</code> must be default constructible (except (3)). See How can I use <code>get()</code> for non-default    constructible/non-copyable types? for how to overcome this limitation.</li> <li>The macro must be used inside the type (class/struct).</li> </ol> <p>Implementation limits</p> <ul> <li>The current implementation is limited to at most 64 member variables. If you want to serialize/deserialize types   with more than 64 member variables, you need to define the <code>to_json</code>/<code>from_json</code> functions manually.</li> </ul>"},{"location":"api/macros/nlohmann_define_type_intrusive/#examples","title":"Examples","text":"Example (1): NLOHMANN_DEFINE_TYPE_INTRUSIVE <p>Consider the following complete example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nclass person\n{\n  private:\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n  public:\n    person() = default;\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(person, name, address, age)\n};\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    try\n    {\n        auto p3 = j3.template get&lt;ns::person&gt;();\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; \"deserialization failed: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>serialization: {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\ndeserialization failed: [json.exception.out_of_range.403] key 'age' not found\n</code></pre> <p>Notes:</p> <ul> <li><code>ns::person</code> is default-constructible. This is a requirement for using the macro.</li> <li><code>ns::person</code> has private member variables. This makes <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code> applicable, but not   <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</code>.</li> <li>The macro <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code> is used inside the class.</li> <li>A missing key \"age\" in the deserialization yields an exception. To fall back to the default value,   <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</code> can be used.</li> </ul> <p>The macro is equivalent to:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nclass person\n{\n  private:\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n  public:\n    person() = default;\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n\n    template&lt;typename BasicJsonType&gt;\n    friend void to_json(BasicJsonType&amp; nlohmann_json_j, const person&amp; nlohmann_json_t)\n    {\n        nlohmann_json_j[\"name\"] = nlohmann_json_t.name;\n        nlohmann_json_j[\"address\"] = nlohmann_json_t.address;\n        nlohmann_json_j[\"age\"] = nlohmann_json_t.age;\n    }\n\n    template&lt;typename BasicJsonType&gt;\n    friend void from_json(const BasicJsonType&amp; nlohmann_json_j, person&amp; nlohmann_json_t)\n    {\n        nlohmann_json_t.name = nlohmann_json_j.at(\"name\");\n        nlohmann_json_t.address = nlohmann_json_j.at(\"address\");\n        nlohmann_json_t.age = nlohmann_json_j.at(\"age\");\n    }\n};\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    try\n    {\n        auto p3 = j3.template get&lt;ns::person&gt;();\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; \"deserialization failed: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre> Example (2): NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT <p>Consider the following complete example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nclass person\n{\n  private:\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n  public:\n    person() = default;\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(person, name, address, age)\n};\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    auto p3 = j3.template get&lt;ns::person&gt;();\n    std::cout &lt;&lt; \"roundtrip: \" &lt;&lt; json(p3) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>serialization: {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\nroundtrip: {\"address\":\"742 Evergreen Terrace\",\"age\":-1,\"name\":\"Maggie Simpson\"}\n</code></pre> <p>Notes:</p> <ul> <li><code>ns::person</code> is default-constructible. This is a requirement for using the macro.</li> <li><code>ns::person</code> has private member variables. This makes <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</code> applicable,    but not <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT</code>.</li> <li>The macro <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</code> is used inside the class.</li> <li>A missing key \"age\" in the deserialization does not yield an exception. Instead, the default value <code>-1</code> is used.</li> </ul> <p>The macro is equivalent to:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nclass person\n{\n  private:\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n  public:\n    person() = default;\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n\n    template&lt;typename BasicJsonType&gt;\n    friend void to_json(BasicJsonType&amp; nlohmann_json_j, const person&amp; nlohmann_json_t)\n    {\n        nlohmann_json_j[\"name\"] = nlohmann_json_t.name;\n        nlohmann_json_j[\"address\"] = nlohmann_json_t.address;\n        nlohmann_json_j[\"age\"] = nlohmann_json_t.age;\n    }\n\n    template&lt;typename BasicJsonType&gt;\n    friend void from_json(const BasicJsonType&amp; nlohmann_json_j, person&amp; nlohmann_json_t)\n    {\n        person nlohmann_json_default_obj;\n        nlohmann_json_t.name = nlohmann_json_j.value(\"name\", nlohmann_json_default_obj.name);\n        nlohmann_json_t.address = nlohmann_json_j.value(\"address\", nlohmann_json_default_obj.address);\n        nlohmann_json_t.age = nlohmann_json_j.value(\"age\", nlohmann_json_default_obj.age);\n    }\n};\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    auto p3 = j3.template get&lt;ns::person&gt;();\n    std::cout &lt;&lt; \"roundtrip: \" &lt;&lt; json(p3) &lt;&lt; std::endl;\n}\n</code></pre> <p>Note how a default-initialized <code>person</code> object is used in the <code>from_json</code> to fill missing values.</p> Example (3): NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE <p>Consider the following complete example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nclass person\n{\n  private:\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n  public:\n    // No default constructor\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n\n    NLOHMANN_DEFINE_TYPE_INTRUSIVE(person, name, address, age)\n};\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>serialization: {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\n</code></pre> <p>Notes:</p> <ul> <li><code>ns::person</code> is non-default-constructible. This allows this macro to be used instead of    <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code> and <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT</code>.</li> <li><code>ns::person</code> has private member variables. This makes <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE</code> applicable, but not   <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE</code>.</li> <li>The macro <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE</code> is used inside the class.</li> </ul> <p>The macro is equivalent to:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nclass person\n{\n  private:\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n  public:\n    // No default constructor\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n\n    template&lt;typename BasicJsonType&gt;\n    friend void to_json(BasicJsonType&amp; nlohmann_json_j, const person&amp; nlohmann_json_t)\n    {\n        nlohmann_json_j[\"name\"] = nlohmann_json_t.name;\n        nlohmann_json_j[\"address\"] = nlohmann_json_t.address;\n        nlohmann_json_j[\"age\"] = nlohmann_json_t.age;\n    }\n};\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api/macros/nlohmann_define_type_intrusive/#see-also","title":"See also","text":"<ul> <li>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE, NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT,    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE   for a similar macro that can be defined outside the type.</li> <li>NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE, NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT,   NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE, NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE,   NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT,    NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE for similar macros for   derived types</li> <li>Arbitrary Type Conversions for an overview.</li> </ul>"},{"location":"api/macros/nlohmann_define_type_intrusive/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.9.0.</li> <li>Added in version 3.11.0.</li> <li>Added in version 3.11.3.</li> </ol>"},{"location":"api/macros/nlohmann_define_type_non_intrusive/","title":"NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE, NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT, NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE","text":"<pre><code>#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(type, member...)              // (1)\n#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(type, member...) // (2)\n#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(type, member...) // (3)\n</code></pre> <p>These macros can be used to simplify the serialization/deserialization of types if you want to use a JSON object as serialization and want to use the member variable names as object keys in that object. The macro is to be defined outside the class/struct to create code for, but inside its namespace. Unlike <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code>, it cannot access private members. The first parameter is the name of the class/struct, and all remaining parameters name the members.</p> <ol> <li>Will use <code>at</code> during deserialization and will throw    <code>out_of_range.403</code> if a key is missing in the JSON object.</li> <li>Will use <code>value</code> during deserialization and fall back to the default value for the    respective type of the member variable if a key in the JSON object is missing. The generated <code>from_json()</code> function    default constructs an object and uses its values as the defaults when calling the <code>value</code> function.</li> <li>Only defines the serialization. Useful in cases when the type does not have a default constructor and only serialization is required.</li> </ol> <p>Summary:</p> Need access to private members Need only de-serialization Allow missing values when de-serializing macro NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE"},{"location":"api/macros/nlohmann_define_type_non_intrusive/#parameters","title":"Parameters","text":"<code>type</code> (in) name of the type (class, struct) to serialize/deserialize <code>member</code> (in) name of the (public) member variable to serialize/deserialize; up to 64 members can be given as a comma-separated list"},{"location":"api/macros/nlohmann_define_type_non_intrusive/#default-definition","title":"Default definition","text":"<p>The macros add two functions to the namespace which take care of the serialization and deserialization:</p> <pre><code>template&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp;, const type&amp;);\ntemplate&lt;typename BasicJsonType&gt;\nvoid from_json(const BasicJsonType&amp;, type&amp;); // except (3)\n</code></pre> <p>See the examples below for the concrete generated code.</p>"},{"location":"api/macros/nlohmann_define_type_non_intrusive/#notes","title":"Notes","text":"<p>Prerequisites</p> <ol> <li>The type <code>type</code> must be default constructible (except (3). See How can I use <code>get()</code> for non-default constructible/non-copyable types?    for how to overcome this limitation.</li> <li>The macro must be used outside the type (class/struct).</li> <li>The passed members must be public.</li> </ol> <p>Implementation limits</p> <ul> <li>The current implementation is limited to at most 64 member variables. If you want to serialize/deserialize types   with more than 64 member variables, you need to define the <code>to_json</code>/<code>from_json</code> functions manually.</li> </ul>"},{"location":"api/macros/nlohmann_define_type_non_intrusive/#examples","title":"Examples","text":"Example (1): NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE <p>Consider the following complete example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nstruct person\n{\n    std::string name;\n    std::string address;\n    int age;\n};\n\nNLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(person, name, address, age)\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    try\n    {\n        auto p3 = j3.template get&lt;ns::person&gt;();\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; \"deserialization failed: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>serialization: {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\ndeserialization failed: [json.exception.out_of_range.403] key 'age' not found\n</code></pre> <p>Notes:</p> <ul> <li><code>ns::person</code> is default-constructible. This is a requirement for using the macro.</li> <li><code>ns::person</code> has only public member variables. This makes <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</code> applicable.</li> <li>The macro <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</code> is used outside the class, but inside its namespace <code>ns</code>.</li> <li>A missing key \"age\" in the deserialization yields an exception. To fall back to the default value,   <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT</code> can be used.</li> </ul> <p>The macro is equivalent to:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nstruct person\n{\n    std::string name;\n    std::string address;\n    int age;\n};\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp; nlohmann_json_j, const person&amp; nlohmann_json_t)\n{\n    nlohmann_json_j[\"name\"] = nlohmann_json_t.name;\n    nlohmann_json_j[\"address\"] = nlohmann_json_t.address;\n    nlohmann_json_j[\"age\"] = nlohmann_json_t.age;\n}\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid from_json(const BasicJsonType&amp; nlohmann_json_j, person&amp; nlohmann_json_t)\n{\n    nlohmann_json_t.name = nlohmann_json_j.at(\"name\");\n    nlohmann_json_t.address = nlohmann_json_j.at(\"address\");\n    nlohmann_json_t.age = nlohmann_json_j.at(\"age\");\n}\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    try\n    {\n        auto p3 = j3.template get&lt;ns::person&gt;();\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; \"deserialization failed: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre> Example (2): NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT <p>Consider the following complete example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nstruct person\n{\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n    person() = default;\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n};\n\nNLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(person, name, address, age)\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    auto p3 = j3.template get&lt;ns::person&gt;();\n    std::cout &lt;&lt; \"roundtrip: \" &lt;&lt; json(p3) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>serialization: {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\nroundtrip: {\"address\":\"742 Evergreen Terrace\",\"age\":-1,\"name\":\"Maggie Simpson\"}\n</code></pre> <p>Notes:</p> <ul> <li><code>ns::person</code> is default-constructible. This is a requirement for using the macro.</li> <li><code>ns::person</code> has only public member variables. This makes <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT</code>   applicable.</li> <li>The macro <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT</code> is used outside the class, but inside its   namespace <code>ns</code>.</li> <li>A missing key \"age\" in the deserialization does not yield an exception. Instead, the default value <code>-1</code> is used.</li> </ul> <p>The macro is equivalent to:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nstruct person\n{\n    std::string name = \"John Doe\";\n    std::string address = \"123 Fake St\";\n    int age = -1;\n\n    person() = default;\n    person(std::string name_, std::string address_, int age_)\n        : name(std::move(name_)), address(std::move(address_)), age(age_)\n    {}\n};\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp; nlohmann_json_j, const person&amp; nlohmann_json_t)\n{\n    nlohmann_json_j[\"name\"] = nlohmann_json_t.name;\n    nlohmann_json_j[\"address\"] = nlohmann_json_t.address;\n    nlohmann_json_j[\"age\"] = nlohmann_json_t.age;\n}\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid from_json(const BasicJsonType&amp; nlohmann_json_j, person&amp; nlohmann_json_t)\n{\n    person nlohmann_json_default_obj;\n    nlohmann_json_t.name = nlohmann_json_j.value(\"name\", nlohmann_json_default_obj.name);\n    nlohmann_json_t.address = nlohmann_json_j.value(\"address\", nlohmann_json_default_obj.address);\n    nlohmann_json_t.age = nlohmann_json_j.value(\"age\", nlohmann_json_default_obj.age);\n}\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n\n    // deserialization: json -&gt; person\n    json j2 = R\"({\"address\": \"742 Evergreen Terrace\", \"age\": 40, \"name\": \"Homer Simpson\"})\"_json;\n    auto p2 = j2.template get&lt;ns::person&gt;();\n\n    // incomplete deserialization:\n    json j3 = R\"({\"address\": \"742 Evergreen Terrace\", \"name\": \"Maggie Simpson\"})\"_json;\n    auto p3 = j3.template get&lt;ns::person&gt;();\n    std::cout &lt;&lt; \"roundtrip: \" &lt;&lt; json(p3) &lt;&lt; std::endl;\n}\n</code></pre> <p>Note how a default-initialized <code>person</code> object is used in the <code>from_json</code> to fill missing values.</p> Example (3): NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE <p>Consider the following complete example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nstruct person\n{\n    std::string name;\n    std::string address;\n    int age;\n};\n\nNLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(person, name, address, age)\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>serialization: {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\n</code></pre> <p>Notes:</p> <ul> <li><code>ns::person</code> is non-default-constructible. This allows this macro to be used instead of    <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE</code> and <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT</code>.</li> <li><code>ns::person</code> has only public member variables. This makes <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE</code> applicable.</li> <li>The macro <code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE</code> is used outside the class, but inside its namespace <code>ns</code>.</li> </ul> <p>The macro is equivalent to:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nnamespace ns\n{\nstruct person\n{\n    std::string name;\n    std::string address;\n    int age;\n};\n\ntemplate&lt;typename BasicJsonType&gt;\nvoid to_json(BasicJsonType&amp; nlohmann_json_j, const person&amp; nlohmann_json_t)\n{\n    nlohmann_json_j[\"name\"] = nlohmann_json_t.name;\n    nlohmann_json_j[\"address\"] = nlohmann_json_t.address;\n    nlohmann_json_j[\"age\"] = nlohmann_json_t.age;\n}\n} // namespace ns\n\nint main()\n{\n    ns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n    // serialization: person -&gt; json\n    json j = p;\n    std::cout &lt;&lt; \"serialization: \" &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api/macros/nlohmann_define_type_non_intrusive/#see-also","title":"See also","text":"<ul> <li>NLOHMANN_DEFINE_TYPE_INTRUSIVE, NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT,   NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE   for a similar macro that can be defined inside the type.</li> <li>NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE, NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT,   NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE, NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE,   NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT,   NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE for similar macros for   derived types</li> <li>Arbitrary Type Conversions for an overview.</li> </ul>"},{"location":"api/macros/nlohmann_define_type_non_intrusive/#version-history","title":"Version history","text":"<ol> <li>Added in version 3.9.0.</li> <li>Added in version 3.11.0.</li> <li>Added in version 3.11.3.</li> </ol>"},{"location":"api/macros/nlohmann_json_namespace/","title":"NLOHMANN_JSON_NAMESPACE","text":"<pre><code>#define NLOHMANN_JSON_NAMESPACE /* value */\n</code></pre> <p>This macro evaluates to the full name of the <code>nlohmann</code> namespace.</p>"},{"location":"api/macros/nlohmann_json_namespace/#default-definition","title":"Default definition","text":"<p>The default value consists of the root namespace (<code>nlohmann</code>) and an inline ABI namespace. See <code>nlohmann</code> Namespace for details.</p> <p>When the macro is not defined, the library will define it to its default value. Overriding this value has no effect on the library.</p>"},{"location":"api/macros/nlohmann_json_namespace/#examples","title":"Examples","text":"Example <p>The example shows how to use <code>NLOHMANN_JSON_NAMESPACE</code> instead of just <code>nlohmann</code>, as well as how to output the value of <code>NLOHMANN_JSON_NAMESPACE</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// possible use case: use NLOHMANN_JSON_NAMESPACE instead of nlohmann\nusing json = NLOHMANN_JSON_NAMESPACE::json;\n\n// macro needed to output the NLOHMANN_JSON_NAMESPACE as string literal\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\nint main()\n{\n    std::cout &lt;&lt; QUOTE(NLOHMANN_JSON_NAMESPACE) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>nlohmann::json_abi_v3_12_0\n</code></pre>"},{"location":"api/macros/nlohmann_json_namespace/#see-also","title":"See also","text":"<ul> <li><code>NLOHMANN_JSON_NAMESPACE_BEGIN, NLOHMANN_JSON_NAMESPACE_END</code></li> <li><code>NLOHMANN_JSON_NAMESPACE_NO_VERSION</code></li> </ul>"},{"location":"api/macros/nlohmann_json_namespace/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0. Changed inline namespace name in version 3.11.2.</li> </ul>"},{"location":"api/macros/nlohmann_json_namespace_begin/","title":"NLOHMANN_JSON_NAMESPACE_BEGIN, NLOHMANN_JSON_NAMESPACE_END","text":"<pre><code>#define NLOHMANN_JSON_NAMESPACE_BEGIN /* value */  // (1)\n#define NLOHMANN_JSON_NAMESPACE_END   /* value */  // (2)\n</code></pre> <p>These macros can be used to open and close the <code>nlohmann</code> namespace. See <code>nlohmann</code> Namespace for details.</p> <ol> <li>Opens the namespace.</li> <li>Closes the namespace.</li> </ol>"},{"location":"api/macros/nlohmann_json_namespace_begin/#default-definition","title":"Default definition","text":"<p>The default definitions open and close the <code>nlohmann</code> namespace. The precise definition of [<code>NLOHMANN_JSON_NAMESPACE_BEGIN</code>] varies as described here.</p> <ol> <li> <p>Default definition of <code>NLOHMANN_JSON_NAMESPACE_BEGIN</code>:</p> <pre><code>namespace nlohmann\n{\ninline namespace json_abi_v3_11_2\n{\n</code></pre> </li> <li> <p>Default definition of <code>NLOHMANN_JSON_NAMESPACE_END</code>:     <pre><code>}  // namespace json_abi_v3_11_2\n}  // namespace nlohmann\n</code></pre></p> </li> </ol> <p>When these macros are not defined, the library will define them to their default definitions.</p>"},{"location":"api/macros/nlohmann_json_namespace_begin/#examples","title":"Examples","text":"Example <p>The example shows how to use <code>NLOHMANN_JSON_NAMESPACE_BEGIN</code>/<code>NLOHMANN_JSON_NAMESPACE_END</code> from the How do I convert third-party types? page.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;optional&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\n// partial specialization (see https://json.nlohmann.me/features/arbitrary_types/)\nNLOHMANN_JSON_NAMESPACE_BEGIN\ntemplate &lt;typename T&gt;\nstruct adl_serializer&lt;std::optional&lt;T&gt;&gt;\n{\n    static void to_json(json&amp; j, const std::optional&lt;T&gt;&amp; opt)\n    {\n        if (opt == std::nullopt)\n        {\n            j = nullptr;\n        }\n        else\n        {\n            j = *opt;\n        }\n    }\n};\nNLOHMANN_JSON_NAMESPACE_END\n\nint main()\n{\n    std::optional&lt;int&gt; o1 = 1;\n    std::optional&lt;int&gt; o2 = std::nullopt;\n\n    NLOHMANN_JSON_NAMESPACE::json j;\n    j.push_back(o1);\n    j.push_back(o2);\n    std::cout &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>[1,null]\n</code></pre>"},{"location":"api/macros/nlohmann_json_namespace_begin/#see-also","title":"See also","text":"<ul> <li><code>nlohmann</code> Namespace</li> <li>NLOHMANN_JSON_NAMESPACE</li> <li><code>NLOHMANN_JSON_NAMESPACE_NO_VERSION</code></li> </ul>"},{"location":"api/macros/nlohmann_json_namespace_begin/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.0. Changed inline namespace name in version 3.11.2.</li> </ul>"},{"location":"api/macros/nlohmann_json_namespace_no_version/","title":"NLOHMANN_JSON_NAMESPACE_NO_VERSION","text":"<pre><code>#define NLOHMANN_JSON_NAMESPACE_NO_VERSION /* value */\n</code></pre> <p>If defined to <code>1</code>, the version component is omitted from the inline namespace. See <code>nlohmann</code> Namespace for details.</p>"},{"location":"api/macros/nlohmann_json_namespace_no_version/#default-definition","title":"Default definition","text":"<p>The default value is <code>0</code>.</p> <pre><code>#define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0\n</code></pre> <p>When the macro is not defined, the library will define it to its default value.</p>"},{"location":"api/macros/nlohmann_json_namespace_no_version/#examples","title":"Examples","text":"Example <p>The example shows how to use <code>NLOHMANN_JSON_NAMESPACE_NO_VERSION</code> to disable the version component of the inline namespace.</p> <pre><code>#include &lt;iostream&gt;\n\n#define NLOHMANN_JSON_NAMESPACE_NO_VERSION 1\n#include &lt;nlohmann/json.hpp&gt;\n\n// macro needed to output the NLOHMANN_JSON_NAMESPACE as string literal\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\nint main()\n{\n    std::cout &lt;&lt; QUOTE(NLOHMANN_JSON_NAMESPACE) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>nlohmann::json_abi\n</code></pre>"},{"location":"api/macros/nlohmann_json_namespace_no_version/#see-also","title":"See also","text":"<ul> <li><code>nlohmann</code> Namespace</li> <li><code>NLOHMANN_JSON_NAMESPACE</code></li> <li><code>NLOHMANN_JSON_NAMESPACE_BEGIN, NLOHMANN_JSON_NAMESPACE_END</code></li> </ul>"},{"location":"api/macros/nlohmann_json_namespace_no_version/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.11.2.</li> </ul>"},{"location":"api/macros/nlohmann_json_serialize_enum/","title":"NLOHMANN_JSON_SERIALIZE_ENUM","text":"<pre><code>#define NLOHMANN_JSON_SERIALIZE_ENUM(type, conversion...)\n</code></pre> <p>By default, enum values are serialized to JSON as integers. In some cases, this could result in undesired behavior. If an enum is modified or re-ordered after data has been serialized to JSON, the later deserialized JSON data may be undefined or a different enum value than was originally intended.</p> <p>The <code>NLOHMANN_JSON_SERIALIZE_ENUM</code> allows to define a user-defined serialization for every enumerator.</p>"},{"location":"api/macros/nlohmann_json_serialize_enum/#parameters","title":"Parameters","text":"<code>type</code> (in) name of the enum to serialize/deserialize <code>conversion</code> (in) a pair of an enumerator and a JSON serialization; arbitrary pairs can be given as a comma-separated list"},{"location":"api/macros/nlohmann_json_serialize_enum/#default-definition","title":"Default definition","text":"<p>The macro adds two functions to the namespace which take care of the serialization and deserialization:</p> <pre><code>template&lt;typename BasicJsonType&gt;\ninline void to_json(BasicJsonType&amp; j, const type&amp; e);\ntemplate&lt;typename BasicJsonType&gt;\ninline void from_json(const BasicJsonType&amp; j, type&amp; e);\n</code></pre>"},{"location":"api/macros/nlohmann_json_serialize_enum/#notes","title":"Notes","text":"<p>Prerequisites</p> <p>The macro must be used inside the namespace of the enum.</p> <p>Important notes</p> <ul> <li>When using <code>template get&lt;ENUM_TYPE&gt;()</code>, undefined JSON values will default to the first specified   conversion. Select this default pair carefully. See example 1 below.</li> <li>If an enum or JSON value is specified in multiple conversions, the first matching conversion from the top of the   list will be returned when converting to or from JSON. See example 2 below.</li> </ul>"},{"location":"api/macros/nlohmann_json_serialize_enum/#examples","title":"Examples","text":"Example 1: Basic usage <p>The example shows how <code>NLOHMANN_JSON_SERIALIZE_ENUM</code> can be used to serialize/deserialize both classical enums and C++11 enum classes:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nnamespace ns\n{\nenum TaskState\n{\n    TS_STOPPED,\n    TS_RUNNING,\n    TS_COMPLETED,\n    TS_INVALID = -1\n};\n\nNLOHMANN_JSON_SERIALIZE_ENUM(TaskState,\n{\n    { TS_INVALID, nullptr },\n    { TS_STOPPED, \"stopped\" },\n    { TS_RUNNING, \"running\" },\n    { TS_COMPLETED, \"completed\" }\n})\n\nenum class Color\n{\n    red, green, blue, unknown\n};\n\nNLOHMANN_JSON_SERIALIZE_ENUM(Color,\n{\n    { Color::unknown, \"unknown\" }, { Color::red, \"red\" },\n    { Color::green, \"green\" }, { Color::blue, \"blue\" }\n})\n} // namespace ns\n\nint main()\n{\n    // serialization\n    json j_stopped = ns::TS_STOPPED;\n    json j_red = ns::Color::red;\n    std::cout &lt;&lt; \"ns::TS_STOPPED -&gt; \" &lt;&lt; j_stopped\n              &lt;&lt; \", ns::Color::red -&gt; \" &lt;&lt; j_red &lt;&lt; std::endl;\n\n    // deserialization\n    json j_running = \"running\";\n    json j_blue = \"blue\";\n    auto running = j_running.template get&lt;ns::TaskState&gt;();\n    auto blue = j_blue.template get&lt;ns::Color&gt;();\n    std::cout &lt;&lt; j_running &lt;&lt; \" -&gt; \" &lt;&lt; running\n              &lt;&lt; \", \" &lt;&lt; j_blue &lt;&lt; \" -&gt; \" &lt;&lt; static_cast&lt;int&gt;(blue) &lt;&lt; std::endl;\n\n    // deserializing undefined JSON value to enum\n    // (where the first map entry above is the default)\n    json j_pi = 3.14;\n    auto invalid = j_pi.template get&lt;ns::TaskState&gt;();\n    auto unknown = j_pi.template get&lt;ns::Color&gt;();\n    std::cout &lt;&lt; j_pi &lt;&lt; \" -&gt; \" &lt;&lt; invalid &lt;&lt; \", \"\n              &lt;&lt; j_pi &lt;&lt; \" -&gt; \" &lt;&lt; static_cast&lt;int&gt;(unknown) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>ns::TS_STOPPED -&gt; \"stopped\", ns::Color::red -&gt; \"red\"\n\"running\" -&gt; 1, \"blue\" -&gt; 2\n3.14 -&gt; -1, 3.14 -&gt; 3\n</code></pre> Example 2: Multiple conversions for one enumerator <p>The example shows how to use multiple conversions for a single enumerator. In the example, <code>Color::red</code> will always be serialized to <code>\"red\"</code>, because the first occurring conversion. The second conversion, however, offers an alternative deserialization from <code>\"rot\"</code> to <code>Color::red</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nnamespace ns\n{\nenum class Color\n{\n    red, green, blue, unknown\n};\n\nNLOHMANN_JSON_SERIALIZE_ENUM(Color,\n{\n    { Color::unknown, \"unknown\" }, { Color::red, \"red\" },\n    { Color::green, \"green\" }, { Color::blue, \"blue\" },\n    { Color::red, \"rot\" } // a second conversion for Color::red\n})\n}\n\nint main()\n{\n    // serialization\n    json j_red = ns::Color::red;\n    std::cout &lt;&lt; static_cast&lt;int&gt;(ns::Color::red) &lt;&lt; \" -&gt; \" &lt;&lt; j_red &lt;&lt; std::endl;\n\n    // deserialization\n    json j_rot = \"rot\";\n    auto rot = j_rot.template get&lt;ns::Color&gt;();\n    auto red = j_red.template get&lt;ns::Color&gt;();\n    std::cout &lt;&lt; j_rot &lt;&lt; \" -&gt; \" &lt;&lt; static_cast&lt;int&gt;(rot) &lt;&lt; std::endl;\n    std::cout &lt;&lt; j_red &lt;&lt; \" -&gt; \" &lt;&lt; static_cast&lt;int&gt;(red) &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>0 -&gt; \"red\"\n\"rot\" -&gt; 0\n\"red\" -&gt; 0\n</code></pre>"},{"location":"api/macros/nlohmann_json_serialize_enum/#see-also","title":"See also","text":"<ul> <li>Specializing enum conversion</li> <li><code>JSON_DISABLE_ENUM_SERIALIZATION</code></li> </ul>"},{"location":"api/macros/nlohmann_json_serialize_enum/#version-history","title":"Version history","text":"<p>Added in version 3.4.0.</p>"},{"location":"api/macros/nlohmann_json_version_major/","title":"NLOHMANN_JSON_VERSION_MAJOR, NLOHMANN_JSON_VERSION_MINOR, NLOHMANN_JSON_VERSION_PATCH","text":"<pre><code>#define NLOHMANN_JSON_VERSION_MAJOR /* value */\n#define NLOHMANN_JSON_VERSION_MINOR /* value */\n#define NLOHMANN_JSON_VERSION_PATCH /* value */\n</code></pre> <p>These macros are defined by the library and contain the version numbers according to Semantic Versioning 2.0.0.</p>"},{"location":"api/macros/nlohmann_json_version_major/#default-definition","title":"Default definition","text":"<p>The macros are defined according to the current library version.</p>"},{"location":"api/macros/nlohmann_json_version_major/#examples","title":"Examples","text":"Example <p>The example below shows how <code>NLOHMANN_JSON_VERSION_MAJOR</code>, <code>NLOHMANN_JSON_VERSION_MINOR</code>, and <code>NLOHMANN_JSON_VERSION_PATCH</code> are defined by the library.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; \"JSON for Modern C++ version \"\n              &lt;&lt; NLOHMANN_JSON_VERSION_MAJOR &lt;&lt; \".\"\n              &lt;&lt; NLOHMANN_JSON_VERSION_MINOR &lt;&lt; \".\"\n              &lt;&lt; NLOHMANN_JSON_VERSION_PATCH &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>JSON for Modern C++ version 3.12.0\n</code></pre>"},{"location":"api/macros/nlohmann_json_version_major/#see-also","title":"See also","text":"<ul> <li>meta - returns version information on the library</li> <li>JSON_SKIP_LIBRARY_VERSION_CHECK - skip library version check</li> </ul>"},{"location":"api/macros/nlohmann_json_version_major/#version-history","title":"Version history","text":"<ul> <li>Added in version 3.1.0.</li> </ul>"},{"location":"community/","title":"Community","text":"<ul> <li>Code of Conduct - the rules and norms of this project</li> <li>Contribution Guidelines - guidelines how to contribute to this project</li> <li>Governance - the governance model of this project</li> <li>Quality Assurance - how the quality of this project is assured</li> <li>Security Policy - the security policy of the project</li> </ul>"},{"location":"community/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at mail@nlohmann.me. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/contribution_guidelines/","title":"Contribution Guidelines","text":"<p>Thank you for your interest in contributing to this project! What began as an exercise to explore the exciting features of C++11 has evolved into a widely used JSON library. I truly appreciate all the contributions from the community, whether it's proposing features, identifying bugs, or fixing mistakes! To ensure that our collaboration is efficient and effective, please follow these guidelines.</p> <p>Feel free to discuss or suggest improvements to this document by submitting a pull request.</p>"},{"location":"community/contribution_guidelines/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are multiple ways to contribute.</p>"},{"location":"community/contribution_guidelines/#reporting-an-issue","title":"Reporting an issue","text":"<p>Please create an issue, assuming one does not already exist, and describe your concern. Note you need a GitHub account for this.</p> <p>Clearly describe the issue:</p> <ul> <li>If it is a bug, please describe how to reproduce it. If possible, attach a complete example which demonstrates   the error. Please also state what you expected to happen instead of the error.</li> <li>If you propose a change or addition, try to give an example what the improved code could look like or how to use   it.</li> <li>If you found a compilation error, please tell us which compiler (version and operating system) you used and paste   the (relevant part of) the error messages to the ticket.</li> </ul> <p>Please stick to the provided issue template bug report if possible.</p>"},{"location":"community/contribution_guidelines/#reporting-a-security-vulnerability","title":"Reporting a security vulnerability","text":"<p>You can report a security vulnerability according to our security policy.</p>"},{"location":"community/contribution_guidelines/#discussing-a-new-feature","title":"Discussing a new feature","text":"<p>For questions, feature or support requests, please open a discussion. If you find a proposed answer satisfactory, please use the \"Mark as answer\" button to make it easier for readers to see what helped and for the community to filter for open questions.</p>"},{"location":"community/contribution_guidelines/#proposing-a-fix-or-an-improvement","title":"Proposing a fix or an improvement","text":"<p>Join an ongoing discussion or comment on an existing issue before starting to code. This can help to avoid duplicate efforts or other frustration during the later review.</p> <p>Create a pull request against the <code>develop</code> branch and follow the pull request template. In particular,</p> <ul> <li>describe the changes in detail, both the what and why,</li> <li>reference existing issues where applicable,</li> <li>add tests to maintain 100% test coverage,</li> <li>update the documentation as needed, and</li> <li>ensure the source code is amalgamated.</li> </ul> <p>We describe all points in detail below.</p> <p>All contributions (including pull requests) must agree to the Developer Certificate of Origin (DCO) version 1.1. This is exactly the same one created and used by the Linux kernel developers and posted on http://developercertificate.org/. This is a developer's certification that he or she has the right to submit the patch for inclusion into the project.</p>"},{"location":"community/contribution_guidelines/#how-to","title":"How to...","text":""},{"location":"community/contribution_guidelines/#describe-your-changes","title":"Describe your changes","text":"<p>This library is primarily maintained as a spare-time project. As such, I cannot make any guarantee how quickly changes are merged and released. Therefore, it is very important to make the review as smooth as possible by explaining not only what you changed, but why. This rationale can be very valuable down the road when improvements or bugs are discussed years later.</p>"},{"location":"community/contribution_guidelines/#reference-an-existing-issue","title":"Reference an existing issue","text":"<p>Link a pull request to an issue to clarify that a fix is forthcoming and which issue can be closed after merging. Only a few cases (e.g., fixing typos) do not require prior discussions.</p>"},{"location":"community/contribution_guidelines/#write-tests","title":"Write tests","text":"<p>The library has an extensive test suite that currently covers 100 % of the library's code. These tests are crucial to maintain API stability and give future contributors confidence that they do not accidentally break things. As Titus Winters aptly put it:</p> <p>If you liked it, you should have put a test on it.</p>"},{"location":"community/contribution_guidelines/#run-the-tests","title":"Run the tests","text":"<p>First, ensure the test suite runs before making any changes:</p> <pre><code>$ cmake -S. -B build\n$ cmake --build build -j 10\n$ ctest --test-dir build -j 10\n</code></pre> <p>The test suite should report:</p> <pre><code>100% tests passed, 0 tests failed out of 98\n</code></pre>"},{"location":"community/contribution_guidelines/#add-tests","title":"Add tests","text":"<p>The tests are located in <code>tests/src/unit-*.cpp</code> and contain doctest assertions like <code>CHECK</code>. The tests are structured along the features of the library or the nature of the tests. Usually, it should be clear from the context which existing file needs to be extended, and only very few cases require creating new test files.</p> <p>When fixing a bug, edit <code>unit-regression2.cpp</code> and add a section referencing the fixed issue.</p>"},{"location":"community/contribution_guidelines/#exceptions","title":"Exceptions","text":"<p>When you test exceptions, please use <code>CHECK_THROWS_WITH_AS</code> which also takes the <code>what()</code> argument of the thrown exception into account.</p>"},{"location":"community/contribution_guidelines/#coverage","title":"Coverage","text":"<p>If test coverage decreases, an automatic warning comment will be posted on the pull request. You can access a code coverage report as an artifact to the \u201cUbuntu\u201d workflow.</p>"},{"location":"community/contribution_guidelines/#update-the-documentation","title":"Update the documentation","text":"<p>The main documentation of the library is generated from the files <code>docs/mkdocs/docs</code>. This folder contains dedicated pages for certain features, a list of all exceptions, and  extensive API documentation with details on every public API function.</p> <p>Build the documentation locally using:</p> <pre><code>make install_venv -C docs/mkdocs\nmake serve -C docs/mkdocs\n</code></pre> <p>The documentation will then be available at http://127.0.0.1:8000/. See the documentation of mkdocs and Material for MkDocs for more information.</p>"},{"location":"community/contribution_guidelines/#amalgamate-the-source-code","title":"Amalgamate the source code","text":"<p>The single-header files <code>single_include/nlohmann/json.hpp</code> and <code>single_include/nlohmann/json_fwd.hpp</code> are generated from the source files in the <code>include/nlohmann</code> directory. Do not edit the files directly; instead, modify the include/nlohmann sources and regenerate the files by executing:</p> <pre><code>make amalgamate\n</code></pre> <p>Running <code>make amalgamate</code> will also apply automatic formatting to the source files using <code>Artistic Style</code>. This formatting may modify your source files in-place. Be certain to review and commit any changes to avoid unintended formatting diffs in commits.</p>"},{"location":"community/contribution_guidelines/#recommended-documentation","title":"Recommended documentation","text":"<ul> <li>The library\u2019s README file is an excellent starting point to   understand its functionality.</li> <li>The documentation page is the reference documentation of the library.</li> <li>RFC 8259 is the reference for the JavaScript Object Notation (JSON)   Data Interchange Format.</li> </ul>"},{"location":"community/contribution_guidelines/#please-dont","title":"Please don't...","text":"<p>Certain contributions are not helpful.</p>"},{"location":"community/contribution_guidelines/#break-the-public-api","title":"Break the public API","text":"<p>We take pride in the library being used by numerous customers across various industries. They all rely on the guarantees provided by semantic versioning. Please do not change the library such that the public API of the 3.x.y version is broken. This includes:</p> <ul> <li>Changing function signatures (altering parameter types, return types, number of parameters) or changing the const-ness   of member functions.</li> <li>Removing functions.</li> <li>Renaming functions or classes.</li> <li>Changing exception handling.</li> <li>Changing exception ids.</li> <li>Changing access specifiers.</li> <li>Changing default arguments.</li> </ul> <p>Although these guidelines may seem restrictive, they are essential for maintaining the library\u2019s utility.</p> <p>Breaking changes may be introduced when they are guarded with a feature macro such as <code>JSON_USE_IMPLICIT_CONVERSIONS</code> which allows  selectively changing the behavior of the library. In next steps, the current behavior can then be deprecated. Using feature macros then allows users to test their code against the library in the next major release.</p>"},{"location":"community/contribution_guidelines/#break-c11-language-conformance","title":"Break C++11 language conformance","text":"<p>This library is designed to work with C++11 and later. This means that any supported C++11 compiler should compile the library without problems. Some compilers like GCC 4.7 (and earlier), Clang 3.3 (and earlier), or Microsoft Visual Studio 13.0 and earlier are known not to work due to missing or incomplete C++11 support.</p> <p>Please do not add features that do not work with the mentioned supported compilers. Please guard features from C++14 and later against the respective <code>JSON_HAS_CPP_14</code> macros.</p>"},{"location":"community/contribution_guidelines/#break-json-conformance","title":"Break JSON conformance","text":"<p>Please refrain from proposing changes that would break JSON conformance. If you propose a conformant extension of JSON to be supported by the library, please motivate this extension.</p>"},{"location":"community/contribution_guidelines/#wanted","title":"Wanted","text":"<p>The following areas really need contribution and are always welcomed:</p> <ul> <li>Extending the continuous integration toward more exotic compilers such as Android NDK, Intel's Compiler, or the   bleeding-edge versions Clang.</li> <li>Improving the efficiency of the JSON parser. The current parser is implemented as a naive recursive descent parser   with hand-coded string handling. More sophisticated approaches like LALR parsers would be really appreciated. That   said, parser generators like Bison or ANTLR do not play nice with single-header files -- I really would like to keep   the parser inside the <code>json.hpp</code> header, and I am not aware of approaches similar to <code>re2c</code> for   parsing.</li> <li>Extending and updating existing benchmarks to include (the most recent version of) this library. Though efficiency   is not everything, speed and memory consumption are very important characteristics for C++ developers, so having   proper comparisons would be interesting.</li> </ul> <p>We look forward to your contributions and collaboration to enhance the library!</p>"},{"location":"community/governance/","title":"Governance","text":"<p>The governance model for the JSON for Modern C++ project is a Benevolent Dictator for Life (BDFL) structure. As the sole maintainer, Niels Lohmann is responsible for all key aspects of the project. The project governance may evolve as the project grows, but any changes will be documented here and communicated to contributors.</p>"},{"location":"community/governance/#overview","title":"Overview","text":"<p>This project is led by a benevolent dictator, Niels Lohmann, and managed by the community. That is, the community actively contributes to the day-to-day maintenance of the project, but the general strategic line is drawn by the benevolent dictator. In case of disagreement, they have the last word. It is the benevolent dictator\u2019s job to resolve disputes within the community and to ensure that the project is able to progress in a coordinated way. In turn, it is the community\u2019s job to guide the decisions of the benevolent dictator through active engagement and contribution.</p>"},{"location":"community/governance/#roles-and-responsibilities","title":"Roles and responsibilities","text":""},{"location":"community/governance/#benevolent-dictator-project-lead","title":"Benevolent dictator (project lead)","text":"<p>Typically, the benevolent dictator, or project lead, is self-appointed. However, because the community always has the ability to fork, this person is fully answerable to the community. The project lead\u2019s role is a difficult one: they set the strategic objectives of the project and communicate these clearly to the community. They also have to understand the community as a whole and strive to satisfy as many conflicting needs as possible, while ensuring that the project survives in the long term.</p> <p>In many ways, the role of the benevolent dictator is less about dictatorship and more about diplomacy. The key is to ensure that, as the project expands, the right people are given influence over it and the community rallies behind the vision of the project lead. The lead\u2019s job is then to ensure that the committers (see below) make the right decisions on behalf of the project. Generally speaking, as long as the committers are aligned with the project\u2019s strategy, the project lead will allow them to proceed as they desire.</p>"},{"location":"community/governance/#committers","title":"Committers","text":"<p>Committers are contributors who have made several valuable contributions to the project and are now relied upon to both write code directly to the repository and screen the contributions of others. In many cases they are programmers but it is also possible that they contribute in a different role. Typically, a committer will focus on a specific aspect of the project, and will bring a level of expertise and understanding that earns them the respect of the community and the project lead. The role of committer is not an official one, it is simply a position that influential members of the community will find themselves in as the project lead looks to them for guidance and support.</p> <p>Committers have no authority over the overall direction of the project. However, they do have the ear of the project lead. It is a committer\u2019s job to ensure that the lead is aware of the community\u2019s needs and collective objectives, and to help develop or elicit appropriate contributions to the project. Often, committers are given informal control over their specific areas of responsibility, and are assigned rights to directly modify certain areas of the source code. That is, although committers do not have explicit decision-making authority, they will often find that their actions are synonymous with the decisions made by the lead.</p>"},{"location":"community/governance/#contributors","title":"Contributors","text":"<p>Contributors are community members who either have no desire to become committers, or have not yet been given the opportunity by the benevolent dictator. They make valuable contributions, such as those outlined in the list below, but generally do not have the authority to make direct changes to the project code. Contributors engage with the project through communication tools, such as email lists, and via reports and patches attached to issues in the issue tracker, as detailed in our community tools document.</p> <p>Anyone can become a contributor. There is no expectation of commitment to the project, no specific skill requirements and no selection process. To become a contributor, a community member simply has to perform one or more actions that are beneficial to the project.</p> <p>Some contributors will already be engaging with the project as users, but will also find themselves doing one or more of the following:</p> <ul> <li>supporting new users (current users often provide the most effective new user support)</li> <li>reporting bugs</li> <li>identifying requirements</li> <li>supplying graphics and web design</li> <li>programming</li> <li>assisting with project infrastructure</li> <li>writing documentation</li> <li>fixing bugs</li> <li>adding features</li> </ul> <p>As contributors gain experience and familiarity with the project, they may find that the project lead starts relying on them more and more. When this begins to happen, they gradually adopt the role of committer, as described above.</p>"},{"location":"community/governance/#users","title":"Users","text":"<p>Users are community members who have a need for the project. They are the most important members of the community: without them, the project would have no purpose. Anyone can be a user; there are no specific requirements.</p> <p>Users should be encouraged to participate in the life of the project and the community as much as possible. User contributions enable the project team to ensure that they are satisfying the needs of those users. Common user activities include (but are not limited to):</p> <ul> <li>evangelising about the project</li> <li>informing developers of project strengths and weaknesses from a new user\u2019s perspective</li> <li>providing moral support (a \u2018thank you\u2019 goes a long way)</li> <li>providing financial support</li> </ul> <p>Users who continue to engage with the project and its community will often find themselves becoming more and more involved. Such users may then go on to become contributors, as described above.</p>"},{"location":"community/governance/#support","title":"Support","text":"<p>All participants in the community are encouraged to provide support for new users within the project management infrastructure. This support is provided as a way of growing the community. Those seeking support should recognise that all support activity within the project is voluntary and is therefore provided as and when time allows. A user requiring guaranteed response times or results should therefore seek to purchase a support contract from a vendor. (Of course, that vendor should be an active member of the community.) However, for those willing to engage with the project on its own terms, and willing to help support other users, the community support channels are ideal.</p>"},{"location":"community/governance/#contribution-process","title":"Contribution Process","text":"<p>Anyone can contribute to the project, regardless of their skills, as there are many ways to contribute. For instance, a contributor might be active on the project mailing list and issue tracker, or might supply patches. The various ways of contributing are described in more detail in our roles in open source document.</p> <p>The developer mailing list is the most appropriate place for a contributor to ask for help when making their first contribution.</p>"},{"location":"community/governance/#decision-making-process","title":"Decision-Making Process","text":"<p>The benevolent dictatorship model does not need a formal conflict resolution process, since the project lead\u2019s word is final. If the community chooses to question the wisdom of the actions of a committer, the project lead can review their decisions by checking the email archives, and either uphold or reverse them.</p> <p>Source</p> <p>The text was taken from http://oss-watch.ac.uk/resources/benevolentdictatorgovernancemodel.</p>"},{"location":"community/quality_assurance/","title":"Quality assurance","text":"<p>Ensuring quality is paramount for this project, particularly because numerous other projects depend on it. Each commit to the library undergoes rigorous checks against the following requirements, and any violations will result in a failed build.</p>"},{"location":"community/quality_assurance/#c-language-compliance-and-compiler-compatibility","title":"C++ language compliance and compiler compatibility","text":"<p>Requirement: Compiler support</p> <p>Any compiler with complete C++11 support can compile the library without warnings.</p> <ul> <li> <p> The library is compiled with 50+ different C++ compilers with different operating systems and platforms,   including the oldest versions known to compile the library.</p> Compilers used in continuous integration Compiler Architecture Operating System CI AppleClang 15.0.0.15000040; Xcode 15.0.1 x86_64 macOS 13.7.2 (Ventura) GitHub AppleClang 15.0.0.15000100; Xcode 15.1 x86_64 macOS 13.7.2 (Ventura) GitHub AppleClang 15.0.0.15000100; Xcode 15.2 x86_64 macOS 13.7.2 (Ventura) GitHub AppleClang 15.0.0.15000309; Xcode 15.3 arm64 macOS 14.7.2 (Sonoma) GitHub AppleClang 15.0.0.15000309; Xcode 15.4 arm64 macOS 14.7.2 (Sonoma) GitHub AppleClang 16.0.0.16000026; Xcode 16 arm64 macOS 15.2 (Sequoia) GitHub AppleClang 16.0.0.16000026; Xcode 16.1 arm64 macOS 15.2 (Sequoia) GitHub AppleClang 16.0.0.16000026; Xcode 16.2 arm64 macOS 15.2 (Sequoia) GitHub AppleClang 17.0.0.17000013; Xcode 16.3 arm64 macOS 15.5 (Sequoia) GitHub AppleClang 17.0.0.17000013; Xcode 16.4 arm64 macOS 15.5 (Sequoia) GitHub AppleClang 17.0.0.17000319; Xcode 26.0.1 arm64 macOS 15.5 (Sequoia) GitHub Clang 3.5.2 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 3.6.2 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 3.7.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 3.8.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 3.9.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 4.0.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 5.0.2 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 6.0.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 7.1.0 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 8.0.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 9.0.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 10.0.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 11.0.1 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 11.1.0 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 12.0.1 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 12.0.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 13.0.1 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 13.0.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 14.0.6 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 14.0.6 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 15.0.7 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 15.0.7 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 16.0.6 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 16.0.6 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 17.0.6 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 18.1.8 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 18.1.8 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 19.1.5 with MSVC-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 19.1.7 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 19.1.7 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 20.1.1 x86_64 Ubuntu 22.04.1 LTS GitHub Clang 20.1.8 with GNU-like command-line x86_64 Windows Server 2022 (Build 20348) GitHub Clang 21.0.0 x86_64 Ubuntu 22.04.1 LTS GitHub Emscripten 4.0.6 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 4.8.5 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 4.9.3 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 5.5.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 6.4.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 7.5.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 8.5.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 9.3.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 9.4.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 9.5.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 10.5.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 11.4.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 11.5.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 12.2.0 (MinGW-W64 i686-ucrt-posix-dwarf) x86_64 Windows Server 2022 (Build 20348) GitHub GNU 12.2.0 (MinGW-W64 x86_64-ucrt-posix-seh) x86_64 Windows Server 2022 (Build 20348) GitHub GNU 12.4.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 13.3.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 14.2.0 x86_64 Ubuntu 22.04.1 LTS GitHub GNU 14.2.0 arm64 Linux 6.1.100 Cirrus CI GNU 15.1.0 x86_64 Ubuntu 22.04.1 LTS GitHub icpc (ICC) 2021.5.0 20211109 x86_64 Ubuntu 20.04.3 LTS GitHub MSVC 19.0.24241.7 x86 Windows 8.1 AppVeyor MSVC 19.16.27035.0 x86 Windows-10 (Build 14393) AppVeyor MSVC 19.29.30157.0 x86 Windows-10 (Build 17763) AppVeyor MSVC 19.44.35214.0 x86 Windows Server 2022 (Build 20348) GitHub MSVC 19.44.35214.0 x86_64 Windows Server 2022 (Build 20348) GitHub </li> <li> <p> The library is compiled with all C++ language revisions (C++11, C++14, C++17, C++20, C++23, and C++26) to detect   and fix language deprecations early.</p> </li> <li> The library is checked for compiler warnings:</li> <li> <p>On Clang, <code>-Weverything</code> is used with 8 exceptions.</p> Clang warnings <pre><code># Ignored Clang warnings:\n# -Wno-c++98-compat               The library targets C++11.\n# -Wno-c++98-compat-pedantic      The library targets C++11.\n# -Wno-deprecated-declarations    The library contains annotations for deprecated functions.\n# -Wno-extra-semi-stmt            The library uses assert which triggers this warning.\n# -Wno-padded                     We do not care about padding warnings.\n# -Wno-covered-switch-default     All switches list all cases and a default case.\n# -Wno-unsafe-buffer-usage        Otherwise Doctest would not compile.\n# -Wno-missing-noreturn           We found no way to silence this warning otherwise, see PR #4871\n\nset(CLANG_CXXFLAGS\n    -Werror\n    -Weverything\n    -Wno-c++98-compat\n    -Wno-c++98-compat-pedantic\n    -Wno-deprecated-declarations\n    -Wno-extra-semi-stmt\n    -Wno-padded\n    -Wno-covered-switch-default\n    -Wno-unsafe-buffer-usage\n    -Wno-missing-noreturn\n)\n</code></pre> </li> <li> <p>On GCC, 300+ warnings are enabled with 8 exceptions.</p> GCC warnings <pre><code># Warning flags determined for GCC 15.1.0 with https://github.com/nlohmann/gcc_flags:\n# Ignored GCC warnings:\n# -Wno-abi-tag           We do not care about ABI tags.\n# -Wno-aggregate-return  The library uses aggregate returns.\n# -Wno-long-long         The library uses the long long type to interface with system functions.\n# -Wno-namespaces        The library uses namespaces.\n# -Wno-nrvo              Doctest triggers this warning.\n# -Wno-padded            We do not care about padding warnings.\n# -Wno-system-headers    We do not care about warnings in system headers.\n# -Wno-templates         The library uses templates.\n\nset(GCC_CXXFLAGS\n    -pedantic\n    -Werror\n    --all-warnings\n    --extra-warnings\n    -W\n    -WNSObject-attribute\n    -Wno-abi-tag\n    -Waddress\n    -Waddress-of-packed-member\n    -Wno-aggregate-return\n    -Waggressive-loop-optimizations\n    -Waligned-new=all\n    -Wall\n    -Walloc-size\n    -Walloc-zero\n    -Walloca\n    -Wanalyzer-allocation-size\n    -Wanalyzer-deref-before-check\n    -Wanalyzer-double-fclose\n    -Wanalyzer-double-free\n    -Wanalyzer-exposure-through-output-file\n    -Wanalyzer-exposure-through-uninit-copy\n    -Wanalyzer-fd-access-mode-mismatch\n    -Wanalyzer-fd-double-close\n    -Wanalyzer-fd-leak\n    -Wanalyzer-fd-phase-mismatch\n    -Wanalyzer-fd-type-mismatch\n    -Wanalyzer-fd-use-after-close\n    -Wanalyzer-fd-use-without-check\n    -Wanalyzer-file-leak\n    -Wanalyzer-free-of-non-heap\n    -Wanalyzer-imprecise-fp-arithmetic\n    -Wanalyzer-infinite-loop\n    -Wanalyzer-infinite-recursion\n    -Wanalyzer-jump-through-null\n    -Wanalyzer-malloc-leak\n    -Wanalyzer-mismatching-deallocation\n    -Wanalyzer-null-argument\n    -Wanalyzer-null-dereference\n    -Wanalyzer-out-of-bounds\n    -Wanalyzer-overlapping-buffers\n    -Wanalyzer-possible-null-argument\n    -Wanalyzer-possible-null-dereference\n    -Wanalyzer-putenv-of-auto-var\n    -Wanalyzer-shift-count-negative\n    -Wanalyzer-shift-count-overflow\n    -Wanalyzer-stale-setjmp-buffer\n    -Wanalyzer-symbol-too-complex\n    -Wanalyzer-tainted-allocation-size\n    -Wanalyzer-tainted-array-index\n    -Wanalyzer-tainted-assertion\n    -Wanalyzer-tainted-divisor\n    -Wanalyzer-tainted-offset\n    -Wanalyzer-tainted-size\n    -Wanalyzer-too-complex\n    -Wanalyzer-undefined-behavior-ptrdiff\n    -Wanalyzer-undefined-behavior-strtok\n    -Wanalyzer-unsafe-call-within-signal-handler\n    -Wanalyzer-use-after-free\n    -Wanalyzer-use-of-pointer-in-stale-stack-frame\n    -Wanalyzer-use-of-uninitialized-value\n    -Wanalyzer-va-arg-type-mismatch\n    -Wanalyzer-va-list-exhausted\n    -Wanalyzer-va-list-leak\n    -Wanalyzer-va-list-use-after-va-end\n    -Wanalyzer-write-to-const\n    -Wanalyzer-write-to-string-literal\n    -Warith-conversion\n    -Warray-bounds=2\n    -Warray-compare\n    -Warray-parameter=2\n    -Wattribute-alias=2\n    -Wattribute-warning\n    -Wattributes\n    -Wbool-compare\n    -Wbool-operation\n    -Wbuiltin-declaration-mismatch\n    -Wbuiltin-macro-redefined\n    -Wc++0x-compat\n    -Wc++11-compat\n    -Wc++11-extensions\n    -Wc++14-compat\n    -Wc++14-extensions\n    -Wc++17-compat\n    -Wc++17-extensions\n    -Wc++1z-compat\n    -Wc++20-compat\n    -Wc++20-extensions\n    -Wc++23-extensions\n    -Wc++26-extensions\n    -Wc++2a-compat\n    -Wcalloc-transposed-args\n    -Wcannot-profile\n    -Wcast-align\n    -Wcast-align=strict\n    -Wcast-function-type\n    -Wcast-qual\n    -Wcast-user-defined\n    -Wcatch-value=3\n    -Wchanges-meaning\n    -Wchar-subscripts\n    -Wclass-conversion\n    -Wclass-memaccess\n    -Wclobbered\n    -Wcomma-subscript\n    -Wcomment\n    -Wcomments\n    -Wcomplain-wrong-lang\n    -Wconditionally-supported\n    -Wconversion\n    -Wconversion-null\n    -Wcoverage-invalid-line-number\n    -Wcoverage-mismatch\n    -Wcoverage-too-many-conditions\n    -Wcoverage-too-many-paths\n    -Wcpp\n    -Wctad-maybe-unsupported\n    -Wctor-dtor-privacy\n    -Wdangling-else\n    -Wdangling-pointer=2\n    -Wdangling-reference\n    -Wdate-time\n    -Wdefaulted-function-deleted\n    -Wdelete-incomplete\n    -Wdelete-non-virtual-dtor\n    -Wdeprecated\n    -Wdeprecated-copy\n    -Wdeprecated-copy-dtor\n    -Wdeprecated-declarations\n    -Wdeprecated-enum-enum-conversion\n    -Wdeprecated-enum-float-conversion\n    -Wdeprecated-literal-operator\n    -Wdeprecated-variadic-comma-omission\n    -Wdisabled-optimization\n    -Wdiv-by-zero\n    -Wdouble-promotion\n    -Wduplicated-branches\n    -Wduplicated-cond\n    -Weffc++\n    -Welaborated-enum-base\n    -Wempty-body\n    -Wendif-labels\n    -Wenum-compare\n    -Wenum-conversion\n    -Wexceptions\n    -Wexpansion-to-defined\n    -Wextra\n    -Wextra-semi\n    -Wflex-array-member-not-at-end\n    -Wfloat-conversion\n    -Wfloat-equal\n    -Wformat -Wformat-contains-nul\n    -Wformat -Wformat-diag\n    -Wformat -Wformat-extra-args\n    -Wformat -Wformat-nonliteral\n    -Wformat -Wformat-overflow=2\n    -Wformat -Wformat-security\n    -Wformat -Wformat-signedness\n    -Wformat -Wformat-truncation=2\n    -Wformat -Wformat-y2k\n    -Wformat -Wformat-zero-length\n    -Wformat=2\n    -Wframe-address\n    -Wfree-nonheap-object\n    -Wglobal-module\n    -Whardened\n    -Wheader-guard\n    -Whsa\n    -Wif-not-aligned\n    -Wignored-attributes\n    -Wignored-qualifiers\n    -Wimplicit-fallthrough=5\n    -Winaccessible-base\n    -Winfinite-recursion\n    -Winherited-variadic-ctor\n    -Winit-list-lifetime\n    -Winit-self\n    -Winline\n    -Wint-in-bool-context\n    -Wint-to-pointer-cast\n    -Winterference-size\n    -Winvalid-constexpr\n    -Winvalid-imported-macros\n    -Winvalid-memory-model\n    -Winvalid-offsetof\n    -Winvalid-pch\n    -Winvalid-utf8\n    -Wliteral-suffix\n    -Wlogical-not-parentheses\n    -Wlogical-op\n    -Wno-long-long\n    -Wlto-type-mismatch\n    -Wmain\n    -Wmaybe-musttail-local-addr\n    -Wmaybe-uninitialized\n    -Wmemset-elt-size\n    -Wmemset-transposed-args\n    -Wmisleading-indentation\n    -Wmismatched-dealloc\n    -Wmismatched-new-delete\n    -Wmismatched-tags\n    -Wmissing-attributes\n    -Wmissing-braces\n    -Wmissing-declarations\n    -Wmissing-field-initializers\n    -Wmissing-include-dirs\n    -Wmissing-profile\n    -Wmissing-requires\n    -Wmissing-template-keyword\n    -Wmultichar\n    -Wmultiple-inheritance\n    -Wmultistatement-macros\n    -Wmusttail-local-addr\n    -Wno-namespaces\n    -Wnarrowing\n    -Wnoexcept\n    -Wnoexcept-type\n    -Wnon-template-friend\n    -Wnon-virtual-dtor\n    -Wnonnull\n    -Wnonnull-compare\n    -Wnormalized=nfkc\n    -Wno-nrvo\n    -Wnull-dereference\n    -Wodr\n    -Wold-style-cast\n    -Wopenacc-parallelism\n    -Wopenmp\n    -Wopenmp-simd\n    -Woverflow\n    -Woverlength-strings\n    -Woverloaded-virtual=2\n    -Wpacked\n    -Wpacked-bitfield-compat\n    -Wpacked-not-aligned\n    -Wno-padded\n    -Wparentheses\n    -Wpedantic\n    -Wpessimizing-move\n    -Wplacement-new=2\n    -Wpmf-conversions\n    -Wpointer-arith\n    -Wpointer-compare\n    -Wpragma-once-outside-header\n    -Wpragmas\n    -Wprio-ctor-dtor\n    -Wpsabi\n    -Wrange-loop-construct\n    -Wredundant-decls\n    -Wredundant-move\n    -Wredundant-tags\n    -Wregister\n    -Wreorder\n    -Wrestrict\n    -Wreturn-local-addr\n    -Wreturn-type\n    -Wscalar-storage-order\n    -Wself-move\n    -Wsequence-point\n    -Wshadow=compatible-local\n    -Wshadow=global\n    -Wshadow=local\n    -Wshift-count-negative\n    -Wshift-count-overflow\n    -Wshift-negative-value\n    -Wshift-overflow=2\n    -Wsign-compare\n    -Wsign-conversion\n    -Wsign-promo\n    -Wsized-deallocation\n    -Wsizeof-array-argument\n    -Wsizeof-array-div\n    -Wsizeof-pointer-div\n    -Wsizeof-pointer-memaccess\n    -Wstack-protector\n    -Wstrict-aliasing\n    -Wstrict-aliasing=3\n    -Wstrict-null-sentinel\n    -Wstrict-overflow\n    -Wstring-compare\n    -Wstringop-overflow\n    -Wstringop-overflow=4\n    -Wstringop-overread\n    -Wstringop-truncation\n    -Wsubobject-linkage\n    -Wsuggest-attribute=cold\n    -Wsuggest-attribute=const\n    -Wsuggest-attribute=format\n    -Wsuggest-attribute=malloc\n    -Wsuggest-attribute=noreturn\n    -Wsuggest-attribute=pure\n    -Wsuggest-attribute=returns_nonnull\n    -Wsuggest-final-methods\n    -Wsuggest-final-types\n    -Wsuggest-override\n    -Wswitch\n    -Wswitch-bool\n    -Wswitch-default\n    -Wswitch-enum\n    -Wswitch-outside-range\n    -Wswitch-unreachable\n    -Wsync-nand\n    -Wsynth\n    -Wno-system-headers\n    -Wtautological-compare\n    -Wtemplate-body\n    -Wtemplate-id-cdtor\n    -Wtemplate-names-tu-local\n    -Wno-templates\n    -Wterminate\n    -Wtrailing-whitespace\n    -Wtrampolines\n    -Wtrigraphs\n    -Wtrivial-auto-var-init\n    -Wtsan\n    -Wtype-limits\n    -Wundef\n    -Wunicode\n    -Wuninitialized\n    -Wunknown-pragmas\n    -Wunreachable-code\n    -Wunsafe-loop-optimizations\n    -Wunused\n    -Wunused-but-set-parameter\n    -Wunused-but-set-variable\n    -Wunused-const-variable=2\n    -Wunused-function\n    -Wunused-label\n    -Wunused-local-typedefs\n    -Wunused-macros\n    -Wunused-parameter\n    -Wunused-result\n    -Wunused-value\n    -Wunused-variable\n    -Wuse-after-free=3\n    -Wuseless-cast\n    -Wvarargs\n    -Wvariadic-macros\n    -Wvector-operation-performance\n    -Wvexing-parse\n    -Wvirtual-inheritance\n    -Wvirtual-move-assign\n    -Wvla\n    -Wvla-parameter\n    -Wvolatile\n    -Wvolatile-register-var\n    -Wwrite-strings\n    -Wxor-used-as-pow\n    -Wzero-as-null-pointer-constant\n    -Wzero-length-bounds\n)\n</code></pre> </li> </ul>"},{"location":"community/quality_assurance/#c-standard-library-compliance","title":"C++ standard library compliance","text":"<p>Requirement: No prerequisites</p> <p>The library has no prerequisites other than the Standard Template Library (STL).</p> <ul> <li> The library is compiled and tested with both libc++ and   libstdc++ to detect subtle differences or incompatibilities.</li> <li> The code checked with Include What You Use (IWYU) that all required standard   headers are included.</li> <li> On Windows, the library is compiled with <code>&lt;Windows.h&gt;</code> being included to detect and avoid common bugs.</li> <li> The library is compiled with exceptions disabled to support alternative means of error handling.</li> </ul>"},{"location":"community/quality_assurance/#stable-public-api","title":"Stable public API","text":"<p>Requirement: Stable public API</p> <p>Any change to the library does not break the public API.</p> <ul> <li> All public API functions are tested with a variety of arguments.</li> <li> The library is compiled and tested with different template arguments for number, string, array, and object types.</li> <li> Unit tests cover all lines of the code base.</li> <li> Every exception of the library is thrown in the test suite, and the error messages and exception ids are checked.</li> </ul> <p>Requirement: Complete documentation</p> <p>The public API is extensively documented.</p> <ul> <li> Every public API function has a dedicated page in the   API reference documentation with a self-contained code example.</li> <li> All examples in the documentation are tested, and changes in their output are treated as an error.</li> </ul>"},{"location":"community/quality_assurance/#robust-input-processing","title":"Robust input processing","text":"<p>Requirement: Standards compliance</p> <p>The library is compliant to JSON as defined in RFC 8259.</p> <ul> <li> The lexer is tested with all valid Unicode code points and all prefixes of all invalid Unicode code points.</li> <li> The parser is tested against extensive correctness suites for JSON compliance.</li> <li> In addition, the library is continuously fuzz-tested at OSS-Fuzz where the   library is checked against billions of inputs.</li> </ul>"},{"location":"community/quality_assurance/#static-analysis","title":"Static analysis","text":"<p>Requirement: State-of-the-art code analysis</p> <p>The code is checked with state-of-the-art static code analysis tools.</p> <ul> <li> <p> The code is checked with the latest Clang-Tidy.</p> Clang-Tidy configuration (.clang-tidy) <pre><code># TODO: The first three checks are only removed to get the CI going. They have to be addressed at some point.\n# TODO: portability-avoid-pragma-once: should be fixed eventually\n\nChecks: '*,\n\n         -portability-template-virtual-member-function,\n         -bugprone-use-after-move,\n         -hicpp-invalid-access-moved,\n\n         -altera-id-dependent-backward-branch,\n         -altera-struct-pack-align,\n         -altera-unroll-loops,\n         -android-cloexec-fopen,\n         -boost-use-ranges,\n         -bugprone-easily-swappable-parameters,\n         -cert-err58-cpp,\n         -clang-analyzer-webkit.NoUncountedMemberChecker,\n         -concurrency-mt-unsafe,\n         -cppcoreguidelines-avoid-const-or-ref-data-members,\n         -cppcoreguidelines-avoid-do-while,\n         -cppcoreguidelines-avoid-goto,\n         -cppcoreguidelines-avoid-magic-numbers,\n         -cppcoreguidelines-avoid-non-const-global-variables,\n         -cppcoreguidelines-macro-usage,\n         -cppcoreguidelines-pro-bounds-avoid-unchecked-container-access,\n         -cppcoreguidelines-pro-bounds-array-to-pointer-decay,\n         -cppcoreguidelines-pro-bounds-constant-array-index,\n         -cppcoreguidelines-pro-bounds-pointer-arithmetic,\n         -cppcoreguidelines-pro-type-reinterpret-cast,\n         -cppcoreguidelines-pro-type-union-access,\n         -cppcoreguidelines-rvalue-reference-param-not-moved,\n         -cppcoreguidelines-virtual-class-destructor,\n         -fuchsia-default-arguments-calls,\n         -fuchsia-default-arguments-declarations,\n         -fuchsia-overloaded-operator,\n         -google-explicit-constructor,\n         -google-readability-function-size,\n         -google-runtime-float,\n         -google-runtime-int,\n         -google-runtime-references,\n         -hicpp-avoid-goto,\n         -hicpp-explicit-conversions,\n         -hicpp-function-size,\n         -hicpp-no-array-decay,\n         -hicpp-no-assembler,\n         -hicpp-signed-bitwise,\n         -hicpp-uppercase-literal-suffix,\n         -llvm-header-guard,\n         -llvm-include-order,\n         -llvm-prefer-static-over-anonymous-namespace,\n         -llvm-use-ranges,\n         -llvmlibc-*,\n         -misc-use-anonymous-namespace,\n         -misc-confusable-identifiers,\n         -misc-include-cleaner,\n         -misc-no-recursion,\n         -misc-non-private-member-variables-in-classes,\n         -modernize-concat-nested-namespaces,\n         -modernize-type-traits,\n         -modernize-use-constraints,\n         -modernize-use-designated-initializers,\n         -modernize-use-nodiscard,\n         -modernize-use-ranges,\n         -modernize-use-std-numbers,\n         -modernize-use-trailing-return-type,\n         -performance-enum-size,\n         -portability-avoid-pragma-once,\n         -readability-function-cognitive-complexity,\n         -readability-function-size,\n         -readability-identifier-length,\n         -readability-magic-numbers,\n         -readability-redundant-access-specifiers,\n         -readability-redundant-parentheses,\n         -readability-simplify-boolean-expr,\n         -readability-uppercase-literal-suffix,\n         -readability-use-concise-preprocessor-directives'\n\nCheckOptions:\n  - key: hicpp-special-member-functions.AllowSoleDefaultDtor\n    value: 1\n\nWarningsAsErrors: '*'\n\n#HeaderFilterRegex: '.*nlohmann.*'\nHeaderFilterRegex: '.*hpp$'\n</code></pre> </li> <li> <p> The code is checked with the latest Cppcheck with all warnings enabled.</p> </li> <li> The code is checked with the latest Clang Static Analyzer with 89 enabled   rules.</li> <li> The code is checked with Infer.</li> <li> The code is checked with Codacy.</li> </ul>"},{"location":"community/quality_assurance/#dynamic-analysis","title":"Dynamic analysis","text":"<p>Requirement: Correctness</p> <p>The library is checked for memory correctness and absence of undefined behavior.</p> <ul> <li> The test suite is executed with enabled runtime assertions to   check invariants and preconditions of functions to detect undefined behavior.</li> <li> The test suite is executed with Valgrind (Memcheck) to detect memory leaks.</li> <li> The test suite is executed with Sanitizers (address sanitizer, undefined   behavior sanitizer, integer overflow detection, nullability violations).</li> </ul>"},{"location":"community/quality_assurance/#style-check","title":"Style check","text":"<p>Requirement: Common code style</p> <p>A common code style is used throughout all code files of the library.</p> <ul> <li> <p> The code is formatted with Artistic Style (astyle) against a style configuration   that is also enforced in the CI.</p> Astyle configuration (tools/astyle/.astylerc) <pre><code># Configuration for Artistic Style\n# see https://astyle.sourceforge.net/astyle.html\n\n#######################\n# Brace Style Options #\n#######################\n\n# use Allman style for braces\n--style=allman\n\n###############\n# Tab Options #\n###############\n\n# indent using 4 spaces\n--indent=spaces=4\n\n#######################\n# Indentation Options #\n#######################\n\n# indent access modifiers one half indent\n--indent-modifiers\n\n# indent switch cases to the switch block\n--indent-switches\n\n# indent preprocessor blocks\n--indent-preproc-block\n\n# indent preprocessor defines\n--indent-preproc-define\n\n# indent C++ comments\n--indent-col1-comments\n\n###################\n# Padding Options #\n###################\n\n# insert space padding around operators\n--pad-oper\n\n# insert space between if/for/while... and the following parentheses\n--pad-header\n\n# attach the pointer to the variable type (left)\n--align-pointer=type\n\n# attach the reference to the variable type (left)\n--align-reference=type\n\n######################\n# Formatting Options #\n######################\n\n# add braces to unbraced one line conditional statements\n--add-braces\n\n# convert tabs to spaces\n--convert-tabs\n\n# closes whitespace between the ending angle brackets of template definitions\n--close-templates\n\n#################\n# Other Options #\n#################\n\n# do not create backup files\n--suffix=none\n\n# preserve the original file date\n--preserve-date\n\n# display only the files that have been formatted\n--formatted\n\n# for the linux (LF) line end style\n--lineend=linux\n</code></pre> </li> <li> <p> The code style is checked with cpplint with 61 enabled rules.</p> </li> </ul>"},{"location":"community/quality_assurance/#simple-integration","title":"Simple integration","text":"<p>Requirement: Single header</p> <p>The library can be used by adding a single header to a C++ project.</p> <ul> <li> An amalgamation script is used to check if the source code is exposed as a self-contained single-header file.</li> <li> The test suite is checked against the amalgamated source file as well as the individual source file.</li> </ul> <p>Requirement: CMake as primary development tool</p> <p>All library functions are exposed and usable by CMake.</p> <ul> <li> All library options are exposed as CMake options and tested.</li> <li> The library is tested against relevant CMake versions:</li> <li>CMake 3.5 (the earliest supported)</li> <li>CMake 3.31.6 (the latest 3.x release)</li> <li>CMake 4.0.0 (a very recent release)</li> </ul>"},{"location":"community/security_policy/","title":"Security Policy","text":""},{"location":"community/security_policy/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>We value the security of our users and appreciate your efforts to responsibly disclose vulnerabilities. If you have identified a security vulnerability in this repository, please use the GitHub Security Advisory \"Report a Vulnerability\" tab.</p> <p>Until it is published, this draft security advisory will only be visible to the maintainers of this project. Other users and teams may be added once the advisory is created.</p> <p>We will send a response indicating the next steps in handling your report. After the initial reply to your report, we will keep you informed of the progress towards a fix and full announcement and may ask for additional information or guidance.</p> <p>For vulnerabilities in third-party dependencies or modules, please report them directly to the respective maintainers.</p>"},{"location":"community/security_policy/#additional-resources","title":"Additional Resources","text":"<ul> <li>Explore security-related topics and contribute to tools and projects through   GitHub Security Lab.</li> <li>Learn more about responsible disclosure and reporting vulnerabilities in GitHub at   About coordinated disclosure of security vulnerabilities.</li> </ul> <p>We sincerely thank you for contributing to the security and integrity of this project!</p>"},{"location":"features/arbitrary_types/","title":"Arbitrary Type Conversions","text":"<p>Every type can be serialized in JSON, not just STL containers and scalar types. Usually, you would do something along those lines:</p> <pre><code>namespace ns {\n    // a simple struct to model a person\n    struct person {\n        std::string name;\n        std::string address;\n        int age;\n    };\n} // namespace ns\n\nns::person p = {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n// convert to JSON: copy each value into the JSON object\njson j;\nj[\"name\"] = p.name;\nj[\"address\"] = p.address;\nj[\"age\"] = p.age;\n\n// ...\n\n// convert from JSON: copy each value from the JSON object\nns::person p {\n    j[\"name\"].template get&lt;std::string&gt;(),\n    j[\"address\"].template get&lt;std::string&gt;(),\n    j[\"age\"].template get&lt;int&gt;()\n};\n</code></pre> <p>It works, but that's quite a lot of boilerplate... Fortunately, there's a better way:</p> <pre><code>// create a person\nns::person p {\"Ned Flanders\", \"744 Evergreen Terrace\", 60};\n\n// conversion: person -&gt; json\njson j = p;\n\nstd::cout &lt;&lt; j &lt;&lt; std::endl;\n// {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"}\n\n// conversion: json -&gt; person\nauto p2 = j.template get&lt;ns::person&gt;();\n\n// that's it\nassert(p == p2);\n</code></pre>"},{"location":"features/arbitrary_types/#basic-usage","title":"Basic usage","text":"<p>To make this work with one of your types, you only need to provide two functions:</p> <pre><code>using json = nlohmann::json;\n\nnamespace ns {\n    void to_json(json&amp; j, const person&amp; p) {\n        j = json{ {\"name\", p.name}, {\"address\", p.address}, {\"age\", p.age} };\n    }\n\n    void from_json(const json&amp; j, person&amp; p) {\n        j.at(\"name\").get_to(p.name);\n        j.at(\"address\").get_to(p.address);\n        j.at(\"age\").get_to(p.age);\n    }\n} // namespace ns\n</code></pre> <p>That's all! When calling the <code>json</code> constructor with your type, your custom <code>to_json</code> method will be automatically called. Likewise, when calling <code>template get&lt;your_type&gt;()</code> or <code>get_to(your_type&amp;)</code>, the <code>from_json</code> method will be called.</p> <p>Some important things:</p> <ul> <li>Those methods MUST be in your type's namespace (which can be the global namespace), or the library will not be able to locate them (in this example, they are in namespace <code>ns</code>, where <code>person</code> is defined).</li> <li>Those methods MUST be available (e.g., proper headers must be included) everywhere you use these conversions. Look at #1108 for errors that may occur otherwise.</li> <li>When using <code>template get&lt;your_type&gt;()</code>, <code>your_type</code> MUST be DefaultConstructible. (There is a way to bypass this requirement described later.)</li> <li>In function <code>from_json</code>, use function <code>at()</code> to access the object values rather than <code>operator[]</code>. In case a key does not exist, <code>at</code> throws an exception that you can handle, whereas <code>operator[]</code> exhibits undefined behavior.</li> <li>You do not need to add serializers or deserializers for STL types like <code>std::vector</code>: the library already implements these.</li> </ul>"},{"location":"features/arbitrary_types/#simplify-your-life-with-macros","title":"Simplify your life with macros","text":"<p>If you just want to serialize/deserialize some structs, the <code>to_json</code>/<code>from_json</code> functions can be a lot of boilerplate.</p> <p>There are six macros to make your life easier as long as you (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object:</p> <ul> <li><code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(name, member1, member2, ...)</code> is to be defined inside the namespace of the class/struct to create code for. It will throw an exception in <code>from_json()</code> due to a missing value in the JSON object.</li> <li><code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(name, member1, member2, ...)</code> is to be defined inside the namespace of the class/struct to create code for. It will not throw an exception in <code>from_json()</code> due to a missing value in the JSON object, but fills in values from an object which is default-constructed by the type.</li> <li><code>NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(name, member1, member2, ...)</code> is to be defined inside the namespace of the class/struct to create code for. It does not define a <code>from_json()</code> function which is needed in case the type does not have a default constructor.</li> <li><code>NLOHMANN_DEFINE_TYPE_INTRUSIVE(name, member1, member2, ...)</code> is to be defined inside the class/struct to create code for. This macro can also access private members. It will throw an exception in <code>from_json()</code> due to a missing value in the JSON object.</li> <li><code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(name, member1, member2, ...)</code> is to be defined inside the class/struct to create code for. This macro can also access private members. It will not throw an exception in <code>from_json()</code> due to a missing value in the JSON object, but fills in values from an object which is default-constructed by the type.</li> <li><code>NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE(name, member1, member2, ...)</code> is to be defined inside the class/struct to create code for. This macro can also access private members. It does not define a <code>from_json()</code> function which is needed in case the type does not have a default constructor.</li> </ul> <p>Furthermore, there exist versions to use in the case of derived classes:</p> Need access to private members Need only de-serialization Allow missing values when de-serializing macro NLOHMANN_DEFINE_TYPE_INTRUSIVE NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE <p>For derived classes and structs, use the following macros</p> Need access to private members Need only de-serialization Allow missing values when de-serializing macro NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE <p>Implementation limits</p> <ul> <li>The current macro implementations are limited to at most 64 member variables. If you want to serialize/deserialize   types with more than 64 member variables, you need to define the <code>to_json</code>/<code>from_json</code> functions manually.</li> </ul> Example <p>The <code>to_json</code>/<code>from_json</code> functions for the <code>person</code> struct above can be created with:</p> <pre><code>namespace ns {\n    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(person, name, address, age)\n}\n</code></pre> <p>Here is an example with private members, where <code>NLOHMANN_DEFINE_TYPE_INTRUSIVE</code> is needed:</p> <pre><code>namespace ns {\n    class address {\n      private:\n        std::string street;\n        int housenumber;\n        int postcode;\n\n      public:\n        NLOHMANN_DEFINE_TYPE_INTRUSIVE(address, street, housenumber, postcode)\n    };\n}\n</code></pre>"},{"location":"features/arbitrary_types/#how-do-i-convert-third-party-types","title":"How do I convert third-party types?","text":"<p>This requires a bit more advanced technique. But first, let us see how this conversion mechanism works:</p> <p>The library uses JSON Serializers to convert types to JSON. The default serializer for <code>nlohmann::json</code> is <code>nlohmann::adl_serializer</code> (ADL means Argument-Dependent Lookup).</p> <p>It is implemented like this (simplified):</p> <pre><code>template &lt;typename T&gt;\nstruct adl_serializer {\n    static void to_json(json&amp; j, const T&amp; value) {\n        // calls the \"to_json\" method in T's namespace\n    }\n\n    static void from_json(const json&amp; j, T&amp; value) {\n        // same thing, but with the \"from_json\" method\n    }\n};\n</code></pre> <p>This serializer works fine when you have control over the type's namespace. However, what about <code>boost::optional</code> or <code>std::filesystem::path</code> (C++17)? Hijacking the <code>boost</code> namespace is pretty bad, and it's illegal to add something other than template specializations to <code>std</code>...</p> <p>To solve this, you need to add a specialization of <code>adl_serializer</code> to the <code>nlohmann</code> namespace, here's an example:</p> <pre><code>// partial specialization (full specialization works too)\nNLOHMANN_JSON_NAMESPACE_BEGIN\ntemplate &lt;typename T&gt;\nstruct adl_serializer&lt;boost::optional&lt;T&gt;&gt; {\n    static void to_json(json&amp; j, const boost::optional&lt;T&gt;&amp; opt) {\n        if (opt == boost::none) {\n            j = nullptr;\n        } else {\n            j = *opt; // this will call adl_serializer&lt;T&gt;::to_json which will\n                      // find the free function to_json in T's namespace!\n        }\n    }\n\n    static void from_json(const json&amp; j, boost::optional&lt;T&gt;&amp; opt) {\n        if (j.is_null()) {\n            opt = boost::none;\n        } else {\n            opt = j.template get&lt;T&gt;(); // same as above, but with\n                              // adl_serializer&lt;T&gt;::from_json\n        }\n    }\n};\nNLOHMANN_JSON_NAMESPACE_END\n</code></pre> <p>ABI compatibility</p> <p>Use <code>NLOHMANN_JSON_NAMESPACE_BEGIN</code> and <code>NLOHMANN_JSON_NAMESPACE_END</code> instead of <code>namespace nlohmann { }</code> in code which may be linked with different versions of this library.</p>"},{"location":"features/arbitrary_types/#how-can-i-use-get-for-non-default-constructiblenon-copyable-types","title":"How can I use <code>get()</code> for non-default constructible/non-copyable types?","text":"<p>There is a way if your type is MoveConstructible. You will need to specialize the <code>adl_serializer</code> as well, but with a special <code>from_json</code> overload:</p> <pre><code>struct move_only_type {\n    move_only_type() = delete;\n    move_only_type(int ii): i(ii) {}\n    move_only_type(const move_only_type&amp;) = delete;\n    move_only_type(move_only_type&amp;&amp;) = default;\n\n    int i;\n};\n\nnamespace nlohmann {\n    template &lt;&gt;\n    struct adl_serializer&lt;move_only_type&gt; {\n        // note: the return type is no longer 'void', and the method only takes\n        // one argument\n        static move_only_type from_json(const json&amp; j) {\n            return {j.template get&lt;int&gt;()};\n        }\n\n        // Here's the catch! You must provide a to_json method! Otherwise, you\n        // will not be able to convert move_only_type to json, since you fully\n        // specialized adl_serializer on that type\n        static void to_json(json&amp; j, move_only_type t) {\n            j = t.i;\n        }\n    };\n}\n</code></pre>"},{"location":"features/arbitrary_types/#can-i-write-my-own-serializer-advanced-use","title":"Can I write my own serializer? (Advanced use)","text":"<p>Yes. You might want to take a look at <code>unit-udt.cpp</code> in the test suite, to see a few examples.</p> <p>If you write your own serializer, you will need to do a few things:</p> <ul> <li>use a different <code>basic_json</code> alias than <code>nlohmann::json</code> (the last template parameter of <code>basic_json</code> is the <code>JSONSerializer</code>)</li> <li>use your <code>basic_json</code> alias (or a template parameter) in all your <code>to_json</code>/<code>from_json</code> methods</li> <li>use <code>nlohmann::to_json</code> and <code>nlohmann::from_json</code> when you need ADL</li> </ul> <p>Here is an example, without simplifications, that only accepts types with a size &lt;= 32, and uses ADL.</p> <pre><code>// You should use void as a second template argument\n// if you don't need compile-time checks on T\ntemplate&lt;typename T, typename SFINAE = typename std::enable_if&lt;sizeof(T) &lt;= 32&gt;::type&gt;\nstruct less_than_32_serializer {\n    template &lt;typename BasicJsonType&gt;\n    static void to_json(BasicJsonType&amp; j, T value) {\n        // we want to use ADL, and call the correct to_json overload\n        using nlohmann::to_json; // this method is called by adl_serializer,\n                                 // this is where the magic happens\n        to_json(j, value);\n    }\n\n    template &lt;typename BasicJsonType&gt;\n    static void from_json(const BasicJsonType&amp; j, T&amp; value) {\n        // same thing here\n        using nlohmann::from_json;\n        from_json(j, value);\n    }\n};\n</code></pre> <p>Be very careful when reimplementing your serializer, you can stack overflow if you don't pay attention:</p> <pre><code>template &lt;typename T, void&gt;\nstruct bad_serializer\n{\n    template &lt;typename BasicJsonType&gt;\n    static void to_json(BasicJsonType&amp; j, const T&amp; value) {\n      // this calls BasicJsonType::json_serializer&lt;T&gt;::to_json(j, value);\n      // if BasicJsonType::json_serializer == bad_serializer ... oops!\n      j = value;\n    }\n\n    template &lt;typename BasicJsonType&gt;\n    static void from_json(const BasicJsonType&amp; j, T&amp; value) {\n      // this calls BasicJsonType::json_serializer&lt;T&gt;::from_json(j, value);\n      // if BasicJsonType::json_serializer == bad_serializer ... oops!\n      value = j.template template get&lt;T&gt;(); // oops!\n    }\n};\n</code></pre>"},{"location":"features/assertions/","title":"Runtime Assertions","text":"<p>The code contains numerous debug assertions to ensure class invariants are valid or to detect undefined behavior. Whereas the former class invariants are nothing to be concerned with, the latter checks for undefined behavior are to detect bugs in client code.</p>"},{"location":"features/assertions/#switch-off-runtime-assertions","title":"Switch off runtime assertions","text":"<p>Runtime assertions can be switched off by defining the preprocessor macro <code>NDEBUG</code> (see the documentation of assert) which is the default for release builds.</p>"},{"location":"features/assertions/#change-assertion-behavior","title":"Change assertion behavior","text":"<p>The behavior of runtime assertions can be changes by defining macro <code>JSON_ASSERT(x)</code> before including the <code>json.hpp</code> header.</p>"},{"location":"features/assertions/#function-with-runtime-assertions","title":"Function with runtime assertions","text":""},{"location":"features/assertions/#unchecked-object-access-to-a-const-value","title":"Unchecked object access to a const value","text":"<p>Function <code>operator[]</code> implements unchecked access for objects. Whereas a missing key is added in the case of non-const objects, accessing a const object with a missing key is undefined behavior (think of a dereferenced null pointer) and yields a runtime assertion.</p> <p>If you are not sure whether an element in an object exists, use checked access with the <code>at</code> function or call the <code>contains</code> function before.</p> <p>See also the documentation on element access.</p> Example 1: Missing object key <p>The following code will trigger an assertion at runtime:</p> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    const json j = {{\"key\", \"value\"}};\n    auto v = j[\"missing\"];\n}\n</code></pre> <p>Output:</p> <pre><code>Assertion failed: (m_value.object-&gt;find(key) != m_value.object-&gt;end()), function operator[], file json.hpp, line 2144.\n</code></pre>"},{"location":"features/assertions/#constructing-from-an-uninitialized-iterator-range","title":"Constructing from an uninitialized iterator range","text":"<p>Constructing a JSON value from an iterator range (see constructor) with an uninitialized iterator is undefined behavior and yields a runtime assertion.</p> Example 2: Uninitialized iterator range <p>The following code will trigger an assertion at runtime:</p> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json::iterator it1, it2;\n    json j(it1, it2);\n}\n</code></pre> <p>Output:</p> <pre><code>Assertion failed: (m_object != nullptr), function operator++, file iter_impl.hpp, line 368.\n</code></pre>"},{"location":"features/assertions/#operations-on-uninitialized-iterators","title":"Operations on uninitialized iterators","text":"<p>Any operation on uninitialized iterators (i.e., iterators that are not associated with any JSON value) is undefined behavior and yields a runtime assertion.</p> Example 3: Uninitialized iterator <p>The following code will trigger an assertion at runtime:</p> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n  json::iterator it;\n  ++it;\n}\n</code></pre> <p>Output:</p> <pre><code>Assertion failed: (m_object != nullptr), function operator++, file iter_impl.hpp, line 368.\n</code></pre>"},{"location":"features/assertions/#changes","title":"Changes","text":""},{"location":"features/assertions/#reading-from-a-null-file-or-char-pointer","title":"Reading from a null <code>FILE</code> or <code>char</code> pointer","text":"<p>Reading from a null <code>FILE</code> or <code>char</code> pointer in C++ is undefined behavior.  Until version 3.12.0, this library asserted that the pointer was not <code>nullptr</code> using a runtime assertion. If assertions were disabled, this would result in undefined behavior. Since version 3.12.0, this library checks for <code>nullptr</code> and throws a <code>parse_error.101</code> to prevent the undefined behavior.</p> Example 4: Reading from null pointer <p>The following code will trigger an assertion at runtime:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::FILE* f = std::fopen(\"nonexistent_file.json\", \"r\");\n    try {\n        json j = json::parse(f);\n    } catch (std::exception&amp; e) {\n        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.101] parse error: attempting to parse an empty input; check that your input string or stream contains the expected JSON\n</code></pre>"},{"location":"features/assertions/#see-also","title":"See also","text":"<ul> <li>JSON_ASSERT - control behavior of runtime assertions</li> </ul>"},{"location":"features/binary_values/","title":"Binary Values","text":"<p>The library implements several binary formats that encode JSON in an efficient way. Most of these formats support binary values; that is, values that have semantics defined outside the library and only define a sequence of bytes to be stored.</p> <p>JSON itself does not have a binary value. As such, binary values are an extension that this library implements to store values received by a binary format. Binary values are never created by the JSON parser and are only part of a serialized JSON text if they have been created manually or via a binary format.</p>"},{"location":"features/binary_values/#api-for-binary-values","title":"API for binary values","text":"<pre><code>classDiagram\n\nclass binary_t [\"json::binary_t\"] {\n    +void set_subtype(std::uint64_t subtype)\n    +void clear_subtype()\n    +std::uint64_t subtype() const\n    +bool has_subtype() const\n}\n\nclass vector [\"std::vector&lt;uint8_t&gt;\"]\n\nvector &lt;|-- binary_t</code></pre> <p>By default, binary values are stored as <code>std::vector&lt;std::uint8_t&gt;</code>. This type can be changed by providing a template parameter to the <code>basic_json</code> type. To store binary subtypes, the storage type is extended and exposed as <code>json::binary_t</code>:</p> <pre><code>auto binary = json::binary_t({0xCA, 0xFE, 0xBA, 0xBE});\nauto binary_with_subtype = json::binary_t({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n</code></pre> <p>There are several convenience functions to check and set the subtype:</p> <pre><code>binary.has_subtype();                   // returns false\nbinary_with_subtype.has_subtype();      // returns true\n\nbinary_with_subtype.clear_subtype();\nbinary_with_subtype.has_subtype();      // returns true\n\nbinary_with_subtype.set_subtype(42);\nbinary.set_subtype(23);\n\nbinary.subtype();                       // returns 23\n</code></pre> <p>As <code>json::binary_t</code> is subclassing <code>std::vector&lt;std::uint8_t&gt;</code>, all member functions are available:</p> <pre><code>binary.size();  // returns 4\nbinary[1];      // returns 0xFE\n</code></pre> <p>JSON values can be constructed from <code>json::binary_t</code>:</p> <pre><code>json j = binary;\n</code></pre> <p>Binary values are primitive values just like numbers or strings:</p> <pre><code>j.is_binary();    // returns true\nj.is_primitive(); // returns true\n</code></pre> <p>Given a binary JSON value, the <code>binary_t</code> can be accessed by reference as via <code>get_binary()</code>:</p> <pre><code>j.get_binary().has_subtype();  // returns true\nj.get_binary().size();         // returns 4\n</code></pre> <p>For convenience, binary JSON values can be constructed via <code>json::binary</code>:</p> <pre><code>auto j2 = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 23);\nauto j3 = json::binary({0xCA, 0xFE, 0xBA, 0xBE});\n\nj2 == j;                        // returns true\nj3.get_binary().has_subtype();  // returns false\nj3.get_binary().subtype();      // returns std::uint64_t(-1) as j3 has no subtype\n</code></pre>"},{"location":"features/binary_values/#serialization","title":"Serialization","text":"<p>Binary values are serialized differently according to the formats.</p>"},{"location":"features/binary_values/#json","title":"JSON","text":"<p>JSON does not have a binary type, and this library does not introduce a new type as this would break conformance. Instead, binary values are serialized as an object with two keys: <code>bytes</code> holds an array of integers, and <code>subtype</code> is an integer or <code>null</code>.</p> Example <p>Code:</p> <pre><code>// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// serialize to standard output\nstd::cout &lt;&lt; j.dump(2) &lt;&lt; std::endl;\n</code></pre> <p>Output:</p> <pre><code>{\n  \"binary\": {\n    \"bytes\": [202, 254, 186, 190],\n    \"subtype\": 42\n  }\n}\n</code></pre> <p>No roundtrip for binary values</p> <p>The JSON parser will not parse the objects generated by binary values back to binary values. This is by design to remain standards compliant. Serializing binary values to JSON is only implemented for debugging purposes.</p>"},{"location":"features/binary_values/#bjdata","title":"BJData","text":"<p>BJData neither supports binary values nor subtypes and proposes to serialize binary values as an array of uint8 values. The library implements this translation.</p> Example <p>Code:</p> <pre><code>// create a binary value of subtype 42 (will be ignored in BJData)\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to BJData\nauto v = json::to_bjdata(j);      \n</code></pre> <p><code>v</code> is a <code>std::vector&lt;std::uint8t&gt;</code> with the following 20 elements:</p> <pre><code>0x7B                                             // '{'\n    0x69 0x06                                    // i 6 (length of the key)\n    0x62 0x69 0x6E 0x61 0x72 0x79                // \"binary\"\n    0x5B                                         // '['\n        0x55 0xCA 0x55 0xFE 0x55 0xBA 0x55 0xBE  // content (each byte prefixed with 'U')\n    0x5D                                         // ']'\n0x7D                                             // '}'\n</code></pre> <p>The following code uses the type and size optimization for UBJSON:</p> <pre><code>// convert to UBJSON using the size and type optimization\nauto v = json::to_bjdata(j, true, true);\n</code></pre> <p>The resulting vector has 22 elements; the optimization is not effective for examples with few values:</p> <pre><code>0x7B                                // '{'\n    0x23 0x69 0x01                  // '#' 'i' type of the array elements: unsigned integers\n    0x69 0x06                       // i 6 (length of the key)\n    0x62 0x69 0x6E 0x61 0x72 0x79   // \"binary\"\n    0x5B                            // '[' array\n        0x24 0x55                   // '$' 'U' type of the array elements: unsigned integers\n        0x23 0x69 0x04              // '#' i 4 number of array elements\n        0xCA 0xFE 0xBA 0xBE         // content\n</code></pre> <p>Note that subtype (42) is not serialized and that UBJSON has no binary type, and deserializing <code>v</code> would yield the following value:</p> <pre><code>{\n  \"binary\": [202, 254, 186, 190]\n}\n</code></pre>"},{"location":"features/binary_values/#bson","title":"BSON","text":"<p>BSON supports binary values and subtypes. If a subtype is given, it is used and added as an unsigned 8-bit integer. If no subtype is given, the generic binary subtype 0x00 is used.</p> Example <p>Code:</p> <pre><code>// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to BSON\nauto v = json::to_bson(j);      \n</code></pre> <p><code>v</code> is a <code>std::vector&lt;std::uint8t&gt;</code> with the following 22 elements:</p> <pre><code>0x16 0x00 0x00 0x00                         // number of bytes in the document\n    0x05                                    // binary value\n        0x62 0x69 0x6E 0x61 0x72 0x79 0x00  // key \"binary\" + null byte\n        0x04 0x00 0x00 0x00                 // number of bytes\n        0x2a                                // subtype\n        0xCA 0xFE 0xBA 0xBE                 // content\n0x00                                        // end of the document\n</code></pre> <p>Note that the serialization preserves the subtype, and deserializing <code>v</code> would yield the following value:</p> <pre><code>{\n  \"binary\": {\n    \"bytes\": [202, 254, 186, 190],\n    \"subtype\": 42\n  }\n}\n</code></pre>"},{"location":"features/binary_values/#cbor","title":"CBOR","text":"<p>CBOR supports binary values, but no subtypes. Subtypes will be serialized as tags. Any binary value will be serialized as byte strings. The library will choose the smallest representation using the length of the byte array.</p> Example <p>Code:</p> <pre><code>// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to CBOR\nauto v = json::to_cbor(j);      \n</code></pre> <p><code>v</code> is a <code>std::vector&lt;std::uint8t&gt;</code> with the following 15 elements:</p> <pre><code>0xA1                                   // map(1)\n    0x66                               // text(6)\n        0x62 0x69 0x6E 0x61 0x72 0x79  // \"binary\"\n    0xD8 0x2A                          // tag(42)\n    0x44                               // bytes(4)\n        0xCA 0xFE 0xBA 0xBE            // content\n</code></pre> <p>Note that the subtype is serialized as tag. However, parsing tagged values yield a parse error unless <code>json::cbor_tag_handler_t::ignore</code> or <code>json::cbor_tag_handler_t::store</code> is passed to <code>json::from_cbor</code>.</p> <pre><code>{\n  \"binary\": {\n    \"bytes\": [202, 254, 186, 190],\n    \"subtype\": null\n  }\n}\n</code></pre>"},{"location":"features/binary_values/#messagepack","title":"MessagePack","text":"<p>MessagePack supports binary values and subtypes. If a subtype is given, the ext family is used. The library will choose the smallest representation among fixext1, fixext2, fixext4, fixext8, ext8, ext16, and ext32. The subtype is then added as a signed 8-bit integer.</p> <p>If no subtype is given, the bin family (bin8, bin16, bin32) is used.</p> Example <p>Code:</p> <pre><code>// create a binary value of subtype 42\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to MessagePack\nauto v = json::to_msgpack(j);      \n</code></pre> <p><code>v</code> is a <code>std::vector&lt;std::uint8t&gt;</code> with the following 14 elements:</p> <pre><code>0x81                                   // fixmap1\n    0xA6                               // fixstr6\n        0x62 0x69 0x6E 0x61 0x72 0x79  // \"binary\"\n    0xD6                               // fixext4\n        0x2A                           // subtype\n        0xCA 0xFE 0xBA 0xBE            // content\n</code></pre> <p>Note that the serialization preserves the subtype, and deserializing <code>v</code> would yield the following value:</p> <pre><code>{\n  \"binary\": {\n    \"bytes\": [202, 254, 186, 190],\n    \"subtype\": 42\n  }\n}\n</code></pre>"},{"location":"features/binary_values/#ubjson","title":"UBJSON","text":"<p>UBJSON neither supports binary values nor subtypes and proposes to serialize binary values as an array of uint8 values. The library implements this translation.</p> Example <p>Code:</p> <pre><code>// create a binary value of subtype 42 (will be ignored in UBJSON)\njson j;\nj[\"binary\"] = json::binary({0xCA, 0xFE, 0xBA, 0xBE}, 42);\n\n// convert to UBJSON\nauto v = json::to_ubjson(j);      \n</code></pre> <p><code>v</code> is a <code>std::vector&lt;std::uint8t&gt;</code> with the following 20 elements:</p> <pre><code>0x7B                                             // '{'\n    0x69 0x06                                    // i 6 (length of the key)\n    0x62 0x69 0x6E 0x61 0x72 0x79                // \"binary\"\n    0x5B                                         // '['\n        0x55 0xCA 0x55 0xFE 0x55 0xBA 0x55 0xBE  // content (each byte prefixed with 'U')\n    0x5D                                         // ']'\n0x7D                                             // '}'\n</code></pre> <p>The following code uses the type and size optimization for UBJSON:</p> <pre><code>// convert to UBJSON using the size and type optimization\nauto v = json::to_ubjson(j, true, true);\n</code></pre> <p>The resulting vector has 23 elements; the optimization is not effective for examples with few values:</p> <pre><code>0x7B                                // '{'\n    0x24                            // '$' type of the object elements\n    0x5B                            // '[' array\n    0x23 0x69 0x01                  // '#' i 1 number of object elements\n    0x69 0x06                       // i 6 (length of the key)\n    0x62 0x69 0x6E 0x61 0x72 0x79   // \"binary\"\n        0x24 0x55                   // '$' 'U' type of the array elements: unsigned integers\n        0x23 0x69 0x04              // '#' i 4 number of array elements\n        0xCA 0xFE 0xBA 0xBE         // content\n</code></pre> <p>Note that subtype (42) is not serialized and that UBJSON has no binary type, and deserializing <code>v</code> would yield the following value:</p> <pre><code>{\n  \"binary\": [202, 254, 186, 190]\n}\n</code></pre>"},{"location":"features/comments/","title":"Comments","text":"<p>This library does not support comments by default. It does so for three reasons:</p> <ol> <li>Comments are not part of the JSON specification. You may argue that <code>//</code> or <code>/* */</code> are allowed in JavaScript, but JSON is not JavaScript.</li> <li> <p>This was not an oversight: Douglas Crockford wrote on this in May 2012:</p> <p>I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability.  I know that the lack of comments makes some people sad, but it shouldn't. </p> <p>Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser.</p> </li> <li> <p>It is dangerous for interoperability if some libraries add comment support while others do not. Please check The Harmful Consequences of the Robustness Principle on this.</p> </li> </ol> <p>However, you can set parameter <code>ignore_comments</code> to <code>true</code> in the <code>parse</code> function to ignore <code>//</code> or <code>/* */</code> comments. Comments will then be treated as whitespace.</p> <p>For more information, see JSON With Commas and Comments (JWCC).</p> <p>Example</p> <p>Consider the following JSON with comments.</p> <pre><code>{\n    // update in 2006: removed Pluto\n    \"planets\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n                \"Jupiter\", \"Uranus\", \"Neptune\" /*, \"Pluto\" */]\n}\n</code></pre> <p>When calling <code>parse</code> without additional argument, a parse error exception is thrown. If <code>ignore_comments</code> is set to <code>true</code>, the comments are ignored during parsing:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string s = R\"(\n    {\n        // update in 2006: removed Pluto\n        \"planets\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n                    \"Jupiter\", \"Uranus\", \"Neptune\" /*, \"Pluto\" */]\n    }\n    )\";\n\n    try\n    {\n        json j = json::parse(s);\n    }\n    catch (json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    json j = json::parse(s,\n                         /* callback */ nullptr,\n                         /* allow exceptions */ true,\n                         /* ignore_comments */ true);\n    std::cout &lt;&lt; j.dump(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.101] parse error at line 3, column 9: syntax error while parsing object key - invalid literal; last read: '&lt;U+000A&gt;    {&lt;U+000A&gt;        /'; expected string literal\n{\n  \"planets\": [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Uranus\",\n    \"Neptune\"\n  ]\n}\n</code></pre>"},{"location":"features/enum_conversion/","title":"Specializing enum conversion","text":"<p>By default, enum values are serialized to JSON as integers. In some cases, this could result in undesired behavior. If the integer values of any enum values are changed after data using those enum values has been serialized to JSON, then deserializing that JSON would result in a different enum value being restored, or the value not being found at all.</p> <p>It is possible to more precisely specify how a given enum is mapped to and from JSON as shown below:</p> <pre><code>// example enum type declaration\nenum TaskState {\n    TS_STOPPED,\n    TS_RUNNING,\n    TS_COMPLETED,\n    TS_INVALID=-1,\n};\n\n// map TaskState values to JSON as strings\nNLOHMANN_JSON_SERIALIZE_ENUM( TaskState, {\n    {TS_INVALID, nullptr},\n    {TS_STOPPED, \"stopped\"},\n    {TS_RUNNING, \"running\"},\n    {TS_COMPLETED, \"completed\"},\n})\n</code></pre> <p>The <code>NLOHMANN_JSON_SERIALIZE_ENUM()</code> macro declares a set of <code>to_json()</code> / <code>from_json()</code> functions for type <code>TaskState</code> while avoiding repetition and boilerplate serialization code.</p>"},{"location":"features/enum_conversion/#usage","title":"Usage","text":"<pre><code>// enum to JSON as string\njson j = TS_STOPPED;\nassert(j == \"stopped\");\n\n// json string to enum\njson j3 = \"running\";\nassert(j3.template get&lt;TaskState&gt;() == TS_RUNNING);\n\n// undefined json value to enum (where the first map entry above is the default)\njson jPi = 3.14;\nassert(jPi.template get&lt;TaskState&gt;() == TS_INVALID );\n</code></pre>"},{"location":"features/enum_conversion/#notes","title":"Notes","text":"<p>Just as in Arbitrary Type Conversions above,</p> <ul> <li><code>NLOHMANN_JSON_SERIALIZE_ENUM()</code> MUST be declared in your enum type's   namespace (which can be the global namespace), or the library will not be able to locate it, and it will default to   integer serialization.</li> <li>It MUST be available (e.g., proper headers must be included) everywhere you use the conversions.</li> </ul> <p>Other Important points:</p> <ul> <li>When using <code>template get&lt;ENUM_TYPE&gt;()</code>, undefined JSON values will default to the first pair specified in your map. Select this   default pair carefully.</li> <li>If an enum or JSON value is specified more than once in your map, the first matching occurrence from the top of the   map will be returned when converting to or from JSON.</li> <li>To disable the default serialization of enumerators as integers and force a compiler error instead, see <code>JSON_DISABLE_ENUM_SERIALIZATION</code>.</li> </ul>"},{"location":"features/iterators/","title":"Iterators","text":""},{"location":"features/iterators/#overview","title":"Overview","text":"<p>A <code>basic_json</code> value is a container and allows access via iterators. Depending on the value type, <code>basic_json</code> stores zero or more values.</p> <p>As for other containers, <code>begin()</code> returns an iterator to the first value and <code>end()</code> returns an iterator to the value following the last value. The latter iterator is a placeholder and cannot be dereferenced. In case of null values, empty arrays, or empty objects, <code>begin()</code> will return <code>end()</code>.</p> <p></p>"},{"location":"features/iterators/#iteration-order-for-objects","title":"Iteration order for objects","text":"<p>When iterating over objects, values are ordered with respect to the <code>object_comparator_t</code> type which defaults to <code>std::less</code>. See the types documentation for more information.</p> Example <pre><code>// create JSON object {\"one\": 1, \"two\": 2, \"three\": 3}\njson j;\nj[\"one\"] = 1;\nj[\"two\"] = 2;\nj[\"three\"] = 3;\n\nfor (auto it = j.begin(); it != j.end(); ++it)\n{\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>1\n3\n2\n</code></pre> <p>The reason for the order is the lexicographic ordering of the object keys \"one\", \"three\", \"two\".</p>"},{"location":"features/iterators/#access-object-keys-during-iteration","title":"Access object keys during iteration","text":"<p>The JSON iterators have two member functions, <code>key()</code> and <code>value()</code> to access the object key and stored value, respectively. When calling <code>key()</code> on a non-object iterator, an invalid_iterator.207 exception is thrown.</p> Example <pre><code>// create JSON object {\"one\": 1, \"two\": 2, \"three\": 3}\njson j;\nj[\"one\"] = 1;\nj[\"two\"] = 2;\nj[\"three\"] = 3;\n\nfor (auto it = j.begin(); it != j.end(); ++it)\n{\n    std::cout &lt;&lt; it.key() &lt;&lt; \" : \" &lt;&lt; it.value() &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>one : 1\nthree : 3\ntwo : 2\n</code></pre>"},{"location":"features/iterators/#range-based-for-loops","title":"Range-based for loops","text":"<p>C++11 allows using range-based for loops to iterate over a container.</p> <pre><code>for (auto it : j_object)\n{\n    // \"it\" is of type json::reference and has no key() member\n    std::cout &lt;&lt; \"value: \" &lt;&lt; it &lt;&lt; '\\n';\n}\n</code></pre> <p>For this reason, the <code>items()</code> function allows accessing <code>iterator::key()</code> and <code>iterator::value()</code> during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator.</p> <pre><code>for (auto&amp; el : j_object.items())\n{\n    std::cout &lt;&lt; \"key: \" &lt;&lt; el.key() &lt;&lt; \", value:\" &lt;&lt; el.value() &lt;&lt; '\\n';\n}\n</code></pre> <p>The items() function also allows using structured bindings (C++17):</p> <pre><code>for (auto&amp; [key, val] : j_object.items())\n{\n    std::cout &lt;&lt; \"key: \" &lt;&lt; key &lt;&lt; \", value:\" &lt;&lt; val &lt;&lt; '\\n';\n}\n</code></pre> <p>Note</p> <p>When iterating over an array, <code>key()</code> will return the index of the element as string. For primitive types (e.g., numbers), <code>key()</code> returns an empty string.</p> <p>Warning</p> <p>Using <code>items()</code> on temporary objects is dangerous. Make sure the object's lifetime exceeds the iteration. See #2040 for more information.</p>"},{"location":"features/iterators/#reverse-iteration-order","title":"Reverse iteration order","text":"<p><code>rbegin()</code> and <code>rend()</code> return iterators in the reverse sequence.</p> <p></p> Example <pre><code>json j = {1, 2, 3, 4};\n\nfor (auto it = j.rbegin(); it != j.rend(); ++it)\n{\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>4\n3\n2\n1\n</code></pre>"},{"location":"features/iterators/#iterating-strings-and-binary-values","title":"Iterating strings and binary values","text":"<p>Note that \"value\" means a JSON value in this setting, not values stored in the underlying containers. That is, <code>*begin()</code> returns the complete string or binary array and is also safe the underlying string or binary array is empty.</p> Example <pre><code>json j = \"Hello, world\";\nfor (auto it = j.begin(); it != j.end(); ++it)\n{\n    std::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>\"Hello, world\"\n</code></pre>"},{"location":"features/iterators/#iterator-invalidation","title":"Iterator invalidation","text":"Operations invalidated iterators <code>clear</code> all"},{"location":"features/json_patch/","title":"JSON Patch and Diff","text":""},{"location":"features/json_patch/#patches","title":"Patches","text":"<p>JSON Patch (RFC 6902) defines a JSON document structure for expressing a sequence of operations to apply to a JSON document. With the <code>patch</code> function, a JSON Patch is applied to the current JSON value by executing all operations from the patch.</p> Example <p>The following code shows how a JSON patch is applied to a value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // the original document\n    json doc = R\"(\n        {\n          \"baz\": \"qux\",\n          \"foo\": \"bar\"\n        }\n    )\"_json;\n\n    // the patch\n    json patch = R\"(\n        [\n          { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" },\n          { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] },\n          { \"op\": \"remove\", \"path\": \"/foo\"}\n        ]\n    )\"_json;\n\n    // apply the patch\n    json patched_doc = doc.patch(patch);\n\n    // output original and patched document\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; doc &lt;&lt; \"\\n\\n\"\n              &lt;&lt; std::setw(4) &lt;&lt; patched_doc &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"baz\": \"qux\",\n    \"foo\": \"bar\"\n}\n\n{\n    \"baz\": \"boo\",\n    \"hello\": [\n        \"world\"\n    ]\n}\n</code></pre>"},{"location":"features/json_patch/#diff","title":"Diff","text":"<p>The library can also calculate a JSON patch (i.e., a diff) given two JSON values.</p> <p>Invariant</p> <p>For two JSON values source and target, the following code yields always true:</p> <pre><code>source.patch(diff(source, target)) == target;\n</code></pre> Example <p>The following code shows how a JSON patch is created as a diff for two JSON values.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // the source document\n    json source = R\"(\n        {\n            \"baz\": \"qux\",\n            \"foo\": \"bar\"\n        }\n    )\"_json;\n\n    // the target document\n    json target = R\"(\n        {\n            \"baz\": \"boo\",\n            \"hello\": [\n                \"world\"\n            ]\n        }\n    )\"_json;\n\n    // create the patch\n    json patch = json::diff(source, target);\n\n    // roundtrip\n    json patched_source = source.patch(patch);\n\n    // output patch and roundtrip result\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; patch &lt;&lt; \"\\n\\n\"\n              &lt;&lt; std::setw(4) &lt;&lt; patched_source &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>[\n    {\n        \"op\": \"replace\",\n        \"path\": \"/baz\",\n        \"value\": \"boo\"\n    },\n    {\n        \"op\": \"remove\",\n        \"path\": \"/foo\"\n    },\n    {\n        \"op\": \"add\",\n        \"path\": \"/hello\",\n        \"value\": [\n            \"world\"\n        ]\n    }\n]\n\n{\n    \"baz\": \"boo\",\n    \"hello\": [\n        \"world\"\n    ]\n}\n</code></pre>"},{"location":"features/json_pointer/","title":"JSON Pointer","text":""},{"location":"features/json_pointer/#introduction","title":"Introduction","text":"<p>The library supports JSON Pointer (RFC 6901) as an alternative means to address structured values. A JSON Pointer is a string that identifies a specific value within a JSON document.</p> <p>Consider the following JSON document</p> <pre><code>{\n    \"array\": [\"A\", \"B\", \"C\"],\n    \"nested\": {\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": [true, false]\n    }\n}\n</code></pre> <p>Then every value inside the JSON document can be identified as follows:</p> JSON Pointer JSON value `` <code>{\"array\":[\"A\",\"B\",\"C\"],\"nested\":{\"one\":1,\"two\":2,\"three\":[true,false]}}</code> <code>/array</code> <code>[\"A\",\"B\",\"C\"]</code> <code>/array/0</code> <code>A</code> <code>/array/1</code> <code>B</code> <code>/array/2</code> <code>C</code> <code>/nested</code> <code>{\"one\":1,\"two\":2,\"three\":[true,false]}</code> <code>/nested/one</code> <code>1</code> <code>/nested/two</code> <code>2</code> <code>/nested/three</code> <code>[true,false]</code> <code>/nested/three/0</code> <code>true</code> <code>/nested/three/1</code> <code>false</code> <p>Note <code>/</code> does not identify the root (i.e., the whole document), but an object entry with empty key <code>\"\"</code>. See RFC 6901 for more information.</p>"},{"location":"features/json_pointer/#json-pointer-creation","title":"JSON Pointer creation","text":"<p>JSON Pointers can be created from a string:</p> <pre><code>json::json_pointer p(\"/nested/one\");\n</code></pre> <p>Furthermore, a user-defined string literal can be used to achieve the same result:</p> <pre><code>auto p = \"/nested/one\"_json_pointer;\n</code></pre> <p>The escaping rules of RFC 6901 are implemented. See the constructor documentation for more information.</p>"},{"location":"features/json_pointer/#value-access","title":"Value access","text":"<p>JSON Pointers can be used in the <code>at</code>, <code>operator[]</code>, and <code>value</code> functions just like object keys or array indices.</p> <pre><code>// the JSON value from above\nauto j = json::parse(R\"({\n    \"array\": [\"A\", \"B\", \"C\"],\n    \"nested\": {\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": [true, false]\n    }\n})\");\n\n// access values\nauto val = j[\"\"_json_pointer];                              // {\"array\":[\"A\",\"B\",\"C\"],...}\nauto val1 = j[\"/nested/one\"_json_pointer];                  // 1\nauto val2 = j.at(json::json_pointer(\"/nested/three/1\"));    // false\nauto val3 = j.value(json::json_pointer(\"/nested/four\"), 0); // 0\n</code></pre>"},{"location":"features/json_pointer/#flatten-unflatten","title":"Flatten / unflatten","text":"<p>The library implements a function <code>flatten</code> to convert any JSON document into a JSON object where each key is a JSON Pointer and each value is a primitive JSON value (i.e., a string, boolean, number, or null).</p> <pre><code>// the JSON value from above\nauto j = json::parse(R\"({\n    \"array\": [\"A\", \"B\", \"C\"],\n    \"nested\": {\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": [true, false]\n    }\n})\");\n\n// create flattened value\nauto j_flat = j.flatten();\n</code></pre> <p>The resulting value <code>j_flat</code> is:</p> <pre><code>{\n  \"/array/0\": \"A\",\n  \"/array/1\": \"B\",\n  \"/array/2\": \"C\",\n  \"/nested/one\": 1,\n  \"/nested/two\": 2,\n  \"/nested/three/0\": true,\n  \"/nested/three/1\": false\n}\n</code></pre> <p>The reverse function, <code>unflatten</code> recreates the original value.</p> <pre><code>auto j_original = j_flat.unflatten();\n</code></pre>"},{"location":"features/json_pointer/#see-also","title":"See also","text":"<ul> <li>Class <code>json_pointer</code></li> <li>Function <code>flatten</code></li> <li>Function <code>unflatten</code></li> <li>JSON Patch</li> </ul>"},{"location":"features/macros/","title":"Supported Macros","text":"<p>Some aspects of the library can be configured by defining preprocessor macros before including the <code>json.hpp</code> header. See also the API documentation for macros for examples and more information.</p>"},{"location":"features/macros/#json_assertx","title":"<code>JSON_ASSERT(x)</code>","text":"<p>This macro controls which code is executed for runtime assertions of the library.</p> <p>See full documentation of <code>JSON_ASSERT(x)</code>.</p>"},{"location":"features/macros/#json_catch_userexception","title":"<code>JSON_CATCH_USER(exception)</code>","text":"<p>This macro overrides <code>catch</code> calls inside the library.</p> <p>See full documentation of <code>JSON_CATCH_USER(exception)</code>.</p>"},{"location":"features/macros/#json_diagnostics","title":"<code>JSON_DIAGNOSTICS</code>","text":"<p>This macro enables extended diagnostics for exception messages. Possible values are <code>1</code> to enable or <code>0</code> to disable (default).</p> <p>When enabled, exception messages contain a JSON Pointer to the JSON value that triggered the exception, see Extended diagnostic messages for an example. Note that enabling this macro increases the size of every JSON value by one pointer and adds some runtime overhead.</p> <p>The diagnostics messages can also be controlled with the CMake option <code>JSON_Diagnostics</code> (<code>OFF</code> by default) which sets <code>JSON_DIAGNOSTICS</code> accordingly.</p> <p>See full documentation of <code>JSON_DIAGNOSTICS</code>.</p>"},{"location":"features/macros/#json_diagnostic_positions","title":"<code>JSON_DIAGNOSTIC_POSITIONS</code>","text":"<p>When enabled, two new member functions <code>start_pos()</code> and <code>end_pos()</code> are added to <code>basic_json</code> values. If the value was created by calling the<code>parse</code> function, then these functions allow querying the byte positions of the value in the input it was parsed from. The byte positions are also used in exceptions to help locate errors.</p> <p>The diagnostics positions can also be controlled with the CMake option <code>JSON_Diagnostic_Positions</code> (<code>OFF</code> by default) which sets <code>JSON_DIAGNOSTIC_POSITIONS</code> accordingly.</p> <p>See full documentation of <code>JSON_DIAGNOSTIC_POSITIONS</code></p>"},{"location":"features/macros/#json_has_cpp_11-json_has_cpp_14-json_has_cpp_17-json_has_cpp_20","title":"<code>JSON_HAS_CPP_11</code>, <code>JSON_HAS_CPP_14</code>, <code>JSON_HAS_CPP_17</code>, <code>JSON_HAS_CPP_20</code>","text":"<p>The library targets C++11, but also supports some features introduced in later C++ versions (e.g., <code>std::string_view</code> support for C++17). For these new features, the library implements some preprocessor checks to determine the C++ standard. By defining any of these symbols, the internal check is overridden and the provided C++ version is unconditionally assumed. This can be helpful for compilers that only implement parts of the standard and would be detected incorrectly.</p> <p>See full documentation of <code>JSON_HAS_CPP_11</code>, <code>JSON_HAS_CPP_14</code>, <code>JSON_HAS_CPP_17</code>, and <code>JSON_HAS_CPP_20</code>.</p>"},{"location":"features/macros/#json_has_filesystem-json_has_experimental_filesystem","title":"<code>JSON_HAS_FILESYSTEM</code>, <code>JSON_HAS_EXPERIMENTAL_FILESYSTEM</code>","text":"<p>When compiling with C++17, the library provides conversions from and to <code>std::filesystem::path</code>. As compiler support for filesystem is limited, the library tries to detect whether <code>&lt;filesystem&gt;</code>/<code>std::filesystem</code> (<code>JSON_HAS_FILESYSTEM</code>) or <code>&lt;experimental/filesystem&gt;</code>/<code>std::experimental::filesystem</code> (<code>JSON_HAS_EXPERIMENTAL_FILESYSTEM</code>) should be used. To override the built-in check, define <code>JSON_HAS_FILESYSTEM</code> or <code>JSON_HAS_EXPERIMENTAL_FILESYSTEM</code> to <code>1</code>.</p> <p>See full documentation of <code>JSON_HAS_FILESYSTEM</code> and <code>JSON_HAS_EXPERIMENTAL_FILESYSTEM</code>.</p>"},{"location":"features/macros/#json_noexception","title":"<code>JSON_NOEXCEPTION</code>","text":"<p>Exceptions can be switched off by defining the symbol <code>JSON_NOEXCEPTION</code>.</p> <p>See full documentation of <code>JSON_NOEXCEPTION</code>.</p>"},{"location":"features/macros/#json_disable_enum_serialization","title":"<code>JSON_DISABLE_ENUM_SERIALIZATION</code>","text":"<p>When defined, default parse and serialize functions for enums are excluded and have to be provided by the user, for example, using <code>NLOHMANN_JSON_SERIALIZE_ENUM</code>.</p> <p>See full documentation of <code>JSON_DISABLE_ENUM_SERIALIZATION</code>.</p>"},{"location":"features/macros/#json_no_io","title":"<code>JSON_NO_IO</code>","text":"<p>When defined, headers <code>&lt;cstdio&gt;</code>, <code>&lt;ios&gt;</code>, <code>&lt;iosfwd&gt;</code>, <code>&lt;istream&gt;</code>, and <code>&lt;ostream&gt;</code> are not included and parse functions relying on these headers are excluded. This is relevant for environment where these I/O functions are disallowed for security reasons (e.g., Intel Software Guard Extensions (SGX)).</p> <p>See full documentation of <code>JSON_NO_IO</code>.</p>"},{"location":"features/macros/#json_skip_library_version_check","title":"<code>JSON_SKIP_LIBRARY_VERSION_CHECK</code>","text":"<p>When defined, the library will not create a compiler warning when a different version of the library was already included.</p> <p>See full documentation of <code>JSON_SKIP_LIBRARY_VERSION_CHECK</code>.</p>"},{"location":"features/macros/#json_skip_unsupported_compiler_check","title":"<code>JSON_SKIP_UNSUPPORTED_COMPILER_CHECK</code>","text":"<p>When defined, the library will not create a compile error when a known unsupported compiler is detected. This allows  using the library with compilers that do not fully support C++11 and may only work if unsupported features are not used.</p> <p>See full documentation of <code>JSON_SKIP_UNSUPPORTED_COMPILER_CHECK</code>.</p>"},{"location":"features/macros/#json_throw_userexception","title":"<code>JSON_THROW_USER(exception)</code>","text":"<p>This macro overrides <code>throw</code> calls inside the library. The argument is the exception to be thrown.</p> <p>See full documentation of <code>JSON_THROW_USER(exception)</code>.</p>"},{"location":"features/macros/#json_try_user","title":"<code>JSON_TRY_USER</code>","text":"<p>This macro overrides <code>try</code> calls inside the library.</p> <p>See full documentation of <code>JSON_TRY_USER</code>.</p>"},{"location":"features/macros/#json_use_implicit_conversions","title":"<code>JSON_USE_IMPLICIT_CONVERSIONS</code>","text":"<p>When defined to <code>0</code>, implicit conversions are switched off. By default, implicit conversions are switched on.</p> <p>See full documentation of <code>JSON_USE_IMPLICIT_CONVERSIONS</code>.</p>"},{"location":"features/macros/#nlohmann_define_type_-nlohmann_define_derived_type_","title":"<code>NLOHMANN_DEFINE_TYPE_*(...)</code>, <code>NLOHMANN_DEFINE_DERIVED_TYPE_*(...)</code>","text":"<p>The library defines 12 macros to simplify the serialization/deserialization of types. See the page on arbitrary type conversion for a detailed discussion.</p>"},{"location":"features/macros/#nlohmann_json_serialize_enumtype","title":"<code>NLOHMANN_JSON_SERIALIZE_ENUM(type, ...)</code>","text":"<p>This macro simplifies the serialization/deserialization of enum types. See Specializing enum conversion for more information.</p> <p>See full documentation of <code>NLOHMANN_JSON_SERIALIZE_ENUM</code>.</p>"},{"location":"features/macros/#nlohmann_json_version_major-nlohmann_json_version_minor-nlohmann_json_version_patch","title":"<code>NLOHMANN_JSON_VERSION_MAJOR</code>, <code>NLOHMANN_JSON_VERSION_MINOR</code>, <code>NLOHMANN_JSON_VERSION_PATCH</code>","text":"<p>These macros are defined by the library and contain the version numbers according to Semantic Versioning 2.0.0.</p> <p>See full documentation of <code>NLOHMANN_JSON_VERSION_MAJOR</code>, <code>NLOHMANN_JSON_VERSION_MINOR</code>, and <code>NLOHMANN_JSON_VERSION_PATCH</code>.</p>"},{"location":"features/merge_patch/","title":"JSON Merge Patch","text":"<p>The library supports JSON Merge Patch (RFC 7386) as a patch format. The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. This function applies a merge patch to the current JSON value.</p> <p>Instead of using JSON Pointer to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified.</p> Example <p>The following code shows how a JSON Merge Patch is applied to a JSON document.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iomanip&gt; // for std::setw\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // the original document\n    json document = R\"({\n                \"title\": \"Goodbye!\",\n                \"author\": {\n                    \"givenName\": \"John\",\n                    \"familyName\": \"Doe\"\n                },\n                \"tags\": [\n                    \"example\",\n                    \"sample\"\n                ],\n                \"content\": \"This will be unchanged\"\n            })\"_json;\n\n    // the patch\n    json patch = R\"({\n                \"title\": \"Hello!\",\n                \"phoneNumber\": \"+01-123-456-7890\",\n                \"author\": {\n                    \"familyName\": null\n                },\n                \"tags\": [\n                    \"example\"\n                ]\n            })\"_json;\n\n    // apply the patch\n    document.merge_patch(patch);\n\n    // output original and patched document\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; document &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"author\": {\n        \"givenName\": \"John\"\n    },\n    \"content\": \"This will be unchanged\",\n    \"phoneNumber\": \"+01-123-456-7890\",\n    \"tags\": [\n        \"example\"\n    ],\n    \"title\": \"Hello!\"\n}\n</code></pre>"},{"location":"features/modules/","title":"Modules","text":"<p>This library has experimental support for C++ modules, introduced in C++20. The library can be imported by writing <code>import nlohmann.json;</code> instead of <code>#include &lt;nlohmann/json.hpp&gt;</code>. </p> <p>Please be aware that the module is experimental and a full test is outstanding, and the exported symbols are subject to change.</p>"},{"location":"features/modules/#requirements","title":"Requirements","text":"<p>The <code>nlohmann.json</code> module requires that the build system is configured to build and resolve modules when imported. Obviously, as modules were introduced in C++20, this feature can only be used in C++20 and subsequent versions.</p> <p>To enable building the <code>nlohmann.json</code> module (which is not done by default), the macro <code>NLOHMANN_JSON_BUILD_MODULES</code> must be passed to the build system.</p>"},{"location":"features/modules/#example","title":"Example","text":"<p>When using modules rather than headers, the previous example for creating a <code>json</code> object through a JSON file, would instead be: <pre><code>import std;\nimport nlohmann.json;\n\nusing json = nlohmann::json;\n\n// ...\n\nstd::ifstream f(\"example.json\");\njson data = json::parse(f);\n</code></pre></p>"},{"location":"features/modules/#modules-do-not-export-macros","title":"Modules do not export macros","text":"<p>It should be noted that as modules do not export macros, the <code>nlohmann.json</code> module will not export any macros, but rather only the following symbols:</p> <ul> <li><code>nlohmann::adl_serializer</code></li> <li><code>nlohmann::basic_json</code></li> <li><code>nlohmann::json</code></li> <li><code>nlohmann::json_pointer</code></li> <li><code>nlohmann::ordered_map</code></li> <li><code>nlohmann::ordered_json</code></li> </ul>"},{"location":"features/namespace/","title":"<code>nlohmann</code> Namespace","text":"<p>The 3.11.0 release introduced an inline namespace to allow different parts of a codebase to safely use different versions of the JSON library as long as they never exchange instances of library types.</p>"},{"location":"features/namespace/#structure","title":"Structure","text":"<p>The complete default namespace name is derived as follows:</p> <ul> <li>The root namespace is always <code>nlohmann</code>.</li> <li>The inline namespace starts with <code>json_abi</code> and is followed by several optional ABI tags according to the value of   these ABI-affecting macros, in order:<ul> <li><code>JSON_DIAGNOSTICS</code> defined non-zero appends <code>_diag</code>.</li> <li><code>JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON</code>   defined non-zero appends <code>_ldvcmp</code>.</li> </ul> </li> <li>The inline namespace ends with the suffix <code>_v</code> followed by the 3 components of the version number separated by   underscores. To omit the version component, see Disabling the version component   below.</li> </ul> <p>For example, the namespace name for version 3.11.2 with <code>JSON_DIAGNOSTICS</code> defined to <code>1</code> is:</p> <pre><code>nlohmann::json_abi_diag_v3_11_2\n</code></pre>"},{"location":"features/namespace/#purpose","title":"Purpose","text":"<p>Several incompatibilities have been observed. Amongst the most common ones is linking code compiled with different definitions of <code>JSON_DIAGNOSTICS</code>. This is illustrated in the diagram below.</p> <pre><code>graph\n    json[\"&lt;strong&gt;nlohmann_json (v3.10.5)&lt;/strong&gt;&lt;br&gt;JSON_DIAGNOSTICS=0\"]\n    json_diag[\"&lt;strong&gt;nlohmann_json (v3.10.5)&lt;/strong&gt;&lt;br&gt;JSON_DIAGNOSTICS=1\"]\n    library[\"&lt;strong&gt;some library&lt;/strong&gt;\"]\n    app[\"&lt;strong&gt;application&lt;/strong&gt;\"]\n\n    library --&gt; json\n    app --&gt; json_diag\n    app --&gt; library</code></pre> <p>In releases prior to 3.11.0, mixing any version of the JSON library with different <code>JSON_DIAGNOSTICS</code> settings would result in a crashing application. If <code>some_library</code> never passes instances of JSON library types to the application, this scenario became safe in version 3.11.0 and above due to the inline namespace yielding distinct symbol names.</p>"},{"location":"features/namespace/#limitations","title":"Limitations","text":"<p>Neither the compiler nor the linker will issue as much as a warning when translation units \u2013 intended to be linked together and that include different versions and/or configurations of the JSON library \u2013 exchange and use library types.</p> <p>There is an exception when forward declarations are used (i.e., when including <code>json_fwd.hpp</code>) in which case the linker may complain about undefined references.</p>"},{"location":"features/namespace/#disabling-the-version-component","title":"Disabling the version component","text":"<p>Different versions are not necessarily ABI-incompatible, but the project does not actively track changes in the ABI and recommends that all parts of a codebase exchanging library types be built with the same version. Users can, at their own risk, disable the version component of the linline namespace, allowing different versions \u2013 but not configurations \u2013 to be used in cases where the linker would otherwise output undefined reference errors.</p> <p>To do so, define <code>NLOHMANN_JSON_NAMESPACE_NO_VERSION</code> to <code>1</code>.</p> <p>This applies to version 3.11.2 and above only; versions 3.11.0 and 3.11.1 can apply the technique described in the next section to emulate the effect of the <code>NLOHMANN_JSON_NAMESPACE_NO_VERSION</code> macro.</p> <p>Use at your own risk</p> <p>Disabling the namespace version component and mixing ABI-incompatible versions will result in crashes or incorrect behavior. You have been warned!</p>"},{"location":"features/namespace/#disabling-the-inline-namespace-completely","title":"Disabling the inline namespace completely","text":"<p>When interoperability with code using a pre-3.11.0 version of the library is required, users can, at their own risk restore the old namespace layout by redefining <code>NLOHMANN_JSON_NAMESPACE_BEGIN, NLOHMANN_JSON_NAMESPACE_END</code> as follows:</p> <pre><code>#define NLOHMANN_JSON_NAMESPACE_BEGIN  namespace nlohmann {\n#define NLOHMANN_JSON_NAMESPACE_END    }\n</code></pre> <p>Use at your own risk</p> <p>Overriding the namespace and mixing ABI-incompatible versions will result in crashes or incorrect behavior. You have been warned!</p>"},{"location":"features/namespace/#version-history","title":"Version history","text":"<ul> <li>Introduced inline namespace (<code>json_v3_11_0[_abi-tag]*</code>) in version 3.11.0.</li> <li>Changed structure of inline namespace in version 3.11.2.</li> </ul>"},{"location":"features/object_order/","title":"Object Order","text":"<p>The JSON standard defines objects as \"an unordered collection of zero or more name/value pairs\". As such, an implementation does not need to preserve any specific order of object keys.</p>"},{"location":"features/object_order/#default-behavior-sort-keys","title":"Default behavior: sort keys","text":"<p>The default type <code>nlohmann::json</code> uses a <code>std::map</code> to store JSON objects, and thus stores object keys sorted alphabetically.</p> Example <pre><code>#include &lt;iostream&gt;\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j;\n    j[\"one\"] = 1;\n    j[\"two\"] = 2;\n    j[\"three\"] = 3;\n\n    std::cout &lt;&lt; j.dump(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"one\": 1,\n  \"three\": 3,\n  \"two\": 2\n}\n</code></pre>"},{"location":"features/object_order/#alternative-behavior-preserve-insertion-order","title":"Alternative behavior: preserve insertion order","text":"<p>If you do want to preserve the insertion order, you can try the type <code>nlohmann::ordered_json</code>.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing ordered_json = nlohmann::ordered_json;\n\nint main()\n{\n    ordered_json j;\n    j[\"one\"] = 1;\n    j[\"two\"] = 2;\n    j[\"three\"] = 3;\n\n    std::cout &lt;&lt; j.dump(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"one\": 1,\n  \"two\": 2,\n  \"three\": 3\n}\n</code></pre> <p>Alternatively, you can use a more sophisticated ordered map like <code>tsl::ordered_map</code> (integration) or <code>nlohmann::fifo_map</code> (integration).</p>"},{"location":"features/object_order/#notes-on-parsing","title":"Notes on parsing","text":"<p>Note that you also need to call the right <code>parse</code> function when reading from a file. Assume file <code>input.json</code> contains the JSON object above:</p> <pre><code>{\n  \"one\": 1,\n  \"two\": 2,\n  \"three\": 3\n}\n</code></pre> <p>Right way</p> <p>The following code correctly calls the <code>parse</code> function from <code>nlohmann::ordered_json</code>:</p> <pre><code>std::ifstream i(\"input.json\");\nauto j = nlohmann::ordered_json::parse(i);\nstd::cout &lt;&lt; j.dump(2) &lt;&lt; std::endl;\n</code></pre> <p>The output will be:</p> <pre><code>{\n  \"one\": 1,\n  \"two\": 2,\n  \"three\": 3\n}\n</code></pre> Wrong way <p>The following code incorrectly calls the <code>parse</code> function from <code>nlohmann::json</code> which does not preserve the insertion order, but sorts object keys. Assigning the result to <code>nlohmann::ordered_json</code> compiles, but does not restore the order from the input file.</p> <pre><code>std::ifstream i(\"input.json\");\nnlohmann::ordered_json j = nlohmann::json::parse(i);\nstd::cout &lt;&lt; j.dump(2) &lt;&lt; std::endl;\n</code></pre> <p>The output will be:</p> <pre><code>{\n  \"one\": 1,\n  \"three\": 3\n  \"two\": 2,\n}\n</code></pre>"},{"location":"features/trailing_commas/","title":"Trailing Commas","text":"<p>Like comments, this library does not support trailing commas in arrays and objects by default.</p> <p>You can set parameter <code>ignore_trailing_commas</code> to <code>true</code> in the <code>parse</code> function to allow trailing commas in arrays and objects. Note that a single comma as the only content of the array or object (<code>[,]</code> or <code>{,}</code>) is not allowed, and multiple trailing commas (<code>[1,,]</code>) are not allowed either.</p> <p>This library does not add trailing commas when serializing JSON data.</p> <p>For more information, see JSON With Commas and Comments (JWCC).</p> <p>Example</p> <p>Consider the following JSON with trailing commas.</p> <pre><code>{\n    \"planets\": [\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Uranus\",\n        \"Neptune\",\n    ]\n}\n</code></pre> <p>When calling <code>parse</code> without additional argument, a parse error exception is thrown. If <code>ignore_trailing_commas</code> is set to <code>true</code>, the trailing commas are ignored during parsing:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::string s = R\"(\n    {\n        \"planets\": [\n            \"Mercury\",\n            \"Venus\",\n            \"Earth\",\n            \"Mars\",\n            \"Jupiter\",\n            \"Uranus\",\n            \"Neptune\",\n        ]\n    }\n    )\";\n\n    try\n    {\n        json j = json::parse(s);\n    }\n    catch (json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    json j = json::parse(s,\n                         /* callback */ nullptr,\n                         /* allow exceptions */ true,\n                         /* ignore_comments */ false,\n                         /* ignore_trailing_commas */ true);\n    std::cout &lt;&lt; j.dump(2) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.parse_error.101] parse error at line 11, column 9: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal\n{\n  \"planets\": [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Uranus\",\n    \"Neptune\"\n  ]\n}\n</code></pre>"},{"location":"features/binary_formats/","title":"Binary Formats","text":"<p>Though JSON is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance, over a network. Hence, the library supports</p> <ul> <li>BJData (Binary JData),</li> <li>BSON (Binary JSON),</li> <li>CBOR (Concise Binary Object Representation),</li> <li>MessagePack, and</li> <li>UBJSON (Universal Binary JSON)</li> </ul> <p>to efficiently encode JSON values to byte vectors and to decode such vectors.</p>"},{"location":"features/binary_formats/#comparison","title":"Comparison","text":""},{"location":"features/binary_formats/#completeness","title":"Completeness","text":"Format Serialization Deserialization BJData complete complete BSON incomplete: top-level value must be an object incomplete, but all JSON types are supported CBOR complete incomplete, but all JSON types are supported MessagePack complete complete UBJSON complete complete"},{"location":"features/binary_formats/#binary-values","title":"Binary values","text":"Format Binary values Binary subtypes BJData not supported not supported BSON supported supported CBOR supported supported MessagePack supported supported UBJSON not supported not supported <p>See binary values for more information.</p>"},{"location":"features/binary_formats/#sizes","title":"Sizes","text":"Format canada.json twitter.json citm_catalog.json jeopardy.json BJData 53.2 % 91.1 % 78.1 % 96.6 % BJData (size) 58.6 % 92.1 % 86.7 % 97.4 % BJData (size+tyoe) 58.6 % 92.1 % 86.5 % 97.4 % BSON 85.8 % 95.2 % 95.8 % 106.7 % CBOR 50.5 % 86.3 % 68.4 % 88.0 % MessagePack 50.5 % 86.0 % 68.5 % 87.9 % UBJSON 53.2 % 91.3 % 78.2 % 96.6 % UBJSON (size) 58.6 % 92.3 % 86.8 % 97.4 % UBJSON (size+type) 55.9 % 92.3 % 85.0 % 95.0 % <p>Sizes compared to minified JSON value.</p>"},{"location":"features/binary_formats/bjdata/","title":"BJData","text":"<p>The BJData format was derived from and improved upon Universal Binary JSON(UBJSON) specification (Draft 12). Specifically, it introduces an optimized array container for efficient storage of N-dimensional packed arrays (ND-arrays); it also adds 5 new type markers - <code>[u] - uint16</code>, <code>[m] - uint32</code>, <code>[M] - uint64</code>, <code>[h] - float16</code> and <code>[B] - byte</code> - to unambiguously map common binary numeric types; furthermore, it uses little-endian (LE) to store all numerics instead of big-endian (BE) as in UBJSON to avoid unnecessary conversions on commonly available platforms.</p> <p>Compared to other binary JSON-like formats such as MessagePack and CBOR, both BJData and UBJSON demonstrate a rare combination of being both binary and quasi-human-readable. This is because all semantic elements in BJData and UBJSON, including the data-type markers and name/string types, are directly human-readable. Data stored in the BJData/UBJSON format is not only compact in size, fast to read/write, but also can be directly searched or read using simple processing.</p> <p>References</p> <ul> <li>BJData Specification</li> </ul>"},{"location":"features/binary_formats/bjdata/#serialization","title":"Serialization","text":"<p>The library uses the following mapping from JSON values types to BJData types according to the BJData specification:</p> JSON value type value/range BJData type marker null <code>null</code> null <code>Z</code> boolean <code>true</code> true <code>T</code> boolean <code>false</code> false <code>F</code> number_integer -9223372036854775808..-2147483649 int64 <code>L</code> number_integer -2147483648..-32769 int32 <code>l</code> number_integer -32768..-129 int16 <code>I</code> number_integer -128..127 int8 <code>i</code> number_integer 128..255 uint8 <code>U</code> number_integer 256..32767 int16 <code>I</code> number_integer 32768..65535 uint16 <code>u</code> number_integer 65536..2147483647 int32 <code>l</code> number_integer 2147483648..4294967295 uint32 <code>m</code> number_integer 4294967296..9223372036854775807 int64 <code>L</code> number_integer 9223372036854775808..18446744073709551615 uint64 <code>M</code> number_unsigned 0..127 int8 <code>i</code> number_unsigned 128..255 uint8 <code>U</code> number_unsigned 256..32767 int16 <code>I</code> number_unsigned 32768..65535 uint16 <code>u</code> number_unsigned 65536..2147483647 int32 <code>l</code> number_unsigned 2147483648..4294967295 uint32 <code>m</code> number_unsigned 4294967296..9223372036854775807 int64 <code>L</code> number_unsigned 9223372036854775808..18446744073709551615 uint64 <code>M</code> number_float any value float64 <code>D</code> string with shortest length indicator string <code>S</code> array see notes on optimized format/ND-array array <code>[</code> object see notes on optimized format map <code>{</code> binary see notes on binary values array <code>[$B</code> <p>Complete mapping</p> <p>The mapping is complete in the sense that any JSON value type can be converted to a BJData value.</p> <p>Any BJData output created by <code>to_bjdata</code> can be successfully parsed by <code>from_bjdata</code>.</p> <p>Size constraints</p> <p>The following values can not be converted to a BJData value:</p> <ul> <li>strings with more than 18446744073709551615 bytes, i.e., 2^{64}-1 bytes (theoretical)</li> </ul> <p>Unused BJData markers</p> <p>The following markers are not used in the conversion:</p> <ul> <li><code>Z</code>: no-op values are not created.</li> <li><code>C</code>: single-byte strings are serialized with <code>S</code> markers.</li> </ul> <p>NaN/infinity handling</p> <p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the <code>dump()</code> function which serializes NaN or Infinity to <code>null</code>.</p> <p>Endianness</p> <p>A breaking difference between BJData and UBJSON is the endianness of numerical values. In BJData, all numerical data types (integers <code>UiuImlML</code> and floating-point values <code>hdD</code>) are stored in the little-endian (LE) byte order as opposed to big-endian as used by UBJSON. Adopting LE to store numeric records avoids unnecessary byte swapping on most modern computers where LE is used as the default byte order.</p> <p>Optimized formats</p> <p>Optimized formats for containers are supported via two parameters of <code>to_bjdata</code>:</p> <ul> <li>Parameter <code>use_size</code> adds size information to the beginning of a container and removes the closing marker.</li> <li>Parameter <code>use_type</code> further checks whether all elements of a container have the same type and adds the type   marker to the beginning of the container. The <code>use_type</code> parameter must only be used together with   <code>use_size = true</code>.</li> </ul> <p>Note that <code>use_size = true</code> alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed of the number of elements in the container.</p> <p>ND-array optimized format</p> <p>BJData extends UBJSON's optimized array size marker to support ND-arrays of uniform numerical data types (referred to as packed arrays). For example, the 2-D <code>uint8</code> integer array <code>[[1,2],[3,4],[5,6]]</code>, stored as nested optimized array in UBJSON <code>[ [$U#i2 1 2 [$U#i2 3 4 [$U#i2 5 6 ]</code>, can be further compressed in BJData to <code>[$U#[$i#i2 2 3 1 2 3 4 5 6</code> or <code>[$U#[i2 i3] 1 2 3 4 5 6</code>.</p> <p>To maintain type and size information, ND-arrays are converted to JSON objects following the annotated array format (defined in the JData specification (Draft 3)), when parsed using <code>from_bjdata</code>. For example, the above 2-D <code>uint8</code> array can be parsed and accessed as</p> <pre><code>{\n    \"_ArrayType_\": \"uint8\",\n    \"_ArraySize_\": [2,3],\n    \"_ArrayData_\": [1,2,3,4,5,6]\n}\n</code></pre> <p>Likewise, when a JSON object in the above form is serialized using <code>to_bjdata</code>, it is automatically converted into a compact BJData ND-array. The only exception is, that when the 1-dimensional vector stored in <code>\"_ArraySize_\"</code> contains a single integer or two integers with one being 1, a regular 1-D optimized array is generated.</p> <p>The current version of this library does not yet support automatic detection of and conversion from a nested JSON array input to a BJData ND-array.</p> <p>Restrictions in optimized data types for arrays and objects</p> <p>Due to diminished space saving, hampered readability, and increased security risks, in BJData, the allowed data types following the <code>$</code> marker in an optimized array and object container are restricted to non-zero-fixed-length data types. Therefore, the valid optimized type markers can only be one of <code>UiuImlMLhdDCB</code>. This also means other variable (<code>[{SH</code>) or zero-length types (<code>TFN</code>) can not be used in an optimized array or object in BJData.</p> <p>Binary values</p> <p>BJData provides a dedicated <code>B</code> marker (defined in the BJData specification (Draft 3)) that is used in optimized arrays to designate binary data. This means that, unlike UBJSON, binary data can be both serialized and deserialized.</p> <p>To preserve compatibility with BJData Draft 2, the Draft 3 optimized binary array must be explicitly enabled using the <code>version</code> parameter of <code>to_bjdata</code>.</p> <p>In Draft2 mode (default), if the JSON data contains the binary type, the value stored as a list of integers, as suggested by the BJData documentation. In particular, this means that the serialization and the deserialization of JSON containing binary values into BJData and back will result in a different JSON object.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\n// function to print BJData's diagnostic format\nvoid print_byte(uint8_t byte)\n{\n    if (32 &lt; byte and byte &lt; 128)\n    {\n        std::cout &lt;&lt; (char)byte;\n    }\n    else\n    {\n        std::cout &lt;&lt; (int)byte;\n    }\n}\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": false})\"_json;\n\n    // serialize it to BJData\n    std::vector&lt;std::uint8_t&gt; v = json::to_bjdata(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // create an array of numbers\n    json array = {1, 2, 3, 4, 5, 6, 7, 8};\n\n    // serialize it to BJData using default representation\n    std::vector&lt;std::uint8_t&gt; v_array = json::to_bjdata(array);\n    // serialize it to BJData using size optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size = json::to_bjdata(array, true);\n    // serialize it to BJData using type optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size_and_type = json::to_bjdata(array, true, true);\n\n    // print the vector contents\n    for (auto&amp; byte : v_array)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size_and_type)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{i7compactTi6schemaF}\n[i1i2i3i4i5i6i7i8]\n[#i8i1i2i3i4i5i6i7i8\n[$i#i812345678\n</code></pre>"},{"location":"features/binary_formats/bjdata/#deserialization","title":"Deserialization","text":"<p>The library maps BJData types to JSON value types as follows:</p> BJData type JSON value type marker no-op no value, next value is read <code>N</code> null <code>null</code> <code>Z</code> false <code>false</code> <code>F</code> true <code>true</code> <code>T</code> float16 number_float <code>h</code> float32 number_float <code>d</code> float64 number_float <code>D</code> uint8 number_unsigned <code>U</code> int8 number_integer <code>i</code> uint16 number_unsigned <code>u</code> int16 number_integer <code>I</code> uint32 number_unsigned <code>m</code> int32 number_integer <code>l</code> uint64 number_unsigned <code>M</code> int64 number_integer <code>L</code> byte number_unsigned <code>B</code> string string <code>S</code> char string <code>C</code> array array (optimized values are supported) <code>[</code> ND-array object (in JData annotated array format) <code>[$.#[.</code> object object (optimized values are supported) <code>{</code> binary binary (strongly-typed byte array) <code>[$B</code> <p>Complete mapping</p> <p>The mapping is complete in the sense that any BJData value can be converted to a JSON value.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x7B, 0x69, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61,\n                                   0x63, 0x74, 0x54, 0x69, 0x06, 0x73, 0x63, 0x68,\n                                   0x65, 0x6D, 0x61, 0x69, 0x00, 0x7D\n                                  };\n\n    // deserialize it with BJData\n    json j = json::from_bjdata(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"features/binary_formats/bson/","title":"BSON","text":"<p>BSON, short for Binary JSON, is a binary-encoded serialization of JSON-like documents. Like JSON, BSON supports the embedding of documents and arrays within other documents and arrays. BSON also contains extensions that allow representation of data types that are not part of the JSON spec. For example, BSON has a Date type and a BinData type.</p> <p>References</p> <ul> <li>BSON Website - the main source on BSON</li> <li>BSON Specification - the specification</li> </ul>"},{"location":"features/binary_formats/bson/#serialization","title":"Serialization","text":"<p>The library uses the following mapping from JSON values types to BSON types:</p> JSON value type value/range BSON type marker null <code>null</code> null 0x0A boolean <code>true</code>, <code>false</code> boolean 0x08 number_integer -9223372036854775808..-2147483649 int64 0x12 number_integer -2147483648..2147483647 int32 0x10 number_integer 2147483648..9223372036854775807 int64 0x12 number_unsigned 0..2147483647 int32 0x10 number_unsigned 2147483648..9223372036854775807 int64 0x12 number_unsigned 9223372036854775808..18446744073709551615 uint64 0x11 number_float any value double 0x01 string any value string 0x02 array any value document 0x04 object any value document 0x03 binary any value binary 0x05 <p>Incomplete mapping</p> <p>The mapping is incomplete, since only JSON-objects (and things contained therein) can be serialized to BSON. Also, keys may not contain U+0000, since they are serialized a zero-terminated c-strings.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": 0})\"_json;\n\n    // serialize it to BSON\n    std::vector&lt;std::uint8_t&gt; v = json::to_bson(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        std::cout &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)byte &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>0x1b 0x00 0x00 0x00 0x08 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0x00 0x01 0x10 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 0x00 0x00 0x00 0x00 0x00 \n</code></pre>"},{"location":"features/binary_formats/bson/#deserialization","title":"Deserialization","text":"<p>The library maps BSON record types to JSON value types as follows:</p> BSON type BSON marker byte JSON value type double 0x01 number_float string 0x02 string document 0x03 object array 0x04 array binary 0x05 binary undefined 0x06 unsupported ObjectId 0x07 unsupported boolean 0x08 boolean UTC Date-Time 0x09 unsupported null 0x0A null Regular Expr. 0x0B unsupported DB Pointer 0x0C unsupported JavaScript Code 0x0D unsupported Symbol 0x0E unsupported JavaScript Code 0x0F unsupported int32 0x10 number_integer uint64(Timestamp) 0x11 number_unsigned 128-bit decimal float 0x13 unsupported Max Key 0x7F unsupported Min Key 0xFF unsupported <p>Incomplete mapping</p> <p>The mapping is incomplete. The unsupported mappings are indicated in the table above.</p> <p>Handling of BSON type 0x11</p> <p>BSON type 0x11 is used to represent uint64 numbers. This library treats these values purely as uint64 numbers  and does not parse them into date-related formats.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x1b, 0x00, 0x00, 0x00, 0x08, 0x63, 0x6f, 0x6d,\n                                   0x70, 0x61, 0x63, 0x74, 0x00, 0x01, 0x10, 0x73,\n                                   0x63, 0x68, 0x65, 0x6d, 0x61, 0x00, 0x00, 0x00,\n                                   0x00, 0x00, 0x00\n                                  };\n\n    // deserialize it with BSON\n    json j = json::from_bson(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"features/binary_formats/cbor/","title":"CBOR","text":"<p>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code sizes, fairly small message size, and extensibility without the need for version negotiation.</p> <p>References</p> <ul> <li>CBOR Website - the main source on CBOR</li> <li>CBOR Playground - an interactive webpage to translate between JSON and CBOR</li> <li>RFC 7049 - the CBOR specification</li> </ul>"},{"location":"features/binary_formats/cbor/#serialization","title":"Serialization","text":"<p>The library uses the following mapping from JSON values types to CBOR types according to the CBOR specification (RFC 7049):</p> JSON value type value/range CBOR type first byte null <code>null</code> Null 0xF6 boolean <code>true</code> True 0xF5 boolean <code>false</code> False 0xF4 number_integer -9223372036854775808..-2147483649 Negative integer (8 bytes follow) 0x3B number_integer -2147483648..-32769 Negative integer (4 bytes follow) 0x3A number_integer -32768..-129 Negative integer (2 bytes follow) 0x39 number_integer -128..-25 Negative integer (1 byte follow) 0x38 number_integer -24..-1 Negative integer 0x20..0x37 number_integer 0..23 Integer 0x00..0x17 number_integer 24..255 Unsigned integer (1 byte follow) 0x18 number_integer 256..65535 Unsigned integer (2 bytes follow) 0x19 number_integer 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_integer 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_unsigned 0..23 Integer 0x00..0x17 number_unsigned 24..255 Unsigned integer (1 byte follow) 0x18 number_unsigned 256..65535 Unsigned integer (2 bytes follow) 0x19 number_unsigned 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_unsigned 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_float any value representable by a float Single-Precision Float 0xFA number_float any value NOT representable by a float Double-Precision Float 0xFB string length: 0..23 UTF-8 string 0x60..0x77 string length: 23..255 UTF-8 string (1 byte follow) 0x78 string length: 256..65535 UTF-8 string (2 bytes follow) 0x79 string length: 65536..4294967295 UTF-8 string (4 bytes follow) 0x7A string length: 4294967296..18446744073709551615 UTF-8 string (8 bytes follow) 0x7B array size: 0..23 array 0x80..0x97 array size: 23..255 array (1 byte follow) 0x98 array size: 256..65535 array (2 bytes follow) 0x99 array size: 65536..4294967295 array (4 bytes follow) 0x9A array size: 4294967296..18446744073709551615 array (8 bytes follow) 0x9B object size: 0..23 map 0xA0..0xB7 object size: 23..255 map (1 byte follow) 0xB8 object size: 256..65535 map (2 bytes follow) 0xB9 object size: 65536..4294967295 map (4 bytes follow) 0xBA object size: 4294967296..18446744073709551615 map (8 bytes follow) 0xBB binary size: 0..23 byte string 0x40..0x57 binary size: 23..255 byte string (1 byte follow) 0x58 binary size: 256..65535 byte string (2 bytes follow) 0x59 binary size: 65536..4294967295 byte string (4 bytes follow) 0x5A binary size: 4294967296..18446744073709551615 byte string (8 bytes follow) 0x5B <p>Binary values with subtype are mapped to tagged values (0xD8..0xDB) depending on the subtype, followed by a byte string, see \"binary\" cells in the table above.</p> <p>Complete mapping</p> <p>The mapping is complete in the sense that any JSON value type can be converted to a CBOR value.</p> <p>NaN/infinity handling</p> <p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the normal JSON serialization which serializes NaN or Infinity to <code>null</code>.</p> <p>Unused CBOR types</p> <p>The following CBOR types are not used in the conversion:</p> <ul> <li>UTF-8 strings terminated by \"break\" (0x7F)</li> <li>arrays terminated by \"break\" (0x9F)</li> <li>maps terminated by \"break\" (0xBF)</li> <li>byte strings terminated by \"break\" (0x5F)</li> <li>date/time (0xC0..0xC1)</li> <li>bignum (0xC2..0xC3)</li> <li>decimal fraction (0xC4)</li> <li>bigfloat (0xC5)</li> <li>expected conversions (0xD5..0xD7)</li> <li>simple values (0xE0..0xF3, 0xF8)</li> <li>undefined (0xF7)</li> <li>half-precision floats (0xF9)</li> <li>break (0xFF)</li> </ul> <p>Tagged items</p> <p>Binary subtypes will be serialized as tagged items. See binary values for an example.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": 0})\"_json;\n\n    // serialize it to CBOR\n    std::vector&lt;std::uint8_t&gt; v = json::to_cbor(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        std::cout &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)byte &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>0xa2 0x67 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xf5 0x66 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 \n</code></pre>"},{"location":"features/binary_formats/cbor/#deserialization","title":"Deserialization","text":"<p>The library maps CBOR types to JSON value types as follows:</p> CBOR type JSON value type first byte Integer number_unsigned 0x00..0x17 Unsigned integer number_unsigned 0x18 Unsigned integer number_unsigned 0x19 Unsigned integer number_unsigned 0x1A Unsigned integer number_unsigned 0x1B Negative integer number_integer 0x20..0x37 Negative integer number_integer 0x38 Negative integer number_integer 0x39 Negative integer number_integer 0x3A Negative integer number_integer 0x3B Byte string binary 0x40..0x57 Byte string binary 0x58 Byte string binary 0x59 Byte string binary 0x5A Byte string binary 0x5B UTF-8 string string 0x60..0x77 UTF-8 string string 0x78 UTF-8 string string 0x79 UTF-8 string string 0x7A UTF-8 string string 0x7B UTF-8 string string 0x7F array array 0x80..0x97 array array 0x98 array array 0x99 array array 0x9A array array 0x9B array array 0x9F map object 0xA0..0xB7 map object 0xB8 map object 0xB9 map object 0xBA map object 0xBB map object 0xBF False <code>false</code> 0xF4 True <code>true</code> 0xF5 Null <code>null</code> 0xF6 Half-Precision Float number_float 0xF9 Single-Precision Float number_float 0xFA Double-Precision Float number_float 0xFB <p>Incomplete mapping</p> <p>The mapping is incomplete in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors:</p> <ul> <li>date/time (0xC0..0xC1)</li> <li>bignum (0xC2..0xC3)</li> <li>decimal fraction (0xC4)</li> <li>bigfloat (0xC5)</li> <li>expected conversions (0xD5..0xD7)</li> <li>simple values (0xE0..0xF3, 0xF8)</li> <li>undefined (0xF7)</li> </ul> <p>Object keys</p> <p>CBOR allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected.</p> <p>Tagged items</p> <p>Tagged items will throw a parse error by default. They can be ignored by passing <code>cbor_tag_handler_t::ignore</code> to function <code>from_cbor</code>. They can be stored by passing <code>cbor_tag_handler_t::store</code> to function <code>from_cbor</code>.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0xa2, 0x67, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63,\n                                   0x74, 0xf5, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6d,\n                                   0x61, 0x00\n                                  };\n\n    // deserialize it with CBOR\n    json j = json::from_cbor(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"features/binary_formats/messagepack/","title":"MessagePack","text":"<p>MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves.</p> <p>References</p> <ul> <li>MessagePack website</li> <li>MessagePack specification</li> </ul>"},{"location":"features/binary_formats/messagepack/#serialization","title":"Serialization","text":"<p>The library uses the following mapping from JSON values types to MessagePack types according to the MessagePack specification:</p> JSON value type value/range MessagePack type first byte null <code>null</code> nil 0xC0 boolean <code>true</code> true 0xC3 boolean <code>false</code> false 0xC2 number_integer -9223372036854775808..-2147483649 int64 0xD3 number_integer -2147483648..-32769 int32 0xD2 number_integer -32768..-129 int16 0xD1 number_integer -128..-33 int8 0xD0 number_integer -32..-1 negative fixint 0xE0..0xFF number_integer 0..127 positive fixint 0x00..0x7F number_integer 128..255 uint 8 0xCC number_integer 256..65535 uint 16 0xCD number_integer 65536..4294967295 uint 32 0xCE number_integer 4294967296..18446744073709551615 uint 64 0xCF number_unsigned 0..127 positive fixint 0x00..0x7F number_unsigned 128..255 uint 8 0xCC number_unsigned 256..65535 uint 16 0xCD number_unsigned 65536..4294967295 uint 32 0xCE number_unsigned 4294967296..18446744073709551615 uint 64 0xCF number_float any value representable by a float float 32 0xCA number_float any value NOT representable by a float float 64 0xCB string length: 0..31 fixstr 0xA0..0xBF string length: 32..255 str 8 0xD9 string length: 256..65535 str 16 0xDA string length: 65536..4294967295 str 32 0xDB array size: 0..15 fixarray 0x90..0x9F array size: 16..65535 array 16 0xDC array size: 65536..4294967295 array 32 0xDD object size: 0..15 fix map 0x80..0x8F object size: 16..65535 map 16 0xDE object size: 65536..4294967295 map 32 0xDF binary size: 0..255 bin 8 0xC4 binary size: 256..65535 bin 16 0xC5 binary size: 65536..4294967295 bin 32 0xC6 <p>Complete mapping</p> <p>The mapping is complete in the sense that any JSON value type can be converted to a MessagePack value.</p> <p>Any MessagePack output created by <code>to_msgpack</code> can be successfully parsed by <code>from_msgpack</code>.</p> <p>Size constraints</p> <p>The following values can not be converted to a MessagePack value:</p> <ul> <li>strings with more than 4294967295 bytes</li> <li>byte strings with more than 4294967295 bytes</li> <li>arrays with more than 4294967295 elements</li> <li>objects with more than 4294967295 elements</li> </ul> <p>NaN/infinity handling</p> <p>If NaN or Infinity are stored inside a JSON number, they are serialized properly in contrast to the dump function which serializes NaN or Infinity to <code>null</code>.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": 0})\"_json;\n\n    // serialize it to MessagePack\n    std::vector&lt;std::uint8_t&gt; v = json::to_msgpack(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        std::cout &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (int)byte &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>0x82 0xa7 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xc3 0xa6 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 \n</code></pre>"},{"location":"features/binary_formats/messagepack/#deserialization","title":"Deserialization","text":"<p>The library maps MessagePack types to JSON value types as follows:</p> MessagePack type JSON value type first byte positive fixint number_unsigned 0x00..0x7F fixmap object 0x80..0x8F fixarray array 0x90..0x9F fixstr string 0xA0..0xBF nil <code>null</code> 0xC0 false <code>false</code> 0xC2 true <code>true</code> 0xC3 float 32 number_float 0xCA float 64 number_float 0xCB uint 8 number_unsigned 0xCC uint 16 number_unsigned 0xCD uint 32 number_unsigned 0xCE uint 64 number_unsigned 0xCF int 8 number_integer 0xD0 int 16 number_integer 0xD1 int 32 number_integer 0xD2 int 64 number_integer 0xD3 str 8 string 0xD9 str 16 string 0xDA str 32 string 0xDB array 16 array 0xDC array 32 array 0xDD map 16 object 0xDE map 32 object 0xDF bin 8 binary 0xC4 bin 16 binary 0xC5 bin 32 binary 0xC6 ext 8 binary 0xC7 ext 16 binary 0xC8 ext 32 binary 0xC9 fixext 1 binary 0xD4 fixext 2 binary 0xD5 fixext 4 binary 0xD6 fixext 8 binary 0xD7 fixext 16 binary 0xD8 negative fixint number_integer 0xE0-0xFF <p>Info</p> <p>Any MessagePack output created by <code>to_msgpack</code> can be successfully parsed by <code>from_msgpack</code>.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x82, 0xa7, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63,\n                                   0x74, 0xc3, 0xa6, 0x73, 0x63, 0x68, 0x65, 0x6d,\n                                   0x61, 0x00\n                                  };\n\n    // deserialize it with MessagePack\n    json j = json::from_msgpack(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"features/binary_formats/ubjson/","title":"UBJSON","text":"<p>Universal Binary JSON (UBJSON) is a binary form directly imitating JSON, but requiring fewer bytes of data. It aims to achieve the generality of JSON, combined with being much easier to process than JSON.</p> <p>References</p> <ul> <li>UBJSON Website</li> </ul>"},{"location":"features/binary_formats/ubjson/#serialization","title":"Serialization","text":"<p>The library uses the following mapping from JSON values types to UBJSON types according to the UBJSON specification:</p> JSON value type value/range UBJSON type marker null <code>null</code> null <code>Z</code> boolean <code>true</code> true <code>T</code> boolean <code>false</code> false <code>F</code> number_integer -9223372036854775808..-2147483649 int64 <code>L</code> number_integer -2147483648..-32769 int32 <code>l</code> number_integer -32768..-129 int16 <code>I</code> number_integer -128..127 int8 <code>i</code> number_integer 128..255 uint8 <code>U</code> number_integer 256..32767 int16 <code>I</code> number_integer 32768..2147483647 int32 <code>l</code> number_integer 2147483648..9223372036854775807 int64 <code>L</code> number_unsigned 0..127 int8 <code>i</code> number_unsigned 128..255 uint8 <code>U</code> number_unsigned 256..32767 int16 <code>I</code> number_unsigned 32768..2147483647 int32 <code>l</code> number_unsigned 2147483648..9223372036854775807 int64 <code>L</code> number_unsigned 2147483649..18446744073709551615 high-precision <code>H</code> number_float any value float64 <code>D</code> string with shortest length indicator string <code>S</code> array see notes on optimized format array <code>[</code> object see notes on optimized format map <code>{</code> <p>Complete mapping</p> <p>The mapping is complete in the sense that any JSON value type can be converted to a UBJSON value.</p> <p>Any UBJSON output created by <code>to_ubjson</code> can be successfully parsed by <code>from_ubjson</code>.</p> <p>Size constraints</p> <p>The following values can not be converted to a UBJSON value:</p> <ul> <li>strings with more than 9223372036854775807 bytes (theoretical)</li> </ul> <p>Unused UBJSON markers</p> <p>The following markers are not used in the conversion:</p> <ul> <li><code>Z</code>: no-op values are not created.</li> <li><code>C</code>: single-byte strings are serialized with <code>S</code> markers.</li> </ul> <p>NaN/infinity handling</p> <p>If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the <code>dump()</code> function which serializes NaN or Infinity to <code>null</code>.</p> <p>Optimized formats</p> <p>The optimized formats for containers are supported: Parameter <code>use_size</code> adds size information to the beginning of a container and removes the closing marker. Parameter <code>use_type</code> further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The <code>use_type</code> parameter must only be used together with <code>use_size = true</code>.</p> <p>Note that <code>use_size = true</code> alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container.</p> <p>Binary values</p> <p>If the JSON data contains the binary type, the value stored is a list of integers, as suggested by the UBJSON documentation.  In particular, this means that serialization and the deserialization of a JSON containing binary values into UBJSON and back will result in a different JSON object.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\n// function to print UBJSON's diagnostic format\nvoid print_byte(uint8_t byte)\n{\n    if (32 &lt; byte and byte &lt; 128)\n    {\n        std::cout &lt;&lt; (char)byte;\n    }\n    else\n    {\n        std::cout &lt;&lt; (int)byte;\n    }\n}\n\nint main()\n{\n    // create a JSON value\n    json j = R\"({\"compact\": true, \"schema\": false})\"_json;\n\n    // serialize it to UBJSON\n    std::vector&lt;std::uint8_t&gt; v = json::to_ubjson(j);\n\n    // print the vector content\n    for (auto&amp; byte : v)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // create an array of numbers\n    json array = {1, 2, 3, 4, 5, 6, 7, 8};\n\n    // serialize it to UBJSON using default representation\n    std::vector&lt;std::uint8_t&gt; v_array = json::to_ubjson(array);\n    // serialize it to UBJSON using size optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size = json::to_ubjson(array, true);\n    // serialize it to UBJSON using type optimization\n    std::vector&lt;std::uint8_t&gt; v_array_size_and_type = json::to_ubjson(array, true, true);\n\n    // print the vector contents\n    for (auto&amp; byte : v_array)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n\n    for (auto&amp; byte : v_array_size_and_type)\n    {\n        print_byte(byte);\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{i7compactTi6schemaF}\n[i1i2i3i4i5i6i7i8]\n[#i8i1i2i3i4i5i6i7i8\n[$i#i812345678\n</code></pre>"},{"location":"features/binary_formats/ubjson/#deserialization","title":"Deserialization","text":"<p>The library maps UBJSON types to JSON value types as follows:</p> UBJSON type JSON value type marker no-op no value, next value is read <code>N</code> null <code>null</code> <code>Z</code> false <code>false</code> <code>F</code> true <code>true</code> <code>T</code> float32 number_float <code>d</code> float64 number_float <code>D</code> uint8 number_unsigned <code>U</code> int8 number_integer <code>i</code> int16 number_integer <code>I</code> int32 number_integer <code>l</code> int64 number_integer <code>L</code> string string <code>S</code> char string <code>C</code> array array (optimized values are supported) <code>[</code> object object (optimized values are supported) <code>{</code> <p>Complete mapping</p> <p>The mapping is complete in the sense that any UBJSON value can be converted to a JSON value.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // create byte vector\n    std::vector&lt;std::uint8_t&gt; v = {0x7B, 0x69, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61,\n                                   0x63, 0x74, 0x54, 0x69, 0x06, 0x73, 0x63, 0x68,\n                                   0x65, 0x6D, 0x61, 0x69, 0x00, 0x7D\n                                  };\n\n    // deserialize it with UBJSON\n    json j = json::from_ubjson(v);\n\n    // print the deserialized JSON value\n    std::cout &lt;&lt; std::setw(2) &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>{\n  \"compact\": true,\n  \"schema\": 0\n}\n</code></pre>"},{"location":"features/element_access/","title":"Element Access","text":"<p>There are many ways elements in a JSON value can be accessed:</p> <ul> <li>unchecked access via <code>operator[]</code></li> <li>checked access via <code>at</code></li> <li>access with default value via <code>value</code></li> <li>iterators</li> <li>JSON pointers</li> </ul>"},{"location":"features/element_access/checked_access/","title":"Checked access: at","text":""},{"location":"features/element_access/checked_access/#overview","title":"Overview","text":"<p>The <code>at</code> member function performs checked access; that is, it returns a reference to the desired value if it exists and throws a <code>basic_json::out_of_range</code> exception otherwise.</p> Read access <p>Consider the following JSON value:</p> <pre><code>{\n    \"name\": \"Mary Smith\",\n    \"age\": 42,\n    \"hobbies\": [\"hiking\", \"reading\"]\n}\n</code></pre> <p>Assume the value is parsed to a <code>json</code> variable <code>j</code>.</p> expression value <code>j</code> <code>{\"name\": \"Mary Smith\", \"age\": 42, \"hobbies\": [\"hiking\", \"reading\"]}</code> <code>j.at(\"name\")</code> <code>\"Mary Smith\"</code> <code>j.at(\"age\")</code> <code>42</code> <code>j.at(\"hobbies\")</code> <code>[\"hiking\", \"reading\"]</code> <code>j.at(\"hobbies\").at(0)</code> <code>\"hiking\"</code> <code>j.at(\"hobbies\").at(1)</code> <code>\"reading\"</code> <p>The return value is a reference, so it can be modified by the original value.</p> Write access <pre><code>j.at(\"name\") = \"John Smith\";\n</code></pre> <p>This code produces the following JSON value:</p> <pre><code>{\n    \"name\": \"John Smith\",\n    \"age\": 42,\n    \"hobbies\": [\"hiking\", \"reading\"]\n}\n</code></pre> <p>When accessing an invalid index (i.e., an index greater than or equal to the array size) or the passed object key is non-existing, an exception is thrown.</p> Accessing via invalid index or missing key <pre><code>j.at(\"hobbies\").at(3) = \"cooking\";\n</code></pre> <p>This code produces the following exception:</p> <pre><code>[json.exception.out_of_range.401] array index 3 is out of range\n</code></pre> <p>When you extended diagnostic messages are enabled by defining <code>JSON_DIAGNOSTICS</code>, the exception further gives information where the key or index is missing or out of range.</p> <pre><code>[json.exception.out_of_range.401] (/hobbies) array index 3 is out of range\n</code></pre>"},{"location":"features/element_access/checked_access/#notes","title":"Notes","text":"<p>Exceptions</p> <ul> <li><code>at</code> can only be used with objects (with a string argument) or with arrays (with a   numeric argument). For other types, a <code>basic_json::type_error</code>   is thrown.</li> <li><code>basic_json::out_of_range</code> exception exceptions are thrown if the   provided key is not found in an object or the provided index is invalid.</li> </ul>"},{"location":"features/element_access/checked_access/#summary","title":"Summary","text":"scenario non-const value const value access to existing object key reference to existing value is returned const reference to existing value is returned access to valid array index reference to existing value is returned const reference to existing value is returned access to non-existing object key <code>basic_json::out_of_range</code> exception is thrown <code>basic_json::out_of_range</code> exception is thrown access to invalid array index <code>basic_json::out_of_range</code> exception is thrown <code>basic_json::out_of_range</code> exception is thrown"},{"location":"features/element_access/default_value/","title":"Access with default value: value","text":""},{"location":"features/element_access/default_value/#overview","title":"Overview","text":"<p>In many situations, such as configuration files, missing values are not exceptional, but may be treated as if a default value was present. For this case, use <code>value(key, default_value)</code> which takes the key you want to access and a default value in case there is no value stored with that key.</p>"},{"location":"features/element_access/default_value/#example","title":"Example","text":"Example <p>Consider the following JSON value:</p> <pre><code>{\n    \"logOutput\": \"result.log\",\n    \"append\": true\n}\n</code></pre> <p>Assume the value is parsed to a <code>json</code> variable <code>j</code>.</p> expression value <code>j</code> <code>{\"logOutput\": \"result.log\", \"append\": true}</code> <code>j.value(\"logOutput\", \"logfile.log\")</code> <code>\"result.log\"</code> <code>j.value(\"append\", true)</code> <code>true</code> <code>j.value(\"append\", false)</code> <code>true</code> <code>j.value(\"logLevel\", \"verbose\")</code> <code>\"verbose\"</code>"},{"location":"features/element_access/default_value/#notes","title":"Notes","text":"<p>Exceptions</p> <ul> <li><code>value</code> can only be used with objects. For other types, a <code>basic_json::type_error</code> is thrown.</li> </ul> <p>Return type</p> <p>The value function is a template, and the return type of the function is determined by the type of the provided default value unless otherwise specified. This can have unexpected effects. In the example below, we store a 64-bit unsigned integer. We get exactly that value when using <code>operator[]</code>. However, when we call <code>value</code> and provide <code>0</code> as default value, then <code>-1</code> is returned. The occurs, because <code>0</code> has type <code>int</code> which overflows when handling the value <code>18446744073709551615</code>.</p> <p>To address this issue, either provide a correctly typed default value or use the template parameter to specify the desired return type. Note that this issue occurs even when a value is stored at the provided key, and the default value is not used as the return value.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j = json::parse(R\"({\"uint64\": 18446744073709551615})\");\n\n    std::cout &lt;&lt; \"operator[]:                \" &lt;&lt; j[\"uint64\"] &lt;&lt; '\\n'\n              &lt;&lt; \"default value (int):       \" &lt;&lt; j.value(\"uint64\", 0) &lt;&lt; '\\n'\n              &lt;&lt; \"default value (uint64_t):  \" &lt;&lt; j.value(\"uint64\", std::uint64_t(0)) &lt;&lt; '\\n'\n              &lt;&lt; \"explicit return value type: \" &lt;&lt; j.value&lt;std::uint64_t&gt;(\"uint64\", 0) &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>operator[]:                18446744073709551615\ndefault value (int):       -1\ndefault value (uint64_t):  18446744073709551615\nexplicit return value type: 18446744073709551615\n</code></pre>"},{"location":"features/element_access/default_value/#see-also","title":"See also","text":"<ul> <li><code>value</code> for access with default value</li> <li>documentation on checked access</li> </ul>"},{"location":"features/element_access/unchecked_access/","title":"Unchecked access: operator[]","text":""},{"location":"features/element_access/unchecked_access/#overview","title":"Overview","text":"<p>Elements in a JSON object and a JSON array can be accessed via <code>operator[]</code> similar to a <code>std::map</code> and a <code>std::vector</code>, respectively.</p> Read access <p>Consider the following JSON value:</p> <pre><code>{\n    \"name\": \"Mary Smith\",\n    \"age\": 42,\n    \"hobbies\": [\"hiking\", \"reading\"]\n}\n</code></pre> <p>Assume the value is parsed to a <code>json</code> variable <code>j</code>.</p> expression value <code>j</code> <code>{\"name\": \"Mary Smith\", \"age\": 42, \"hobbies\": [\"hiking\", \"reading\"]}</code> <code>j[\"name\"]</code> <code>\"Mary Smith\"</code> <code>j[\"age\"]</code> <code>42</code> <code>j[\"hobbies\"]</code> <code>[\"hiking\", \"reading\"]</code> <code>j[\"hobbies\"][0]</code> <code>\"hiking\"</code> <code>j[\"hobbies\"][1]</code> <code>\"reading\"</code> <p>The return value is a reference, so it can modify the original value. In case the passed object key is non-existing, a <code>null</code> value is inserted which can immediately be overwritten.</p> Write access <pre><code>j[\"name\"] = \"John Smith\";\nj[\"maidenName\"] = \"Jones\";\n</code></pre> <p>This code produces the following JSON value:</p> <pre><code>{\n    \"name\": \"John Smith\",\n    \"maidenName\": \"Jones\",\n    \"age\": 42,\n    \"hobbies\": [\"hiking\", \"reading\"]\n}\n</code></pre> <p>When accessing an invalid index (i.e., an index greater than or equal to the array size), the JSON array is resized such that the passed index is the new maximal index. Intermediate values are filled with <code>null</code>.</p> Filling up arrays with <code>null</code> values <pre><code>j[\"hobbies\"][0] = \"running\";\nj[\"hobbies\"][3] = \"cooking\";\n</code></pre> <p>This code produces the following JSON value:</p> <pre><code>{\n    \"name\": \"John Smith\",\n    \"maidenName\": \"Jones\",\n    \"age\": 42,\n    \"hobbies\": [\"running\", \"reading\", null, \"cooking\"]\n}\n</code></pre>"},{"location":"features/element_access/unchecked_access/#notes","title":"Notes","text":"<p>Design rationale</p> <p>The library behaves differently to <code>std::vector</code> and <code>std::map</code>:</p> <ul> <li><code>std::vector::operator[]</code> never inserts a new element.</li> <li><code>std::map::operator[]</code> is not available for const values.</li> </ul> <p>The type <code>json</code> wraps all JSON value types. It would be impossible to remove <code>operator[]</code> for const objects. At the same time, inserting elements for non-const objects is really convenient as it avoids awkward <code>insert</code> calls. To this end, we decided to have an inserting non-const behavior for both arrays and objects.</p> <p>Info</p> <p>The access is unchecked. In case the passed object key does not exist or the passed array index is invalid, no exception is thrown.</p> <p>Danger</p> <ul> <li>It is undefined behavior to access a const object with a non-existing key.</li> <li>It is undefined behavior to access a const array with an invalid index.</li> <li>In debug mode, an assertion will fire in both cases. You can disable assertions by defining the preprocessor   symbol <code>NDEBUG</code> or redefine the macro <code>JSON_ASSERT(x)</code>. See the documentation   on runtime assertions for more information.</li> </ul> <p>Exceptions</p> <p><code>operator[]</code> can only be used with objects (with a string argument) or with arrays (with a numeric argument). For other types, a <code>basic_json::type_error</code> is thrown.</p>"},{"location":"features/element_access/unchecked_access/#summary","title":"Summary","text":"scenario non-const value const value access to existing object key reference to existing value is returned const reference to existing value is returned access to valid array index reference to existing value is returned const reference to existing value is returned access to non-existing object key reference to newly inserted <code>null</code> value is returned undefined behavior; runtime assertion in debug mode access to invalid array index reference to newly inserted <code>null</code> value is returned; any index between previous maximal index and passed index are filled with <code>null</code> undefined behavior; runtime assertion in debug mode"},{"location":"features/parsing/","title":"Parsing","text":"<p>Note</p> <p>This page is under construction.</p>"},{"location":"features/parsing/#input","title":"Input","text":""},{"location":"features/parsing/#sax-vs-dom-parsing","title":"SAX vs. DOM parsing","text":""},{"location":"features/parsing/#exceptions","title":"Exceptions","text":"<p>See parsing and exceptions.</p>"},{"location":"features/parsing/json_lines/","title":"JSON Lines","text":"<p>The JSON Lines format is a text format of newline-delimited JSON. In particular:</p> <ol> <li>The input must be UTF-8 encoded.</li> <li>Every line must be a valid JSON value.</li> <li>The line separator must be <code>\\n</code>. As <code>\\r</code> is silently ignored, <code>\\r\\n</code> is also supported.</li> <li>The final character may be <code>\\n</code>, but is not required to be one.</li> </ol> <p>JSON Text example</p> <pre><code>{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}\n{\"name\": \"Alexa\", \"wins\": [[\"two pair\", \"4\u2660\"], [\"two pair\", \"9\u2660\"]]}\n{\"name\": \"May\", \"wins\": []}\n{\"name\": \"Deloise\", \"wins\": [[\"three of a kind\", \"5\u2663\"]]}\n</code></pre> <p>JSON Lines input with more than one value is treated as invalid JSON by the <code>parse</code> or <code>accept</code> functions. To process it line by line, functions like <code>std::getline</code> can be used:</p> <p>Example: Parse JSON Text input line by line</p> <p>The example below demonstrates how JSON Lines can be processed.</p> <pre><code>#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // JSON Lines (see https://jsonlines.org)\n    std::stringstream input;\n    input &lt;&lt; R\"({\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}\n{\"name\": \"Alexa\", \"wins\": [[\"two pair\", \"4\u2660\"], [\"two pair\", \"9\u2660\"]]}\n{\"name\": \"May\", \"wins\": []}\n{\"name\": \"Deloise\", \"wins\": [[\"three of a kind\", \"5\u2663\"]]}\n)\";\n\n    std::string line;\n    while (std::getline(input, line))\n    {\n        std::cout &lt;&lt; json::parse(line) &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>{\"name\":\"Gilbert\",\"wins\":[[\"straight\",\"7\u2663\"],[\"one pair\",\"10\u2665\"]]}\n{\"name\":\"Alexa\",\"wins\":[[\"two pair\",\"4\u2660\"],[\"two pair\",\"9\u2660\"]]}\n{\"name\":\"May\",\"wins\":[]}\n{\"name\":\"Deloise\",\"wins\":[[\"three of a kind\",\"5\u2663\"]]}\n</code></pre> <p>Note</p> <p>Using <code>operator&gt;&gt;</code> like</p> <pre><code>json j;\nwhile (input &gt;&gt; j)\n{\n    std::cout &lt;&lt; j &lt;&lt; std::endl;\n}\n</code></pre> <p>with a JSON Lines input does not work, because the parser will try to parse one value after the last one.</p>"},{"location":"features/parsing/parse_exceptions/","title":"Parsing and Exceptions","text":"<p>When the input is not valid JSON, an exception of type <code>parse_error</code> is thrown. This exception contains the position in the input where the error occurred, together with a diagnostic message and the last read input token. The exceptions page contains a list of examples for parse error exceptions. In case you process untrusted input, always enclose your code with a <code>try</code>/<code>catch</code> block, like</p> <pre><code>json j;\ntry\n{\n    j = json::parse(my_input);\n}\ncatch (json::parse_error&amp; ex)\n{\n    std::cerr &lt;&lt; \"parse error at byte \" &lt;&lt; ex.byte &lt;&lt; std::endl;\n}\n</code></pre> <p>In case exceptions are undesired or not supported by the environment, there are different ways to proceed:</p>"},{"location":"features/parsing/parse_exceptions/#switch-off-exceptions","title":"Switch off exceptions","text":"<p>The <code>parse()</code> function accepts a <code>bool</code> parameter <code>allow_exceptions</code> which controls whether an exception is thrown when a parse error occurs (<code>true</code>, default) or whether a discarded value should be returned (<code>false</code>).</p> <pre><code>json j = json::parse(my_input, nullptr, false);\nif (j.is_discarded())\n{\n    std::cerr &lt;&lt; \"parse error\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Note there is no diagnostic information available in this scenario.</p>"},{"location":"features/parsing/parse_exceptions/#use-accept-function","title":"Use accept() function","text":"<p>Alternatively, function <code>accept()</code> can be used which does not return a <code>json</code> value, but a <code>bool</code> indicating whether the input is valid JSON.</p> <pre><code>if (!json::accept(my_input))\n{\n    std::cerr &lt;&lt; \"parse error\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Again, there is no diagnostic information available.</p>"},{"location":"features/parsing/parse_exceptions/#user-defined-sax-interface","title":"User-defined SAX interface","text":"<p>Finally, you can implement the SAX interface and decide what should happen in case of a parse error.</p> <p>This function has the following interface:</p> <pre><code>bool parse_error(std::size_t position,\n                 const std::string&amp; last_token,\n                 const json::exception&amp; ex);\n</code></pre> <p>The return value indicates whether the parsing should continue, so the function should usually return <code>false</code>.</p> Example <pre><code>#include &lt;iostream&gt;\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nclass sax_no_exception : public nlohmann::detail::json_sax_dom_parser&lt;json&gt;\n{\n  public:\n    sax_no_exception(json&amp; j)\n      : nlohmann::detail::json_sax_dom_parser&lt;json&gt;(j, false)\n    {}\n\n    bool parse_error(std::size_t position,\n                     const std::string&amp; last_token,\n                     const json::exception&amp; ex)\n    {\n        std::cerr &lt;&lt; \"parse error at input byte \" &lt;&lt; position &lt;&lt; \"\\n\"\n                  &lt;&lt; ex.what() &lt;&lt; \"\\n\"\n                  &lt;&lt; \"last read: \\\"\" &lt;&lt; last_token &lt;&lt; \"\\\"\"\n                  &lt;&lt; std::endl;\n        return false;\n    }\n};\n\nint main()\n{\n    std::string myinput = \"[1,2,3,]\";\n\n    json result;\n    sax_no_exception sax(result);\n\n    bool parse_result = json::sax_parse(myinput, &amp;sax);\n    if (!parse_result)\n    {\n        std::cerr &lt;&lt; \"parsing unsuccessful!\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"parsed value: \" &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>Output:</p> <pre><code>parse error at input byte 8\n[json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal\nlast read: \"3,]\"\nparsing unsuccessful!\nparsed value: [1,2,3]\n</code></pre>"},{"location":"features/parsing/parser_callbacks/","title":"Parser Callbacks","text":""},{"location":"features/parsing/parser_callbacks/#overview","title":"Overview","text":"<p>With a parser callback function, the result of parsing a JSON text can be influenced. When passed to <code>parse</code>, it is called on certain events (passed as <code>parse_event_t</code> via parameter <code>event</code>) with a set recursion depth <code>depth</code> and context JSON value <code>parsed</code>. The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not.</p> <p>The type of the callback function is:</p> <pre><code>template&lt;typename BasicJsonType&gt;\nusing parser_callback_t =\n    std::function&lt;bool(int depth, parse_event_t event, BasicJsonType&amp; parsed)&gt;;\n</code></pre>"},{"location":"features/parsing/parser_callbacks/#callback-event-types","title":"Callback event types","text":"<p>We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters <code>depth</code>, <code>event</code>, and <code>parsed</code>.</p> parameter <code>event</code> description parameter <code>depth</code> parameter <code>parsed</code> <code>parse_event_t::object_start</code> the parser read <code>{</code> and started to process a JSON object depth of the parent of the JSON object a JSON value with type discarded <code>parse_event_t::key</code> the parser read a key of a value in an object depth of the currently parsed JSON object a JSON string containing the key <code>parse_event_t::object_end</code> the parser read <code>}</code> and finished processing a JSON object depth of the parent of the JSON object the parsed JSON object <code>parse_event_t::array_start</code> the parser read <code>[</code> and started to process a JSON array depth of the parent of the JSON array a JSON value with type discarded <code>parse_event_t::array_end</code> the parser read <code>]</code> and finished processing a JSON array depth of the parent of the JSON array the parsed JSON array <code>parse_event_t::value</code> the parser finished reading a JSON value depth of the value the parsed JSON value Example <p>When parsing the following JSON text,</p> <pre><code>{\n    \"name\": \"Berlin\",\n    \"location\": [\n        52.519444,\n        13.406667\n    ]\n}\n</code></pre> <p>these calls are made to the callback function:</p> event depth parsed <code>object_start</code> 0 discarded <code>key</code> 1 <code>\"name\"</code> <code>value</code> 1 <code>\"Berlin\"</code> <code>key</code> 1 <code>\"location\"</code> <code>array_start</code> 1 discarded <code>value</code> 2 <code>52.519444</code> <code>value</code> 2 <code>13.406667</code> <code>array_end</code> 1 <code>[52.519444,13.406667]</code> <code>object_end</code> 0 <code>{\"location\":[52.519444,13.406667],\"name\":\"Berlin\"}</code>"},{"location":"features/parsing/parser_callbacks/#return-value","title":"Return value","text":"<p>Discarding a value (i.e., returning <code>false</code>) has different effects depending on the context in which the function was called:</p> <ul> <li>Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never   read.</li> <li>In case a value outside a structured type is skipped, it is replaced with <code>null</code>. This case happens if the   top-level element is skipped.</li> </ul> Example <p>The example below demonstrates the <code>parse()</code> function with and without callback function.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    // a JSON text\n    auto text = R\"(\n    {\n        \"Image\": {\n            \"Width\":  800,\n            \"Height\": 600,\n            \"Title\":  \"View from 15th Floor\",\n            \"Thumbnail\": {\n                \"Url\":    \"http://www.example.com/image/481989943\",\n                \"Height\": 125,\n                \"Width\":  100\n            },\n            \"Animated\" : false,\n            \"IDs\": [116, 943, 234, 38793]\n        }\n    }\n    )\";\n\n    // parse and serialize JSON\n    json j_complete = json::parse(text);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_complete &lt;&lt; \"\\n\\n\";\n\n    // define parser callback\n    json::parser_callback_t cb = [](int depth, json::parse_event_t event, json &amp; parsed)\n    {\n        // skip object elements with key \"Thumbnail\"\n        if (event == json::parse_event_t::key and parsed == json(\"Thumbnail\"))\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    };\n\n    // parse (with callback) and serialize JSON\n    json j_filtered = json::parse(text, cb);\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; j_filtered &lt;&lt; '\\n';\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Thumbnail\": {\n            \"Height\": 125,\n            \"Url\": \"http://www.example.com/image/481989943\",\n            \"Width\": 100\n        },\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n\n{\n    \"Image\": {\n        \"Animated\": false,\n        \"Height\": 600,\n        \"IDs\": [\n            116,\n            943,\n            234,\n            38793\n        ],\n        \"Title\": \"View from 15th Floor\",\n        \"Width\": 800\n    }\n}\n</code></pre>"},{"location":"features/parsing/sax_interface/","title":"SAX Interface","text":"<p>The library uses a SAX-like interface with the following functions:</p> <pre><code>classDiagram\n\nclass sax_t [\"json::sax_t\"] {\n    &lt;&lt;interface&gt;&gt;\n    +bool null()*\n\n    +bool boolean(bool val)*\n\n    +bool number_integer(number_integer_t val)*\n    +bool number_unsigned(number_unsigned_t val)*\n\n    +bool number_float(number_float_t val, const string_t&amp; s)*\n\n    +bool string(string_t&amp; val)*\n    +bool binary(binary_t&amp; val)*\n\n    +bool start_object(std::size_t elements)*\n    +bool end_object()*\n    +bool start_array(std::size_t elements)*\n    +bool end_array()*\n    +bool key(string_t&amp; val)*\n\n    +bool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex)*\n}</code></pre> <pre><code>// called when null is parsed\nbool null();\n\n// called when a boolean is parsed; value is passed\nbool boolean(bool val);\n\n// called when a signed or unsigned integer number is parsed; value is passed\nbool number_integer(number_integer_t val);\nbool number_unsigned(number_unsigned_t val);\n\n// called when a floating-point number is parsed; value and original string is passed\nbool number_float(number_float_t val, const string_t&amp; s);\n\n// called when a string is parsed; value is passed and can be safely moved away\nbool string(string_t&amp; val);\n// called when a binary value is parsed; value is passed and can be safely moved away\nbool binary(binary_t&amp; val);\n\n// called when an object or array begins or ends, resp. The number of elements is passed (or -1 if not known)\nbool start_object(std::size_t elements);\nbool end_object();\nbool start_array(std::size_t elements);\nbool end_array();\n// called when an object key is parsed; value is passed and can be safely moved away\nbool key(string_t&amp; val);\n\n// called when a parse error occurs; byte position, the last token, and an exception is passed\nbool parse_error(std::size_t position, const std::string&amp; last_token, const json::exception&amp; ex);\n</code></pre> <p>The return value of each function determines whether parsing should proceed.</p> <p>To implement your own SAX handler, proceed as follows:</p> <ol> <li>Implement the SAX interface in a class. You can use class <code>nlohmann::json_sax&lt;json&gt;</code> as base class, but you can also use any class where the functions described above are implemented and public.</li> <li>Create an object of your SAX interface class, e.g. <code>my_sax</code>.</li> <li>Call <code>bool json::sax_parse(input, &amp;my_sax);</code> where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your SAX interface.</li> </ol> <p>Note the <code>sax_parse</code> function only returns a <code>bool</code> indicating the result of the last executed SAX event. It does not return <code>json</code> value - it is up to you to decide what to do with the SAX events. Furthermore, no exceptions are thrown in case of a parse error - it is up to you what to do with the exception object passed to your <code>parse_error</code> implementation. Internally, the SAX interface is used for the DOM parser (class <code>json_sax_dom_parser</code>) as well as the acceptor (<code>json_sax_acceptor</code>), see file <code>json_sax.hpp</code>.</p>"},{"location":"features/parsing/sax_interface/#see-also","title":"See also","text":"<ul> <li>json_sax - documentation of the SAX interface</li> <li>sax_parse - SAX parser</li> </ul>"},{"location":"features/types/","title":"Types","text":"<p>This page gives an overview of how JSON values are stored and how this can be configured.</p>"},{"location":"features/types/#overview","title":"Overview","text":"<p>By default, JSON values are stored as follows:</p> JSON type C++ type object <code>std::map&lt;std::string, basic_json&gt;</code> array <code>std::vector&lt;basic_json&gt;</code> null <code>std::nullptr_t</code> string <code>std::string</code> boolean <code>bool</code> number <code>std::int64_t</code>, <code>std::uint64_t</code>, and <code>double</code> <p>Note there are three different types for numbers - when parsing JSON text, the best fitting type is chosen.</p>"},{"location":"features/types/#storage","title":"Storage","text":"<pre><code>classDiagram\n\nclass value_t {\n    &lt;&lt;enumeration&gt;&gt;\n    null\n    object\n    array\n    string\n    boolean\n    number_integer\n    number_unsigned\n    number_float\n    binary\n    discarded\n}\n\nclass json_value {\n    &lt;&lt;union&gt;&gt;\n    object_t* object\n    array_t* array\n    string_t* string\n    binary_t* binary\n    boolean_t boolean\n    number_integer_t number_integer\n    number_unsigned_t number_unsigned\n    number_float_t number_float\n}\n\nclass basic_json {\n    -value_t m_type\n    -json_value m_value\n    +typedef object_t\n    +typedef array_t\n    +typedef binary_t\n    +typedef boolean_t\n    +typedef number_integer_t\n    +typedef number_unsigned_t\n    +typedef number_float_t\n}\n\nbasic_json .. json_value\nbasic_json .. value_t</code></pre>"},{"location":"features/types/#template-arguments","title":"Template arguments","text":"<p>The data types to store a JSON value are derived from the template arguments passed to class <code>basic_json</code>:</p> <pre><code>template&lt;\n    template&lt;typename U, typename V, typename... Args&gt; class ObjectType = std::map,\n    template&lt;typename U, typename... Args&gt; class ArrayType = std::vector,\n    class StringType = std::string,\n    class BooleanType = bool,\n    class NumberIntegerType = std::int64_t,\n    class NumberUnsignedType = std::uint64_t,\n    class NumberFloatType = double,\n    template&lt;typename U&gt; class AllocatorType = std::allocator,\n    template&lt;typename T, typename SFINAE = void&gt; class JSONSerializer = adl_serializer,\n    class BinaryType = std::vector&lt;std::uint8_t&gt;\n&gt;\nclass basic_json;\n</code></pre> <p>Type <code>json</code> is an alias for <code>basic_json&lt;&gt;</code> and uses the default types.</p> <p>From the template arguments, the following types are derived:</p> <pre><code>using object_comparator_t = std::less&lt;&gt;;\nusing object_t = ObjectType&lt;StringType, basic_json, object_comparator_t,\n                   AllocatorType&lt;std::pair&lt;const StringType, basic_json&gt;&gt;&gt;;\n\nusing array_t = ArrayType&lt;basic_json, AllocatorType&lt;basic_json&gt;&gt;;\n\nusing string_t = StringType;\n\nusing boolean_t = BooleanType;\n\nusing number_integer_t = NumberIntegerType;\nusing number_unsigned_t = NumberUnsignedType;\nusing number_float_t = NumberFloatType;\n\nusing binary_t = nlohmann::byte_container_with_subtype&lt;BinaryType&gt;;\n</code></pre>"},{"location":"features/types/#objects","title":"Objects","text":"<p>RFC 8259 describes JSON objects as follows:</p> <p>An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.</p>"},{"location":"features/types/#default-type","title":"Default type","text":"<p>With the default values for ObjectType (<code>std::map</code>), StringType (<code>std::string</code>), and AllocatorType (<code>std::allocator</code>), the default value for <code>object_t</code> is:</p> <pre><code>std::map&lt;\n  std::string, // key_type\n  basic_json, // value_type\n  std::less&lt;&gt;, // key_compare\n  std::allocator&lt;std::pair&lt;const std::string, basic_json&gt;&gt; // allocator_type\n&gt;\n</code></pre>"},{"location":"features/types/#behavior","title":"Behavior","text":"<p>The choice of <code>object_t</code> influences the behavior of the JSON class. With the default type, objects have the following behavior:</p> <ul> <li>When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings.</li> <li>When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, <code>{\"key\": 2, \"key\": 1}</code> could be equal to either <code>{\"key\": 1}</code> or <code>{\"key\": 2}</code>.</li> <li>Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see <code>dump</code>) in this order. For instance, both <code>{\"b\": 1, \"a\": 2}</code> and <code>{\"a\": 2, \"b\": 1}</code> will be stored and serialized as <code>{\"a\": 2, \"b\": 1}</code>.</li> <li>When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, <code>{\"b\": 1, \"a\": 2}</code> and <code>{\"a\": 2, \"b\": 1}</code> will be treated as equal.</li> </ul>"},{"location":"features/types/#key-order","title":"Key order","text":"<p>The order name/value pairs are added to the object are not preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as <code>std::map</code> with <code>std::less</code> is used by default. Please note this behavior conforms to RFC 8259, because any order implements the specified \"unordered\" nature of JSON objects.</p>"},{"location":"features/types/#limits","title":"Limits","text":"<p>RFC 8259 specifies:</p> <p>An implementation may set limits on the maximum depth of nesting.</p> <p>In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <code>max_size</code> function of a JSON object.</p>"},{"location":"features/types/#storage_1","title":"Storage","text":"<p>Objects are stored as pointers in a <code>basic_json</code> type. That is, for any access to object values, a pointer of type <code>object_t*</code> must be dereferenced.</p>"},{"location":"features/types/#arrays","title":"Arrays","text":"<p>RFC 8259 describes JSON arrays as follows:</p> <p>An array is an ordered sequence of zero or more values.</p>"},{"location":"features/types/#default-type_1","title":"Default type","text":"<p>With the default values for ArrayType (<code>std::vector</code>) and AllocatorType (<code>std::allocator</code>), the default value for <code>array_t</code> is:</p> <pre><code>std::vector&lt;\n  basic_json, // value_type\n  std::allocator&lt;basic_json&gt; // allocator_type\n&gt;\n</code></pre>"},{"location":"features/types/#limits_1","title":"Limits","text":"<p>RFC 8259 specifies:</p> <p>An implementation may set limits on the maximum depth of nesting.</p> <p>In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <code>max_size</code> function of a JSON array.</p>"},{"location":"features/types/#storage_2","title":"Storage","text":"<p>Arrays are stored as pointers in a <code>basic_json</code> type. That is, for any access to array values, a pointer of type <code>array_t*</code> must be dereferenced.</p>"},{"location":"features/types/#strings","title":"Strings","text":"<p>RFC 8259 describes JSON strings as follows:</p> <p>A string is a sequence of zero or more Unicode characters.</p> <p>Unicode values are split by the JSON class into byte-sized characters during deserialization.</p>"},{"location":"features/types/#default-type_2","title":"Default type","text":"<p>With the default values for StringType (<code>std::string</code>), the default value for <code>string_t</code> is <code>std::string</code>.</p>"},{"location":"features/types/#encoding","title":"Encoding","text":"<p>Strings are stored in UTF-8 encoding. Therefore, functions like <code>std::string::size()</code> or <code>std::string::length()</code> return the number of bytes in the string rather than the number of characters or glyphs.</p>"},{"location":"features/types/#string-comparison","title":"String comparison","text":"<p>RFC 8259 states:</p> <p>Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that <code>\"a\\\\b\"</code> and <code>\"a\\u005Cb\"</code> are not equal.</p> <p>This implementation is interoperable as it does compare strings code unit by code unit.</p>"},{"location":"features/types/#storage_3","title":"Storage","text":"<p>String values are stored as pointers in a <code>basic_json</code> type. That is, for any access to string values, a pointer of type <code>string_t*</code> must be dereferenced.</p>"},{"location":"features/types/#booleans","title":"Booleans","text":"<p>RFC 8259 implicitly describes a boolean as a type which differentiates the two literals <code>true</code> and <code>false</code>.</p>"},{"location":"features/types/#default-type_3","title":"Default type","text":"<p>With the default values for BooleanType (<code>bool</code>), the default value for <code>boolean_t</code> is <code>bool</code>.</p>"},{"location":"features/types/#storage_4","title":"Storage","text":"<p>Boolean values are stored directly inside a <code>basic_json</code> type.</p>"},{"location":"features/types/#numbers","title":"Numbers","text":"<p>See the number handling article for a detailed discussion on how numbers are handled by this library.</p> <p>RFC 8259 describes numbers as follows:</p> <p>The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted.</p> <p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer, or a floating-point number. Therefore, three different types, <code>number_integer_t</code>, <code>number_unsigned_t</code>, and <code>number_float_t</code> are used.</p>"},{"location":"features/types/#default-types","title":"Default types","text":"<p>With the default values for NumberIntegerType (<code>std::int64_t</code>), the default value for <code>number_integer_t</code> is <code>std::int64_t</code>. With the default values for NumberUnsignedType (<code>std::uint64_t</code>), the default value for <code>number_unsigned_t</code> is <code>std::uint64_t</code>. With the default values for NumberFloatType (<code>double</code>), the default value for <code>number_float_t</code> is <code>double</code>.</p>"},{"location":"features/types/#default-behavior","title":"Default behavior","text":"<ul> <li>The restrictions about leading zeros are not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as an octal number. Internally, the value will be stored as a decimal number. For instance, the C++ integer literal <code>010</code> will be serialized to <code>8</code>. During deserialization, leading zeros yield an error.</li> <li>Not-a-number (NaN) values will be serialized to <code>null</code>.</li> </ul>"},{"location":"features/types/#limits_2","title":"Limits","text":"<p>RFC 8259 specifies:</p> <p>An implementation may set limits on the range and precision of numbers.</p> <p>When the default type is used, the maximal integer number that can be stored is <code>9223372036854775807</code> (<code>INT64_MAX</code>) and the minimal integer number that can be stored is <code>-9223372036854775808</code> (<code>INT64_MIN</code>). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will automatically be stored as <code>number_unsigned_t</code> or <code>number_float_t</code>.</p> <p>When the default type is used, the maximal unsigned integer number that can be stored is <code>18446744073709551615</code> (<code>UINT64_MAX</code>) and the minimal integer number that can be stored is <code>0</code>. Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will automatically be stored as <code>number_integer_t</code> or <code>number_float_t</code>.</p> <p>RFC 8259 further states:</p> <p>Note that when such software is used, numbers that are integers and are in the range [-2^{53}+1, 2^{53}-1] are interoperable in the sense that implementations will agree exactly on their numeric values.</p> <p>As this range is a subrange of the exactly supported range [<code>INT64_MIN</code>, <code>INT64_MAX</code>], this class's integer type is interoperable.</p> <p>RFC 8259 states:</p> <p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.</p> <p>This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than <code>-1.79769313486232e+308</code> and values greater than <code>1.79769313486232e+308</code> will be stored as NaN internally and be serialized to <code>null</code>.</p>"},{"location":"features/types/#storage_5","title":"Storage","text":"<p>Integer number values, unsigned integer number values, and floating-point number values are stored directly inside a <code>basic_json</code> type.</p>"},{"location":"features/types/number_handling/","title":"Number Handling","text":"<p>This document describes how the library is handling numbers.</p>"},{"location":"features/types/number_handling/#background","title":"Background","text":"<p>This section briefly summarizes how the JSON specification describes how numbers should be handled.</p>"},{"location":"features/types/number_handling/#json-number-syntax","title":"JSON number syntax","text":"<p>JSON defines the syntax of numbers as follows:</p> <p>RFC 8259, Section 6</p> <p>The representation of numbers is similar to that used in most programming languages.  A number is represented in base 10 using decimal digits.  It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part.  Leading zeros are not allowed.</p> <p>A fraction part is a decimal point followed by one or more digits.</p> <p>An exponent part begins with the letter E in uppercase or lowercase, which may be followed by a plus or minus sign.  The E and optional sign are followed by one or more digits.</p> <p>The following railroad diagram from json.org visualizes the number syntax:</p> <p></p>"},{"location":"features/types/number_handling/#number-interoperability","title":"Number interoperability","text":"<p>On number interoperability, the following remarks are made:</p> <p>RFC 8259, Section 6</p> <p>This specification allows implementations to set limits on the range and precision of numbers accepted.  Since software that implements IEEE 754 binary64 (double precision) numbers [IEEE754] is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision.  A JSON number such as 1E400 or 3.141592653589793238462643383279 may indicate potential interoperability problems, since it suggests that the software that created it expects receiving software to have greater capabilities for numeric magnitude and precision than is widely available.</p> <p>Note that when such software is used, numbers that are integers and are in the range [-2^{53}+1, 2^{53}-1] are interoperable in the sense that implementations will agree exactly on their numeric values.</p>"},{"location":"features/types/number_handling/#library-implementation","title":"Library implementation","text":"<p>This section describes how this library implements the above number specification.</p>"},{"location":"features/types/number_handling/#number-storage","title":"Number storage","text":"<p>In the default <code>json</code> type, numbers are stored as <code>std::uint64_t</code>, <code>std::int64_t</code>, and <code>double</code>, respectively. Thereby, <code>std::uint64_t</code> and <code>std::int64_t</code> are used only if they can store the  number without loss of precision. If this is impossible (e.g., if the number is too large), the number is stored as <code>double</code>.</p> <p>Notes</p> <ul> <li>Numbers with a decimal digit or scientific notation are always stored as <code>double</code>.</li> <li>The number types can be changed, see Template number types. </li> <li>As of version 3.9.1, the conversion is realized by   <code>std::strtoull</code>,   <code>std::strtoll</code>, and   <code>std::strtod</code>, respectively.</li> </ul> <p>Examples</p> <ul> <li>Integer <code>-12345678912345789123456789</code> is smaller than <code>INT64_MIN</code> and will be stored as floating-point   number <code>-1.2345678912345788e+25</code>.</li> <li>Integer <code>1E3</code> will be stored as floating-point number <code>1000.0</code>.</li> </ul>"},{"location":"features/types/number_handling/#number-limits","title":"Number limits","text":"<ul> <li>Any 64-bit signed or unsigned integer can be stored without loss of precision.</li> <li>Numbers exceeding the limits of <code>double</code> (i.e., numbers that after conversion via <code>std::strtod</code> are not satisfying <code>std::isfinite</code> such as <code>1E400</code>) will throw exception <code>json.exception.out_of_range.406</code> during parsing.</li> <li>Floating-point numbers are rounded to the next number representable as <code>double</code>. For instance <code>3.141592653589793238462643383279</code> is stored as <code>0x400921fb54442d18</code>. This is the same behavior as the code <code>double x = 3.141592653589793238462643383279;</code>.</li> </ul> <p>Interoperability</p> <ul> <li>The library interoperable with respect to the specification, because its supported range [-2^{63}, 2^{64}-1] is   larger than the described range [-2^{53}+1, 2^{53}-1].</li> <li>All integers outside the range [-2^{63}, 2^{64}-1], as well as floating-point numbers are stored as <code>double</code>.   This also concurs with the specification above.</li> </ul>"},{"location":"features/types/number_handling/#zeros","title":"Zeros","text":"<p>The JSON number grammar allows for different ways to express zero, and this library will store zeros differently:</p> Literal Stored value and type Serialization <code>0</code> <code>std::uint64_t(0)</code> <code>0</code> <code>-0</code> <code>std::int64_t(0)</code> <code>0</code> <code>0.0</code> <code>double(0.0)</code> <code>0.0</code> <code>-0.0</code> <code>double(-0.0)</code> <code>-0.0</code> <code>0E0</code> <code>double(0.0)</code> <code>0.0</code> <code>-0E0</code> <code>double(-0.0)</code> <code>-0.0</code> <p>That is, <code>-0</code> is stored as a signed integer, but the serialization does not reproduce the <code>-</code>.</p>"},{"location":"features/types/number_handling/#number-serialization","title":"Number serialization","text":"<ul> <li>Integer numbers are serialized as is; that is, no scientific notation is used.</li> <li>Floating-point numbers are serialized as specified by the <code>%g</code> printf modifier with    <code>std::numeric_limits&lt;double&gt;::max_digits10</code>   significant digits. The rationale is to use the shortest representation while still allowing round-tripping.</li> </ul> <p>Notes regarding precision of floating-point numbers</p> <p>As described above, floating-point numbers are rounded to the nearest double and serialized with the shortest representation to allow round-tripping. This can yield confusing examples:</p> <ul> <li>The serialization can have fewer decimal places than the input: <code>2555.5599999999999</code> will be serialized as   <code>2555.56</code>. The reverse can also be true.</li> <li>The serialization can be in scientific notation even if the input is not: <code>0.0000972439793401814</code> will be    serialized as <code>9.72439793401814e-05</code>. The reverse can also be true: <code>12345E-5</code> will be serialized as   <code>0.12345</code>.</li> <li>Conversions from <code>float</code> to <code>double</code> can also introduce rounding errors:     <pre><code>float f = 0.3;\njson j = f;\nstd::cout &lt;&lt; j &lt;&lt; '\\n';\n</code></pre>     yields <code>0.30000001192092896</code>.</li> </ul> <p>All examples here can be reproduced by passing the original double value to</p> <pre><code>std::printf(\"%.*g\\n\", std::numeric_limits&lt;double&gt;::max_digits10, double_value);\n</code></pre>"},{"location":"features/types/number_handling/#nan-handling","title":"NaN handling","text":"<p>NaN (not-a-number) cannot be expressed with the number syntax described above and are in fact explicitly excluded:</p> <p>RFC 8259, Section 6</p> <p>Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted.</p> <p>That is, there is no way to parse a NaN value. However, assignments can store NaN values in a JSON value.</p> <p>This library serializes NaN values  as <code>null</code>. This corresponds to the behavior of JavaScript's <code>JSON.stringify</code> function.</p> <p>Example</p> <p>The following example shows how a NaN value is stored in a <code>json</code> value.</p> <pre><code>int main()\n{\n    double val = std::numeric_limits&lt;double&gt;::quiet_NaN();\n    std::cout &lt;&lt; \"val=\" &lt;&lt; val &lt;&lt; std::endl;\n    json j = val;\n    std::cout &lt;&lt; \"j=\" &lt;&lt; j.dump() &lt;&lt; std::endl;\n    val = j;\n    std::cout &lt;&lt; \"val=\" &lt;&lt; val &lt;&lt; std::endl;\n}\n</code></pre> <p>output:</p> <pre><code>val=nan\nj=null\nval=nan\n</code></pre>"},{"location":"features/types/number_handling/#number-comparison","title":"Number comparison","text":"<p>Floating-point inside JSON values numbers are compared with <code>json::number_float_t::operator==</code> which is <code>double::operator==</code> by default.</p> <p>Alternative comparison functions</p> <p>To compare floating-point while respecting an epsilon, an alternative comparison function could be used, for instance</p> <p><pre><code>template&lt;typename T, typename = typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::type&gt;\ninline bool is_same(T a, T b, T epsilon = std::numeric_limits&lt;T&gt;::epsilon()) noexcept\n{\n    return std::abs(a - b) &lt;= epsilon;\n}\n</code></pre> Or you can self-define an operator equal function like this:</p> <pre><code>bool my_equal(const_reference lhs, const_reference rhs)\n{\n    const auto lhs_type lhs.type();\n    const auto rhs_type rhs.type();\n    if (lhs_type == rhs_type)\n    {\n        switch(lhs_type)\n        {\n            // self_defined case\n            case value_t::number_float:\n                return std::abs(lhs - rhs) &lt;= std::numeric_limits&lt;float&gt;::epsilon();\n\n            // other cases remain the same with the original\n            ...\n        }\n    }\n    ...\n}\n</code></pre> <p>(see #703 for more information.)</p> <p>Note</p> <p>NaN values never compare equal to themselves or to other NaN values. See #514.</p>"},{"location":"features/types/number_handling/#number-conversion","title":"Number conversion","text":"<p>Just like the C++ language itself, the <code>get</code> family of functions allows conversions between unsigned and signed integers, and between integers and floating-point values to integers. This behavior may be surprising.</p> <p>Unconditional number conversions</p> <pre><code>double d = 42.3;                                   // non-integer double value 42.3\njson jd = d;                                       // stores double value 42.3\nstd::int64_t i = jd.template get&lt;std::int64_t&gt;();  // now i==42; no warning or error is produced\n</code></pre> <p>Note the last line with throw a <code>json.exception.type_error.302</code> exception if <code>jd</code> is not a numerical type, for instance a string.</p> <p>The rationale is twofold:</p> <ol> <li>JSON does not define a number type or precision (see above).</li> <li>C++ also allows silently converting between number types.</li> </ol> <p>Conditional number conversion</p> <p>The code above can be solved by explicitly checking the nature of the value with members such as <code>is_number_integer()</code> or <code>is_number_unsigned()</code>:</p> <pre><code>// check if jd is really integer-valued\nif (jd.is_number_integer())\n{\n    // if so, do the conversion and use i\n    std::int64_t i = jd.template get&lt;std::int64_t&gt;();\n    // ...\n}\nelse\n{\n    // otherwise, take appropriate action\n    // ...\n}\n</code></pre> <p>Note this approach also has the advantage that it can react on non-numerical JSON value types such as strings.</p> <p>(Example taken from #777.)</p>"},{"location":"features/types/number_handling/#determine-number-types","title":"Determine number types","text":"<p>As the example in Number conversion shows, there are different functions to determine the type of the stored number:</p> <ul> <li><code>is_number()</code> returns <code>true</code> for any number type</li> <li><code>is_number_integer()</code> returns <code>true</code> for signed and unsigned integers</li> <li><code>is_number_unsigned()</code> returns <code>true</code> for unsigned integers only</li> <li><code>is_number_float()</code> returns <code>true</code> for floating-point numbers</li> <li><code>type_name()</code> returns <code>\"number\"</code> for any number type</li> <li><code>type()</code> returns a different enumerator of   <code>value_t</code> for all number types</li> </ul> function unsigned integer signed integer floating-point string <code>is_number()</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>is_number_integer()</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>is_number_unsigned()</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>is_number_float()</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>type_name()</code> <code>\"number\"</code> <code>\"number\"</code> <code>\"number\"</code> <code>\"string\"</code> <code>type()</code> <code>number_unsigned</code> <code>number_integer</code> <code>number_float</code> <code>string</code>"},{"location":"features/types/number_handling/#template-number-types","title":"Template number types","text":"<p>The number types can be changed with template parameters.</p> position number type default type possible values 5 signed integers <code>std::int64_t</code> <code>std::int32_t</code>, <code>std::int16_t</code>, etc. 6 unsigned integers <code>std::uint64_t</code> <code>std::uint32_t</code>, <code>std::uint16_t</code>, etc. 7 floating-point <code>double</code> <code>float</code>, <code>long double</code> <p>Constraints on number types</p> <ul> <li>The type for signed integers must be convertible from <code>long long</code>. The type for floating-point numbers is used   in case of overflow.</li> <li>The type for unsigned integers must be convertible from <code>unsigned long long</code>.  The type for floating-point   numbers is used in case of overflow.</li> <li>The types for signed and unsigned integers must be distinct, see   #2573.</li> <li>Only <code>double</code>, <code>float</code>, and <code>long double</code> are supported for floating-point numbers.</li> </ul> <p>Example</p> <p>A <code>basic_json</code> type that uses <code>long double</code> as floating-point type.</p> <pre><code>using json_ld = nlohmann::basic_json&lt;std::map, std::vector, std::string, bool,\n                                     std::int64_t, std::uint64_t, long double&gt;;\n</code></pre> <p>Note values should then be parsed with <code>json_ld::parse</code> rather than <code>json::parse</code> as the latter would parse floating-point values to <code>double</code> before then converting them to <code>long double</code>.</p>"},{"location":"home/architecture/","title":"Architecture","text":"<p>Info</p> <p>This page is still under construction. Its goal is to provide a high-level overview of the library's architecture. This should help new contributors to get an idea of the used concepts and where to make changes.</p>"},{"location":"home/architecture/#overview","title":"Overview","text":"<p>The main structure is class nlohmann::basic_json.</p> <ul> <li>public API</li> <li>container interface</li> <li>iterators</li> </ul>"},{"location":"home/architecture/#template-specializations","title":"Template specializations","text":"<ul> <li>describe template parameters of <code>basic_json</code></li> <li><code>json</code></li> <li><code>ordered_json</code> via <code>ordered_map</code></li> </ul>"},{"location":"home/architecture/#value-storage","title":"Value storage","text":"<p>Values are stored as a tagged union of value_t and json_value.</p> <pre><code>/// the type of the current element\nvalue_t m_type = value_t::null;\n\n/// the value of the current element\njson_value m_value = {};\n</code></pre> <p>with</p> <pre><code>enum class value_t : std::uint8_t\n{\n    null,             ///&lt; null value\n    object,           ///&lt; object (unordered set of name/value pairs)\n    array,            ///&lt; array (ordered collection of values)\n    string,           ///&lt; string value\n    boolean,          ///&lt; boolean value\n    number_integer,   ///&lt; number value (signed integer)\n    number_unsigned,  ///&lt; number value (unsigned integer)\n    number_float,     ///&lt; number value (floating-point)\n    binary,           ///&lt; binary array (ordered collection of bytes)\n    discarded         ///&lt; discarded by the parser callback function\n};\n\nunion json_value {\n  /// object (stored with pointer to save storage)\n  object_t *object;\n  /// array (stored with pointer to save storage)\n  array_t *array;\n  /// string (stored with pointer to save storage)\n  string_t *string;\n  /// binary (stored with pointer to save storage)\n  binary_t *binary;\n  /// boolean\n  boolean_t boolean;\n  /// number (integer)\n  number_integer_t number_integer;\n  /// number (unsigned integer)\n  number_unsigned_t number_unsigned;\n  /// number (floating-point)\n  number_float_t number_float;\n};\n</code></pre>"},{"location":"home/architecture/#parsing-inputs-deserialization","title":"Parsing inputs (deserialization)","text":"<p>Input is read via input adapters that abstract a source with a common interface:</p> <pre><code>/// read a single character\nstd::char_traits&lt;char&gt;::int_type get_character() noexcept;\n\n/// read multiple characters to a destination buffer and\n/// returns the number of characters successfully read\ntemplate&lt;class T&gt;\nstd::size_t get_elements(T* dest, std::size_t count = 1);\n</code></pre> <p>List examples of input adapters.</p>"},{"location":"home/architecture/#sax-interface","title":"SAX Interface","text":"<p>TODO</p>"},{"location":"home/architecture/#writing-outputs-serialization","title":"Writing outputs (serialization)","text":"<p>Output is written via output adapters:</p> <pre><code>template&lt;typename T&gt;\nvoid write_character(CharType c);\n\ntemplate&lt;typename CharType&gt;\nvoid write_characters(const CharType* s, std::size_t length);\n</code></pre> <p>List examples of output adapters.</p>"},{"location":"home/architecture/#value-conversion","title":"Value conversion","text":"<pre><code>template&lt;class T&gt;\nvoid to_json(basic_json&amp; j, const T&amp; t);\n\ntemplate&lt;class T&gt;\nvoid from_json(const basic_json&amp; j, T&amp; t);\n</code></pre>"},{"location":"home/architecture/#additional-features","title":"Additional features","text":"<ul> <li>JSON Pointers</li> <li>Binary formats</li> <li>Custom base class</li> <li>Conversion macros</li> </ul>"},{"location":"home/architecture/#details-namespace","title":"Details namespace","text":"<ul> <li>C++ feature backports</li> </ul>"},{"location":"home/customers/","title":"Customers","text":"<p>The library is used in multiple projects, applications, operating systems, etc. The list below is not exhaustive, but the result of an internet search. If you know further customers of the library, please let me know.</p> <p></p>"},{"location":"home/customers/#space-exploration","title":"Space Exploration","text":"<ul> <li>Peregrine Lunar Lander Flight 01 - The library was used for payload management in the Peregrine Moon Lander, developed by Astrobotic Technology and launched as part of NASA's Commercial Lunar Payload Services (CLPS) program. After six days in orbit, the spacecraft was intentionally redirected into Earth's atmosphere, where it burned up over the Pacific Ocean on January 18, 2024.</li> </ul>"},{"location":"home/customers/#automotive","title":"Automotive","text":"<ul> <li>Alexa Auto SDK, a software development kit enabling the integration of Alexa into automotive systems</li> <li>Apollo, a framework for building autonomous driving systems</li> <li>Automotive Grade Linux (AGL), a collaborative open-source platform for automotive software development</li> <li>Genesis Motor (infotainment), a luxury automotive brand</li> <li>Hyundai (infotainment), a global automotive brand</li> <li>Kia (infotainment), a global automotive brand</li> <li>Mercedes-Benz Operating System (MB.OS), a core component of the vehicle software ecosystem from Mercedes-Benz</li> <li>Rivian (infotainment), an electric vehicle manufacturer</li> <li>Suzuki (infotainment), a global automotive and motorcycle manufacturer</li> </ul>"},{"location":"home/customers/#gaming-and-entertainment","title":"Gaming and Entertainment","text":"<ul> <li>Assassin's Creed: Mirage, a stealth-action game set in the Middle East, focusing on the journey of a young assassin with classic parkour and stealth mechanics</li> <li>Chasm: The Rift, a first-person shooter blending horror and adventure, where players navigate dark realms and battle monsters</li> <li>College Football 25, a college football simulation game featuring gameplay that mimics real-life college teams and competitions</li> <li>Concepts, a digital sketching app designed for creative professionals, offering flexible drawing tools for illustration, design, and brainstorming</li> <li>Depthkit, a tool for creating and capturing volumetric video, enabling immersive 3D experiences and interactive content</li> <li>IMG.LY, a platform offering creative tools and SDKs for integrating advanced image and video editing in applications</li> <li>LOOT, a tool for optimizing the load order of game plugins, commonly used in The Elder Scrolls and Fallout series</li> <li>Madden NFL 25, a sports simulation game capturing the excitement of American football with realistic gameplay and team management features</li> <li>Marne, an unofficial private server platform for hosting custom Battlefield 1 game experiences</li> <li>Minecraft, a popular sandbox video game</li> <li>NHL 22, a hockey simulation game offering realistic gameplay, team management, and various modes to enhance the hockey experience</li> <li>Pixelpart, a 2D animation and video compositing software that allows users to create animated graphics and visual effects with a focus on simplicity and ease of use</li> <li>Razer Cortex, a gaming performance optimizer and system booster designed to enhance the gaming experience</li> <li>Red Dead Redemption II, an open-world action-adventure game following an outlaw's story in the late 1800s, emphasizing deep storytelling and immersive gameplay</li> <li>Snapchat, a multimedia messaging and augmented reality app for communication and entertainment</li> <li>Tactics Ogre: Reborn, a tactical role-playing game featuring strategic battles and deep storytelling elements</li> <li>Throne and Liberty, an MMORPG that offers an expansive fantasy world with dynamic gameplay and immersive storytelling</li> <li>Unity Vivox, a communication service that enables voice and text chat functionality in multiplayer games developed with Unity</li> <li>Zool: Redimensioned, a modern reimagining of the classic platformer featuring fast-paced gameplay and vibrant environments</li> <li>immersivetech, a technology company focused on immersive experiences, providing tools and solutions for virtual and augmented reality applications</li> </ul>"},{"location":"home/customers/#consumer-electronics","title":"Consumer Electronics","text":"<ul> <li>Audinate, a provider of networked audio solutions specializing in Dante technology, which facilitates high-quality digital audio transport over IP networks</li> <li>Canon CanoScan LIDE, a series of flatbed scanners offering high-resolution image scanning for home and office use</li> <li>Canon PIXMA Printers, a line of all-in-one inkjet printers known for high-quality printing and wireless connectivity</li> <li>Cisco Webex Desk Camera, a video camera designed for professional-quality video conferencing and remote collaboration</li> <li>Philips Hue Personal Wireless Lighting, a smart lighting system for customizable and wireless home illumination</li> <li>Ray-Ban Meta Smart glasses, a pair of smart glasses designed for capturing photos and videos with integrated connectivity and social features</li> <li>Razer Synapse, a unified configuration software enabling hardware customization for Razer devices</li> <li>Siemens SINEMA Remote Connect, a remote connectivity solution for monitoring and managing industrial networks and devices securely</li> <li>Sony PlayStation 4, a gaming console developed by Sony that offers a wide range of games and multimedia entertainment features</li> <li>Sony Virtual Webcam Driver for Remote Camera, a software driver that enables the use of Sony cameras as virtual webcams for video conferencing and streaming</li> </ul>"},{"location":"home/customers/#operating-systems","title":"Operating Systems","text":"<ul> <li>Apple iOS and macOS, a family of operating systems developed by Apple, including iOS for mobile devices and macOS for desktop computers</li> <li>Google Fuchsia, an open-source operating system developed by Google, designed to be secure, updatable, and adaptable across various devices</li> <li>SerenityOS, an open-source operating system that aims to provide a simple and beautiful user experience with a focus on simplicity and elegance</li> <li>Yocto, a Linux-based build system for creating custom operating systems and software distributions, tailored for embedded devices and IoT applications</li> </ul>"},{"location":"home/customers/#development-tools-and-ides","title":"Development Tools and IDEs","text":"<ul> <li>Accentize SpectralBalance, an adaptive speech analysis tool designed to enhance audio quality by optimizing frequency balance in recordings</li> <li>Arm Compiler for Linux, a software development toolchain for compiling and optimizing applications on Arm-based Linux systems</li> <li>BBEdit, a professional text and code editor for macOS</li> <li>CoderPad, a collaborative coding platform that enables real-time code interviews and assessments for developers; the library is included in every CoderPad instance and can be accessed with a simple <code>#include \"json.hpp\"</code></li> <li>Compiler Explorer, a web-based tool that allows users to write, compile, and visualize the assembly output of code in various programming languages; the library is readily available and accessible with the directive <code>#include &lt;nlohmann/json.hpp&gt;</code>.</li> <li>GitHub CodeQL, a code analysis tool used for identifying security vulnerabilities and bugs in software through semantic queries</li> <li>Hex-Rays, a reverse engineering toolset for analyzing and decompiling binaries, primarily used for security research and vulnerability analysis</li> <li>ImHex, a hex editor designed for reverse engineering, providing advanced features for data analysis and manipulation</li> <li>Intel GPA Framework, a suite of cross-platform tools for capturing, analyzing, and optimizing graphics applications across different APIs</li> <li>Intopix, a provider of advanced image processing and compression solutions used in software development and AV workflows</li> <li>MKVToolNix, a set of tools for creating, editing, and inspecting MKV (Matroska) multimedia container files</li> <li>Meta Yoga, a layout engine that facilitates flexible and efficient user interface design across multiple platforms</li> <li>NVIDIA Nsight Compute, a performance analysis tool for CUDA applications that provides detailed insights into GPU performance metrics</li> <li>Notepad++, a free source code editor that supports various programming languages</li> <li>OpenRGB, an open source RGB lighting control that doesn't depend on manufacturer software</li> <li>OpenTelemetry C++, a library for collecting and exporting observability data in C++, enabling developers to implement distributed tracing and metrics in their application</li> <li>Qt Creator, an IDE for developing applications using the Qt application framework</li> <li>Scanbot SDK, a software development kit (SDK) that provides tools for integrating advanced document scanning and barcode scanning capabilities into applications</li> </ul>"},{"location":"home/customers/#machine-learning-and-ai","title":"Machine Learning and AI","text":"<ul> <li>Apple Core ML Tools, a set of tools for converting and configuring machine learning models for deployment in Apple's Core ML framework</li> <li>Avular Mobile Robotics, a platform for developing and deploying mobile robotics solutions</li> <li>Google gemma.cpp, a lightweight C++ inference engine designed for running AI models from the Gemma family</li> <li>llama.cpp, a C++ library designed for efficient inference of large language models (LLMs), enabling streamlined integration into applications</li> <li>MLX, an array framework for machine learning on Apple Silicon</li> <li>Mozilla llamafile, a tool designed for distributing and executing large language models (LLMs) efficiently using a single file format</li> <li>NVIDIA ACE, a suite of real-time AI solutions designed for the development of interactive avatars and digital human applications, enabling scalable and sophisticated user interactions</li> <li>Peer, a platform offering personalized AI assistants for interactive learning and creative collaboration</li> <li>stable-diffusion.cpp, a C++ implementation of the Stable Diffusion image generation model</li> <li>TanvasTouch, a software development kit (SDK) that enables developers to create tactile experiences on touchscreens, allowing users to feel textures and physical sensations in a digital environment</li> <li>TensorFlow, a machine learning framework that facilitates the development and training of models, supporting data serialization and efficient data exchange between components</li> </ul>"},{"location":"home/customers/#scientific-research-and-analysis","title":"Scientific Research and Analysis","text":"<ul> <li>BLACK, a bounded linear temporal logic (LTL) satisfiability checker</li> <li>CERN Atlas Athena, a software framework used in the ATLAS experiment at the Large Hadron Collider (LHC) for performance monitoring</li> <li>ICU, the International Components for Unicode, a mature library for software globalization and multilingual support</li> <li>KAMERA, a platform for synchronized data collection and real-time deep learning to map marine species like polar bears and seals, aiding Arctic ecosystem research</li> <li>KiCad, a free and open-source software suite for electronic design automation</li> <li>Maple, a symbolic and numeric computing environment for advanced mathematical modeling and analysis</li> <li>MeVisLab, a software framework for medical image processing and visualization.</li> <li>OpenPMD API, a versatile programming interface for accessing and managing scientific data, designed to facilitate the efficient storage, retrieval, and sharing of simulation data across various applications and platforms</li> <li>ParaView, an open-source tool for large-scale data visualization and analysis across various scientific domains</li> <li>QGIS, a free and open-source geographic information system (GIS) application that allows users to create, edit, visualize, and analyze geospatial data across a variety of formats</li> <li>VTK, a software library for 3D computer graphics, image processing, and visualization</li> <li>VolView, a lightweight application for interactive visualization and analysis of 3D medical imaging data.</li> </ul>"},{"location":"home/customers/#business-and-productivity-software","title":"Business and Productivity Software","text":"<ul> <li>ArcGIS PRO, a desktop geographic information system (GIS) application developed by Esri for mapping and spatial analysis</li> <li>Autodesk Desktop, a software platform developed by Autodesk for creating and managing desktop applications and services</li> <li>Check Point, a cybersecurity company specializing in threat prevention and network security solutions, offering a range of products designed to protect enterprises from cyber threats and ensure data integrity</li> <li>Microsoft Office for Mac, a suite of productivity applications developed by Microsoft for macOS, including tools for word processing, spreadsheets, and presentations</li> <li>Microsoft Teams, a team collaboration application offering workspace chat and video conferencing, file storage, and integration of proprietary and third-party applications and services</li> <li>Nexthink Infinity, a digital employee experience management platform for monitoring and improving IT performance</li> <li>Sophos Connect Client, a secure VPN client from Sophos that allows remote users to connect to their corporate network, ensuring secure access to resources and data</li> <li>Stonebranch, a cloud-based cybersecurity solution that integrates backup, disaster recovery, and cybersecurity features to protect data and ensure business continuity for organizations</li> <li>Tablecruncher, a data analysis tool that allows users to import, analyze, and visualize spreadsheet data, offering interactive features for better insights and decision-making</li> <li>magicplan, a mobile application for creating floor plans and interior designs using augmented reality</li> </ul>"},{"location":"home/customers/#databases-and-big-data","title":"Databases and Big Data","text":"<ul> <li>ADIOS2, a data management framework designed for high-performance input and output operations</li> <li>Cribl Stream, a real-time data processing platform that enables organizations to collect, route, and transform observability data, enhancing visibility and insights into their systems</li> <li>DB Browser for SQLite, a visual open-source tool for creating, designing, and editing SQLite database files</li> <li>MySQL Connector/C++, a C++ library for connecting and interacting with MySQL databases</li> <li>MySQL NDB Cluster, a distributed database system that provides high availability and scalability for MySQL databases</li> <li>MySQL Shell, an advanced client and code editor for interacting with MySQL servers, supporting SQL, Python, and JavaScript</li> <li>PrestoDB, a distributed SQL query engine designed for large-scale data analytics, originally developed by Facebook</li> <li>ROOT Data Analysis Framework, an open-source data analysis framework widely used in high-energy physics and other fields for data processing and visualization</li> <li>WiredTiger, a high-performance storage engine for databases, offering support for compression, concurrency, and checkpointing</li> </ul>"},{"location":"home/customers/#simulation-and-modeling","title":"Simulation and Modeling","text":"<ul> <li>Arcturus HoloSuite, a software toolset for capturing, editing, and streaming volumetric video, featuring advanced compression technologies for high-quality 3D content creation</li> <li>azul, a fast and efficient 3D city model viewer designed for visualizing urban environments and spatial data</li> <li>Blender, a free and open-source 3D creation suite for modeling, animation, rendering, and more</li> <li>cpplot, a library for creating interactive graphs and charts in C++, which can be viewed in web browsers</li> <li>Foundry Nuke, a powerful node-based digital compositing and visual effects application used in film and television post-production</li> <li>GAMS, a high-performance mathematical modeling system for optimization and decision support</li> <li>Kitware SMTK, a software toolkit for managing simulation models and workflows in scientific and engineering applications</li> <li>M-Star, a computational fluid dynamics software for simulating and analyzing fluid flow</li> <li>MapleSim CAD Toolbox, a software extension for MapleSim that integrates CAD models, allowing users to import, manipulate, and analyze 3D CAD data within the MapleSim environment for enhanced modeling and simulation</li> <li>NVIDIA Omniverse, a platform for 3D content creation and collaboration that enables real-time simulations and interactive experiences across various industries</li> <li>Pixar Renderman, a photorealistic 3D rendering software developed by Pixar, widely used in the film industry for creating high-quality visual effects and animations</li> <li>ROS - Robot Operating System, a set of software libraries and tools that assist in developing robot applications</li> <li>UBS, a multinational financial services and banking company</li> </ul>"},{"location":"home/customers/#enterprise-and-cloud-applications","title":"Enterprise and Cloud Applications","text":"<ul> <li>Acronis Cyber Protect Cloud, an all-in-one data protection solution that combines backup, disaster recovery, and cybersecurity to safeguard business data from threats like ransomware</li> <li>Baereos, a backup solution that provides data protection and recovery options for various environments, including physical and virtual systems</li> <li>Bitdefender Home Scanner, a tool from Bitdefender that scans devices for malware and security threats, providing a safeguard against potential online dangers</li> <li>Citrix Provisioning, a solution that streamlines the delivery of virtual desktops and applications by allowing administrators to manage and provision resources efficiently across multiple environments</li> <li>Citrix Virtual Apps and Desktops, a solution from Citrix that delivers virtual apps and desktops</li> <li>Cyberarc, a security solution that specializes in privileged access management, enabling organizations to control and monitor access to critical systems and data, thereby enhancing overall cybersecurity posture</li> <li>Egnyte Desktop, a secure cloud storage solution designed for businesses, enabling file sharing, collaboration, and data management across teams while ensuring compliance and data protection</li> <li>Elster, a digital platform developed by German tax authorities for secure and efficient electronic tax filing and management using secunet protect4use</li> <li>Ethereum Solidity, a high-level, object-oriented programming language designed for implementing smart contracts on the Ethereum platform</li> <li>Inciga, a monitoring tool for IT infrastructure, designed to provide insights into system performance and availability through customizable dashboards and alerts</li> <li>Intel Accelerator Management Daemon for VMware ESXi, a management tool designed for monitoring and controlling Intel hardware accelerators within VMware ESXi environments, optimizing performance and resource allocation</li> <li>Juniper Identity Management Service</li> <li>Microsoft Azure IoT SDK, a collection of tools and libraries to help developers connect, build, and deploy Internet of Things (IoT) solutions on the Azure cloud platform</li> <li>Microsoft WinGet, a command-line utility included in the Windows Package Manager</li> <li>plexusAV, a high-performance AV-over-IP transceiver device capable of video encoding and decoding using the IPMX standard</li> <li>Pointr, a platform for indoor positioning and navigation solutions, offering tools and SDKs for developers to create location-based applications</li> <li>secunet protect4use, a secure, passwordless multifactor authentication solution that transforms smartphones into digital keyrings, ensuring high security for online services and digital identities</li> <li>Sencore MRD 7000, a professional multi-channel receiver and decoder supporting UHD and HD stream decoding</li> </ul>"},{"location":"home/design_goals/","title":"Design goals","text":"<p>There are myriads of JSON libraries out there, and each may even have its reason to exist. Our class had these design goals:</p> <ul> <li> <p>Intuitive syntax. In languages such as Python, JSON feels like a first-class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code.</p> </li> <li> <p>Trivial integration. Our whole code consists of a single header file <code>json.hpp</code>. That's it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings.</p> </li> <li> <p>Serious testing. Our class is heavily unit-tested and covers 100% of the code, including all exceptional behavior. Furthermore, we checked with Valgrind and the Clang Sanitizers that there are no memory leaks. Google OSS-Fuzz additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the Core Infrastructure Initiative (CII) best practices.</p> </li> </ul> <p>Other aspects were not so important to us:</p> <ul> <li> <p>Memory efficiency. Each JSON object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). The default generalization uses the following C++ data types: <code>std::string</code> for strings, <code>int64_t</code>, <code>uint64_t</code> or <code>double</code> for numbers, <code>std::map</code> for objects, <code>std::vector</code> for arrays, and <code>bool</code> for Booleans. However, you can template the generalized class <code>basic_json</code> to your needs.</p> </li> <li> <p>Speed. There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a <code>std::vector</code> or <code>std::map</code>, you are already set.</p> </li> </ul> <p>See the contribution guidelines for more information.</p>"},{"location":"home/exceptions/","title":"Exceptions","text":""},{"location":"home/exceptions/#overview","title":"Overview","text":""},{"location":"home/exceptions/#base-type","title":"Base type","text":"<p>All exceptions inherit from class <code>json::exception</code> (which in turn inherits from <code>std::exception</code>). It is used as the base class for all exceptions thrown by the <code>basic_json</code> class. This class can hence be used as \"wildcard\" to catch exceptions.</p> <pre><code>classDiagram\n  direction LR\n    class `std::exception` {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class `json::exception` {\n        +const int id\n        +const char* what() const\n    }\n\n    class `json::parse_error` {\n        +const std::size_t byte\n    }\n\n    class `json::invalid_iterator`\n    class `json::type_error`\n    class `json::out_of_range`\n    class `json::other_error`\n\n    `std::exception` &lt;|-- `json::exception`\n    `json::exception` &lt;|-- `json::parse_error`\n    `json::exception` &lt;|-- `json::invalid_iterator`\n    `json::exception` &lt;|-- `json::type_error`\n    `json::exception` &lt;|-- `json::out_of_range`\n    `json::exception` &lt;|-- `json::other_error`</code></pre>"},{"location":"home/exceptions/#switch-off-exceptions","title":"Switch off exceptions","text":"<p>Exceptions are used widely within the library. They can, however, be switched off with either using the compiler flag <code>-fno-exceptions</code> or by defining the symbol <code>JSON_NOEXCEPTION</code>. In this case, exceptions are replaced by <code>abort()</code> calls. You can further control this behavior by defining <code>JSON_THROW_USER</code> (overriding <code>throw</code>), <code>JSON_TRY_USER</code> (overriding <code>try</code>), and <code>JSON_CATCH_USER</code> (overriding <code>catch</code>).</p> <p>Note that <code>JSON_THROW_USER</code> should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior.</p> Example <p>The code below switches off exceptions and creates a log entry with a detailed error message in case of errors.</p> <pre><code>#include &lt;iostream&gt;\n\n#define JSON_TRY_USER if(true)\n#define JSON_CATCH_USER(exception) if(false)\n#define JSON_THROW_USER(exception)                           \\\n    {std::clog &lt;&lt; \"Error in \" &lt;&lt; __FILE__ &lt;&lt; \":\" &lt;&lt; __LINE__ \\\n               &lt;&lt; \" (function \" &lt;&lt; __FUNCTION__ &lt;&lt; \") - \"    \\\n               &lt;&lt; (exception).what() &lt;&lt; std::endl;           \\\n     std::abort();}\n\n#include &lt;nlohmann/json.hpp&gt;\n</code></pre> <p>Note the explanatory <code>what()</code> string of exceptions is not available for MSVC if exceptions are disabled, see #2824.</p> <p>See documentation of <code>JSON_TRY_USER</code>, <code>JSON_CATCH_USER</code> and <code>JSON_THROW_USER</code> for more information.</p>"},{"location":"home/exceptions/#extended-diagnostic-messages","title":"Extended diagnostic messages","text":"<p>Exceptions in the library are thrown in the local context of the JSON value they are detected. This makes detailed diagnostics messages, and hence debugging, difficult.</p> Example <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j;\n    j[\"address\"][\"street\"] = \"Fake Street\";\n    j[\"address\"][\"housenumber\"] = \"12\";\n\n    try\n    {\n        int housenumber = j[\"address\"][\"housenumber\"];\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.type_error.302] type must be number, but is string\n</code></pre> <p>This exception can be hard to debug if storing the value <code>\"12\"</code> and accessing it is further apart.</p> <p>To create better diagnostics messages, each JSON value needs a pointer to its parent value such that a global context (i.e., a path from the root value to the value that led to the exception) can be created. That global context is provided as JSON Pointer.</p> <p>As this global context comes at the price of storing one additional pointer per JSON value and runtime overhead to maintain the parent relation, extended diagnostics are disabled by default. They can, however, be enabled by defining the preprocessor symbol <code>JSON_DIAGNOSTICS</code> to <code>1</code> before including <code>json.hpp</code>.</p> Example <pre><code>#include &lt;iostream&gt;\n\n# define JSON_DIAGNOSTICS 1\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    json j;\n    j[\"address\"][\"street\"] = \"Fake Street\";\n    j[\"address\"][\"housenumber\"] = \"12\";\n\n    try\n    {\n        int housenumber = j[\"address\"][\"housenumber\"];\n    }\n    catch (const json::exception&amp; e)\n    {\n        std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>[json.exception.type_error.302] (/address/housenumber) type must be number, but is string\n</code></pre> <p>Now the exception message contains a JSON Pointer <code>/address/housenumber</code> that indicates which value has the wrong type.</p> <p>See documentation of <code>JSON_DIAGNOSTICS</code> for more information.</p>"},{"location":"home/exceptions/#parse-errors","title":"Parse errors","text":"<p>The library throws this exception when a parse error occurs. Parse errors can occur during the deserialization of JSON text, CBOR, MessagePack, as well as when using JSON Patch.</p> <p>Exceptions have ids 1xx.</p> <p>Byte index</p> <p>Member <code>byte</code> holds the byte index of the last read character in the input file.</p> <p>For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack).</p> Example <p>The following code shows how a <code>parse_error</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // parsing input with a syntax error\n        json::parse(\"[1,2,3,]\");\n    }\n    catch (const json::parse_error&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; '\\n'\n                  &lt;&lt; \"byte position of error: \" &lt;&lt; e.byte &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal\nexception id: 101\nbyte position of error: 8\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionparse_error101","title":"json.exception.parse_error.101","text":"<p>This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member <code>byte</code> indicates the error position.</p> <p>Example message</p> <p>Input ended prematurely:</p> <pre><code>[json.exception.parse_error.101] parse error at 2: unexpected end of input; expected string literal\n</code></pre> <p>No input:</p> <pre><code>[json.exception.parse_error.101] parse error at line 1, column 1: attempting to parse an empty input; check that your input string or stream contains the expected JSON\n</code></pre> <p>Control character was not escaped:</p> <pre><code>[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\\\; last read: '\"&lt;U+0009&gt;'\"\n</code></pre> <p>String was not closed:</p> <pre><code>[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: missing closing quote; last read: '\"'\n</code></pre> <p>Invalid number format:</p> <pre><code>[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected '+', '-', or digit after exponent; last read: '1E'\n</code></pre> <p><code>\\u</code> was not be followed by four hex digits:</p> <pre><code>[json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: '\\u' must be followed by 4 hex digits; last read: '\"\\u01\"'\n</code></pre> <p>Invalid UTF-8 surrogate pair:</p> <pre><code>[json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF; last read: '\"\\uD7FF\\uDC00'\"\n</code></pre> <p>Invalid UTF-8 byte:</p> <pre><code>[json.exception.parse_error.101] parse error at line 3, column 24: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"vous \\352t'\n</code></pre> <p>Tip</p> <ul> <li>Make sure the input is correctly read. Try to write the input to standard output to check if, for instance, the input file was successfully opened.</li> <li>Paste the input to a JSON validator like http://jsonlint.com or a tool like jq.</li> </ul>"},{"location":"home/exceptions/#jsonexceptionparse_error102","title":"json.exception.parse_error.102","text":"<p>JSON uses the <code>\\uxxxx</code> format to describe Unicode characters. Code points above 0xFFFF are split into two <code>\\uxxxx</code> entries (\"surrogate pairs\"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.</p> <p>Example message</p> <pre><code>parse error at 14: missing or wrong low surrogate\n</code></pre> <p>Note</p> <p>This exception is not used any more. Instead json.exception.parse_error.101 with a more detailed description is used.</p>"},{"location":"home/exceptions/#jsonexceptionparse_error103","title":"json.exception.parse_error.103","text":"<p>Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.</p> <p>Example message</p> <pre><code>parse error: code points above 0x10FFFF are invalid\n</code></pre> <p>Note</p> <p>This exception is not used any more. Instead json.exception.parse_error.101 with a more detailed description is used.</p>"},{"location":"home/exceptions/#jsonexceptionparse_error104","title":"json.exception.parse_error.104","text":"<p>RFC 6902 requires a JSON Patch document to be a JSON document that represents an array of objects.</p> <p>Example message</p> <pre><code>[json.exception.parse_error.104] parse error: JSON patch must be an array of objects\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionparse_error105","title":"json.exception.parse_error.105","text":"<p>An operation of a JSON Patch document must contain exactly one \"op\" member, whose value indicates the operation to perform. Its value must be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors.</p> <p>Example message</p> <p><pre><code>[json.exception.parse_error.105] parse error: operation 'add' must have member 'value'\n</code></pre> <pre><code>[json.exception.parse_error.105] parse error: operation 'copy' must have string member 'from'\n</code></pre> <pre><code>[json.exception.parse_error.105] parse error: operation value 'foo' is invalid\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptionparse_error106","title":"json.exception.parse_error.106","text":"<p>An array index in a JSON Pointer (RFC 6901) may be <code>0</code> or any number without a leading <code>0</code>.</p> <p>Example message</p> <pre><code>[json.exception.parse_error.106] parse error: array index '01' must not begin with '0'\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionparse_error107","title":"json.exception.parse_error.107","text":"<p>A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a <code>/</code> character.</p> <p>Example message</p> <pre><code>[json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'foo'\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionparse_error108","title":"json.exception.parse_error.108","text":"<p>In a JSON Pointer, only <code>~0</code> and <code>~1</code> are valid escape sequences.</p> <p>Example message</p> <pre><code>[json.exception.parse_error.108] parse error: escape character '~' must be followed with '0' or '1'\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionparse_error109","title":"json.exception.parse_error.109","text":"<p>A JSON Pointer array index must be a number.</p> <p>Example messages</p> <p><pre><code>[json.exception.parse_error.109] parse error: array index 'one' is not a number\n</code></pre> <pre><code>[json.exception.parse_error.109] parse error: array index '+1' is not a number\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptionparse_error110","title":"json.exception.parse_error.110","text":"<p>When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.</p> <p>Example message</p> <p><pre><code>[json.exception.parse_error.110] parse error at byte 5: syntax error while parsing CBOR string: unexpected end of input\n</code></pre> <pre><code>[json.exception.parse_error.110] parse error at byte 2: syntax error while parsing UBJSON value: expected end of input; last byte: 0x5A\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptionparse_error112","title":"json.exception.parse_error.112","text":"<p>An unexpected byte was read in a binary format or length information is invalid (BSON).</p> <p>Example messages</p> <p><pre><code>[json.exception.parse_error.112] parse error at byte 1: syntax error while parsing CBOR value: invalid byte: 0x1C\n</code></pre> <pre><code>[json.exception.parse_error.112] parse error at byte 1: syntax error while parsing MessagePack value: invalid byte: 0xC1\n</code></pre> <pre><code>[json.exception.parse_error.112] parse error at byte 4: syntax error while parsing BJData size: expected '#' after type information; last byte: 0x02\n</code></pre> <pre><code>[json.exception.parse_error.112] parse error at byte 4: syntax error while parsing UBJSON size: expected '#' after type information; last byte: 0x02\n</code></pre> <pre><code>[json.exception.parse_error.112] parse error at byte 10: syntax error while parsing BSON string: string length must be at least 1, is -2147483648\n</code></pre> <pre><code>[json.exception.parse_error.112] parse error at byte 15: syntax error while parsing BSON binary: byte array length cannot be negative, is -1\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptionparse_error113","title":"json.exception.parse_error.113","text":"<p>While parsing a map key, a value that is not a string has been read.</p> <p>Example messages</p> <p><pre><code>[json.exception.parse_error.113] parse error at byte 2: syntax error while parsing CBOR string: expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0xFF\n</code></pre> <pre><code>[json.exception.parse_error.113] parse error at byte 2: syntax error while parsing MessagePack string: expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0xFF\n</code></pre> <pre><code>[json.exception.parse_error.113] parse error at byte 2: syntax error while parsing UBJSON char: byte after 'C' must be in range 0x00..0x7F; last byte: 0x82\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptionparse_error114","title":"json.exception.parse_error.114","text":"<p>The parsing of the corresponding BSON record type is not implemented (yet).</p> <p>Example message</p> <pre><code>[json.exception.parse_error.114] parse error at byte 5: Unsupported BSON record type 0xFF\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionparse_error115","title":"json.exception.parse_error.115","text":"<p>A UBJSON high-precision number could not be parsed.</p> <p>Example message</p> <pre><code>[json.exception.parse_error.115] parse error at byte 5: syntax error while parsing UBJSON high-precision number: invalid number text: 1A\n</code></pre>"},{"location":"home/exceptions/#iterator-errors","title":"Iterator errors","text":"<p>This exception is thrown if iterators passed to a library function do not match the expected semantics.</p> <p>Exceptions have ids 2xx.</p> Example <p>The following code shows how an <code>invalid_iterator</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // calling iterator::key() on non-object iterator\n        json j = \"string\";\n        json::iterator it = j.begin();\n        auto k = it.key();\n    }\n    catch (const json::invalid_iterator&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.invalid_iterator.207] cannot use key() for non-object iterators\nexception id: 207\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator201","title":"json.exception.invalid_iterator.201","text":"<p>The iterators passed to constructor <code>basic_json(InputIT first, InputIT last)</code> are not compatible, meaning they do not belong to the same container. Therefore, the range (<code>first</code>, <code>last</code>) is invalid.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.201] iterators are not compatible\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator202","title":"json.exception.invalid_iterator.202","text":"<p>In the erase or insert function, the passed iterator <code>pos</code> does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.</p> <p>Example messages</p> <p><pre><code>[json.exception.invalid_iterator.202] iterator does not fit current value\n</code></pre> <pre><code>[json.exception.invalid_iterator.202] iterators first and last must point to objects\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator203","title":"json.exception.invalid_iterator.203","text":"<p>Either iterator passed to function <code>erase(IteratorType first, IteratorType last</code>) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.203] iterators do not fit current value\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator204","title":"json.exception.invalid_iterator.204","text":"<p>When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (<code>begin(),</code> <code>end()),</code> because this is the only way the single stored value is expressed. All other ranges are invalid.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.204] iterators out of range\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator205","title":"json.exception.invalid_iterator.205","text":"<p>When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the <code>begin()</code> iterator, because it is the only way to address the stored value. All other iterators are invalid.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.205] iterator out of range\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator206","title":"json.exception.invalid_iterator.206","text":"<p>The iterators passed to constructor <code>basic_json(InputIT first, InputIT last)</code> belong to a JSON null value and hence to not define a valid range.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.206] cannot construct with iterators from null\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator207","title":"json.exception.invalid_iterator.207","text":"<p>The <code>key()</code> member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.207] cannot use key() for non-object iterators\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator208","title":"json.exception.invalid_iterator.208","text":"<p>The <code>operator[]</code> to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.208] cannot use operator[] for object iterators\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator209","title":"json.exception.invalid_iterator.209","text":"<p>The offset operators (<code>+</code>, <code>-</code>, <code>+=</code>, <code>-=</code>) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.209] cannot use offsets with object iterators\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator210","title":"json.exception.invalid_iterator.210","text":"<p>The iterator range passed to the insert function is not compatible, meaning they do not belong to the same container. Therefore, the range (<code>first</code>, <code>last</code>) is invalid.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.210] iterators do not fit\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator211","title":"json.exception.invalid_iterator.211","text":"<p>The iterator range passed to the insert function must not be a subrange of the container to insert to.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.211] passed iterators may not belong to container\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator212","title":"json.exception.invalid_iterator.212","text":"<p>When two iterators are compared, they must belong to the same container.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.212] cannot compare iterators of different containers\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator213","title":"json.exception.invalid_iterator.213","text":"<p>The order of object iterators cannot be compared, because JSON objects are unordered.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.213] cannot compare order of object iterators\n</code></pre>"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator214","title":"json.exception.invalid_iterator.214","text":"<p>Cannot retrieve value from iterator: The iterator either refers to a null value, or it refers to a primitive type (number, boolean, or string), but does not match the iterator returned by <code>begin()</code>.</p> <p>Example message</p> <pre><code>[json.exception.invalid_iterator.214] cannot get value\n</code></pre>"},{"location":"home/exceptions/#type-errors","title":"Type errors","text":"<p>This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics.</p> <p>Exceptions have ids 3xx.</p> Example <p>The following code shows how a <code>type_error</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // calling push_back() on a string value\n        json j = \"string\";\n        j.push_back(\"another string\");\n    }\n    catch (const json::type_error&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.type_error.308] cannot use push_back() with string\nexception id: 308\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error301","title":"json.exception.type_error.301","text":"<p>To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.</p> <p>Example message</p> <pre><code>[json.exception.type_error.301] cannot create object from initializer list\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error302","title":"json.exception.type_error.302","text":"<p>During implicit or explicit value conversion, the JSON type must be compatible with the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.</p> <p>Example messages</p> <p><pre><code>[json.exception.type_error.302] type must be object, but is null\n</code></pre> <pre><code>[json.exception.type_error.302] type must be string, but is object\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptiontype_error303","title":"json.exception.type_error.303","text":"<p>To retrieve a reference to a value stored in a <code>basic_json</code> object with <code>get_ref</code>, the type of the reference must match the value type. For instance, for a JSON array, the <code>ReferenceType</code> must be <code>array_t &amp;</code>.</p> <p>Example messages</p> <p><pre><code>[json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is object\n</code></pre> <pre><code>[json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is number\"\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptiontype_error304","title":"json.exception.type_error.304","text":"<p>The <code>at()</code> member functions can only be executed for certain JSON types.</p> <p>Example messages</p> <p><pre><code>[json.exception.type_error.304] cannot use at() with string\n</code></pre> <pre><code>[json.exception.type_error.304] cannot use at() with number\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptiontype_error305","title":"json.exception.type_error.305","text":"<p>The <code>operator[]</code> member functions can only be executed for certain JSON types.</p> <p>Example messages</p> <p><pre><code>[json.exception.type_error.305] cannot use operator[] with a string argument with array\n</code></pre> <pre><code>[json.exception.type_error.305] cannot use operator[] with a numeric argument with object\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptiontype_error306","title":"json.exception.type_error.306","text":"<p>The <code>value()</code> member functions can only be executed for certain JSON types.</p> <p>Example message</p> <pre><code>[json.exception.type_error.306] cannot use value() with number\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error307","title":"json.exception.type_error.307","text":"<p>The <code>erase()</code> member functions can only be executed for certain JSON types.</p> <p>Example message</p> <pre><code>[json.exception.type_error.307] cannot use erase() with string\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error308","title":"json.exception.type_error.308","text":"<p>The <code>push_back()</code> and <code>operator+=</code> member functions can only be executed for certain JSON types.</p> <p>Example message</p> <pre><code>[json.exception.type_error.308] cannot use push_back() with string\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error309","title":"json.exception.type_error.309","text":"<p>The <code>insert()</code> member functions can only be executed for certain JSON types.</p> <p>Example messages</p> <p><pre><code>[json.exception.type_error.309] cannot use insert() with array\n</code></pre> <pre><code>[json.exception.type_error.309] cannot use insert() with number\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptiontype_error310","title":"json.exception.type_error.310","text":"<p>The <code>swap()</code> member functions can only be executed for certain JSON types.</p> <p>Example message</p> <pre><code>[json.exception.type_error.310] cannot use swap() with number\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error311","title":"json.exception.type_error.311","text":"<p>The <code>emplace()</code> and <code>emplace_back()</code> member functions can only be executed for certain JSON types.</p> <p>Example messages</p> <p><pre><code>[json.exception.type_error.311] cannot use emplace() with number\n</code></pre> <pre><code>[json.exception.type_error.311] cannot use emplace_back() with number\n</code></pre></p>"},{"location":"home/exceptions/#jsonexceptiontype_error312","title":"json.exception.type_error.312","text":"<p>The <code>update()</code> member functions can only be executed for certain JSON types.</p> <p>Example message</p> <pre><code>[json.exception.type_error.312] cannot use update() with array\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error313","title":"json.exception.type_error.313","text":"<p>The <code>unflatten</code> function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well-defined.</p> <p>Example message</p> <pre><code>[json.exception.type_error.313] invalid value to unflatten\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error314","title":"json.exception.type_error.314","text":"<p>The <code>unflatten</code> function only works for an object whose keys are JSON Pointers.</p> <p>Example message</p> <p>Calling <code>unflatten()</code> on an array <code>[1,2,3]</code>:</p> <pre><code>[json.exception.type_error.314] only objects can be unflattened\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error315","title":"json.exception.type_error.315","text":"<p>The <code>unflatten()</code> function only works for an object whose keys are JSON Pointers and whose values are primitive.</p> <p>Example message</p> <p>Calling <code>unflatten()</code> on an object <code>{\"/1\", [1,2,3]}</code>:</p> <pre><code>[json.exception.type_error.315] values in object must be primitive\n</code></pre>"},{"location":"home/exceptions/#jsonexceptiontype_error316","title":"json.exception.type_error.316","text":"<p>The <code>dump()</code> function only works with UTF-8 encoded strings; that is, if you assign a <code>std::string</code> to a JSON value, make sure it is UTF-8 encoded.</p> <p>Example message</p> <p>Calling <code>dump()</code> on a JSON value containing an ISO 8859-1 encoded string: <pre><code>[json.exception.type_error.316] invalid UTF-8 byte at index 15: 0x6F\n</code></pre></p> <p>Tip</p> <ul> <li>Store the source file with UTF-8 encoding.</li> <li>Pass an error handler as last parameter to the <code>dump()</code> function to avoid this exception:<ul> <li><code>json::error_handler_t::replace</code> will replace invalid bytes sequences with <code>U+FFFD</code> </li> <li><code>json::error_handler_t::ignore</code> will silently ignore invalid byte sequences</li> </ul> </li> </ul>"},{"location":"home/exceptions/#jsonexceptiontype_error317","title":"json.exception.type_error.317","text":"<p>The dynamic type of the object cannot be represented in the requested serialization format (e.g., a raw <code>true</code> or <code>null</code> JSON object cannot be serialized to BSON)</p> <p>Example messages</p> <p>Serializing <code>null</code> to BSON: <pre><code>[json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is null\n</code></pre> Serializing <code>[1,2,3]</code> to BSON: <pre><code>[json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is array\n</code></pre></p> <p>Tip</p> <p>Encapsulate the JSON value in an object. That is, instead of serializing <code>true</code>, serialize <code>{\"value\": true}</code></p>"},{"location":"home/exceptions/#out-of-range","title":"Out of range","text":"<p>This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance, in the case of array indices or nonexisting object keys.</p> <p>Exceptions have ids 4xx.</p> Example <p>The following code shows how an <code>out_of_range</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    try\n    {\n        // calling at() for an invalid index\n        json j = {1, 2, 3, 4};\n        j.at(4) = 10;\n    }\n    catch (const json::out_of_range&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.out_of_range.401] array index 4 is out of range\nexception id: 401\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range401","title":"json.exception.out_of_range.401","text":"<p>The provided array index <code>i</code> is larger than <code>size-1</code>.</p> <p>Example message</p> <pre><code>array index 3 is out of range\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range402","title":"json.exception.out_of_range.402","text":"<p>The special array index <code>-</code> in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.</p> <p>Example message</p> <pre><code>array index '-' (3) is out of range\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range403","title":"json.exception.out_of_range.403","text":"<p>The provided key was not found in the JSON object.</p> <p>Example message</p> <pre><code>key 'foo' not found\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range404","title":"json.exception.out_of_range.404","text":"<p>A reference token in a JSON Pointer could not be resolved.</p> <p>Example message</p> <pre><code>unresolved reference token 'foo'\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range405","title":"json.exception.out_of_range.405","text":"<p>The JSON Patch operations 'remove' and 'add' cannot be applied to the root element of the JSON value.</p> <p>Example message</p> <pre><code>JSON pointer has no parent\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range406","title":"json.exception.out_of_range.406","text":"<p>A parsed number could not be stored as without changing it to NaN or INF.</p> <p>Example message</p> <pre><code>number overflow parsing '10E1000'\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range407","title":"json.exception.out_of_range.407","text":"<p>This exception previously indicated that the UBJSON and BSON binary formats did not support integer numbers greater than 9223372036854775807 due to limitations in the implemented mapping. However, these limitations have since been resolved, and this exception no longer occurs.</p> <p>Exception cannot occur any more</p> <ul> <li>Since version 3.9.0, integer numbers beyond int64 are serialized as high-precision UBJSON numbers.</li> <li>Since version 3.12.0, integer numbers beyond int64 are serialized as uint64 BSON numbers.</li> </ul>"},{"location":"home/exceptions/#jsonexceptionout_of_range408","title":"json.exception.out_of_range.408","text":"<p>The size (following <code>#</code>) of an UBJSON array or object exceeds the maximal capacity.</p> <p>Example message</p> <pre><code>excessive array size: 8658170730974374167\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionout_of_range409","title":"json.exception.out_of_range.409","text":"<p>Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string.</p> <p>Example message</p> <pre><code>BSON key cannot contain code point U+0000 (at byte 2)\n</code></pre>"},{"location":"home/exceptions/#further-exceptions","title":"Further exceptions","text":"<p>This exception is thrown in case of errors that cannot be classified with the other exception types.</p> <p>Exceptions have ids 5xx.</p> Example <p>The following code shows how an <code>other_error</code> exception can be caught.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n\nusing json = nlohmann::json;\nusing namespace nlohmann::literals;\n\nint main()\n{\n    try\n    {\n        // executing a failing JSON Patch operation\n        json value = R\"({\n            \"best_biscuit\": {\n                \"name\": \"Oreo\"\n            }\n        })\"_json;\n        json patch = R\"([{\n            \"op\": \"test\",\n            \"path\": \"/best_biscuit/name\",\n            \"value\": \"Choco Leibniz\"\n        }])\"_json;\n        value.patch(patch);\n    }\n    catch (const json::other_error&amp; e)\n    {\n        // output exception information\n        std::cout &lt;&lt; \"message: \" &lt;&lt; e.what() &lt;&lt; '\\n'\n                  &lt;&lt; \"exception id: \" &lt;&lt; e.id &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>message: [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/best_biscuit/name\",\"value\":\"Choco Leibniz\"}\nexception id: 501\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionother_error501","title":"json.exception.other_error.501","text":"<p>A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.</p> <p>Example message</p> <p>Executing <code>{\"op\":\"test\", \"path\":\"/baz\", \"value\":\"bar\"}</code> on <code>{\"baz\": \"qux\"}</code>:</p> <pre><code>[json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/baz\",\"value\":\"bar\"}\n</code></pre>"},{"location":"home/exceptions/#jsonexceptionother_error502","title":"json.exception.other_error.502","text":"<p>This exception is thrown when a null pointer is passed as SAX event listener to the sax_parse function.</p> <p>Example message</p> <pre><code>[json.exception.other_error.502] SAX handler must not be null\n</code></pre>"},{"location":"home/faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"home/faq/#known-bugs","title":"Known bugs","text":""},{"location":"home/faq/#brace-initialization-yields-arrays","title":"Brace initialization yields arrays","text":"<p>Question</p> <p>Why does</p> <pre><code>json j{true};\n</code></pre> <p>and</p> <pre><code>json j(true);\n</code></pre> <p>yield different results (<code>[true]</code> vs. <code>true</code>)?</p> <p>This is a known issue, and -- even worse -- the behavior differs between GCC and Clang. The \"culprit\" for this is the library's constructor overloads for initializer lists to allow syntax like</p> <pre><code>json array = {1, 2, 3, 4};\n</code></pre> <p>for arrays and</p> <pre><code>json object = {{\"one\", 1}, {\"two\", 2}}; \n</code></pre> <p>for objects.</p> <p>Tip</p> <p>To avoid any confusion and ensure portable code, do not use brace initialization with the types <code>basic_json</code>, <code>json</code>, or <code>ordered_json</code> unless you want to create an object or array as shown in the examples above.</p>"},{"location":"home/faq/#limitations","title":"Limitations","text":""},{"location":"home/faq/#relaxed-parsing","title":"Relaxed parsing","text":"<p>Question</p> <p>Can you add an option to ignore trailing commas?</p> <p>This library does not support any feature that would jeopardize interoperability.</p>"},{"location":"home/faq/#parse-errors-reading-non-ascii-characters","title":"Parse errors reading non-ASCII characters","text":"<p>Questions</p> <ul> <li>Why is the parser complaining about a Chinese character?</li> <li>Does the library support Unicode?</li> <li>I get an exception <code>[json.exception.parse_error.101] parse error at line 1, column 53: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"Test\u00e9$')\"</code></li> </ul> <p>The library supports Unicode input as follows:</p> <ul> <li>Only UTF-8 encoded input is supported, which is the default encoding for JSON, according to RFC 8259.</li> <li><code>std::u16string</code> and <code>std::u32string</code> can be parsed, assuming UTF-16 and UTF-32 encoding, respectively. These encodings are not supported when reading from files or other input containers.</li> <li>Other encodings such as Latin-1 or ISO 8859-1 are not supported and will yield parse or serialization errors.</li> <li>The library will not replace Unicode noncharacters.</li> <li>Invalid surrogates (e.g., incomplete pairs such as <code>\\uDEAD</code>) will yield parse errors.</li> <li>The strings stored in the library are UTF-8 encoded. When using the default string type (<code>std::string</code>), note that its length/size functions return the number of stored bytes rather than the number of characters or glyphs.</li> <li>When you store strings with different encodings in the library, calling <code>dump()</code> may throw an exception unless <code>json::error_handler_t::replace</code> or <code>json::error_handler_t::ignore</code> are used as error handlers.</li> </ul> <p>In most cases, the parser is right to complain, because the input is not UTF-8 encoded. This is especially true for Microsoft Windows, where Latin-1 or ISO 8859-1 is often the standard encoding.</p>"},{"location":"home/faq/#wide-string-handling","title":"Wide string handling","text":"<p>Question</p> <p>Why are wide strings (e.g., <code>std::wstring</code>) dumped as arrays of numbers?</p> <p>As described above, the library assumes UTF-8 as encoding.  To store a wide string, you need to change the encoding.</p> <p>Example</p> <pre><code>#include &lt;codecvt&gt; // codecvt_utf8\n#include &lt;locale&gt;  // wstring_convert\n\n// encoding function\nstd::string to_utf8(std::wstring&amp; wide_string)\n{\n    static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; utf8_conv;\n    return utf8_conv.to_bytes(wide_string);\n}\n\njson j;\nstd::wstring ws = L\"\u8ecaB1234 \u3053\u3093\u306b\u3061\u306f\";\n\nj[\"original\"] = ws;\nj[\"encoded\"] = to_utf8(ws);\n\nstd::cout &lt;&lt; j &lt;&lt; std::endl;\n</code></pre> <p>The result is:</p> <pre><code>{\n  \"encoded\": \"\u8ecaB1234 \u3053\u3093\u306b\u3061\u306f\",\n  \"original\": [36554, 66, 49, 50, 51, 52, 32, 12371, 12435, 12395, 12385, 12399]\n}\n</code></pre>"},{"location":"home/faq/#exceptions","title":"Exceptions","text":""},{"location":"home/faq/#parsing-without-exceptions","title":"Parsing without exceptions","text":"<p>Question</p> <p>Is it possible to indicate a parse error without throwing an exception?</p> <p>Yes, see Parsing and exceptions.</p>"},{"location":"home/faq/#key-name-in-exceptions","title":"Key name in exceptions","text":"<p>Question</p> <p>Can I get the key of the object item that caused an exception?</p> <p>Yes, you can. Please define the symbol <code>JSON_DIAGNOSTICS</code> to get extended diagnostics messages.</p>"},{"location":"home/faq/#serialization-issues","title":"Serialization issues","text":""},{"location":"home/faq/#number-precision","title":"Number precision","text":"<p>Question</p> <ul> <li>It seems that precision is lost when serializing a double.</li> <li>Can I change the precision for floating-point serialization?</li> </ul> <p>The library uses <code>std::numeric_limits&lt;number_float_t&gt;::digits10</code> (15 for IEEE <code>double</code>s) digits for serialization. This value is sufficient to guarantee roundtripping. If one uses more than this number of digits of precision, then string -&gt; value -&gt; string is not guaranteed to round-trip.</p> <p>cppreference.com</p> <p>The value of <code>std::numeric_limits&lt;T&gt;::digits10</code> is the number of base-10 digits that can be represented by the type T without change, that is, any number with this many significant decimal digits can be converted to a value of type T and back to decimal form, without change due to rounding or overflow. </p> <p>Tip</p> <p>The website https://float.exposed gives a good insight into the internal storage of floating-point numbers.</p> <p>See this section on the library's number handling for more information.</p>"},{"location":"home/faq/#compilation-issues","title":"Compilation issues","text":""},{"location":"home/faq/#android-sdk","title":"Android SDK","text":"<p>Question</p> <p>Why does the code not compile with Android SDK?</p> <p>Android defaults to using very old compilers and C++ libraries. To fix this, add the following to your <code>Application.mk</code>. This will switch to the LLVM C++ library, the Clang compiler, and enable C++11 and other features disabled by default.</p> <pre><code>APP_STL := c++_shared\nNDK_TOOLCHAIN_VERSION := clang3.6\nAPP_CPPFLAGS += -frtti -fexceptions\n</code></pre> <p>The code compiles successfully with Android NDK, Revision 9 - 11 (and possibly later) and CrystaX's Android NDK version 10.</p>"},{"location":"home/faq/#missing-stl-function","title":"Missing STL function","text":"<p>Questions</p> <ul> <li>Why do I get a compilation error <code>'to_string' is not a member of 'std'</code> (or similarly, for <code>strtod</code> or <code>strtof</code>)?</li> <li>Why does the code not compile with MinGW or Android SDK?</li> </ul> <p>This is not an issue with the code, but rather with the compiler itself. On Android, see above to build with a newer environment.  For MinGW, please refer to this site and this discussion for information on how to fix this bug. For Android NDK using <code>APP_STL := gnustl_static</code>, please refer to this discussion.</p>"},{"location":"home/license/","title":"License","text":"<p>The class is licensed under the MIT License:</p> <p>Copyright \u00a9 2013-2025 Niels Lohmann</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>The class contains the UTF-8 Decoder from Bjoern Hoehrmann which is licensed under the MIT License (see above). Copyright \u00a9 2008-2009 Bj\u00f6rn Hoehrmann bjoern@hoehrmann.de</p> <p>The class contains a slightly modified version of the Grisu2 algorithm from Florian Loitsch which is licensed under the MIT License (see above). Copyright \u00a9 2009 Florian Loitsch</p> <p>The class contains a copy of Hedley from Evan Nemerson which is licensed as CC0-1.0.</p>"},{"location":"home/releases/","title":"Releases","text":""},{"location":"home/releases/#v373","title":"v3.7.3","text":"<p>Files</p> <ul> <li>include.zip (274 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (791 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2019-11-17 SHA-256: 3b5d2b8f8282b80557091514d8ab97e27f9574336c804ee666fda673a9b59926 (json.hpp), 87b5884741427220d3a33df1363ae0e8b898099fbc59f1c451113f6732891014 (include.zip)</p>"},{"location":"home/releases/#summary","title":"Summary","text":"<p>This release fixes a bug introduced in release 3.7.2 which could yield quadratic complexity in destructor calls. All changes are backward-compatible.</p>"},{"location":"home/releases/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Removed <code>reserve()</code> calls from the destructor which could lead to quadratic complexity. #1837 #1838</li> </ul>"},{"location":"home/releases/#deprecated-functions","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v372","title":"v3.7.2","text":"<p>Files</p> <ul> <li>include.zip (274 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (791 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2019-11-10 SHA-256: 0a65fcbbe1b334d3f45c9498e5ee28c3f3b2428aea98557da4a3ff12f0f14ad6 (json.hpp), 67f69c9a93b7fa0612dc1b6273119d2c560317333581845f358aaa68bff8f087 (include.zip)</p>"},{"location":"home/releases/#summary_1","title":"Summary","text":"<p>Project bad_json_parsers tested how JSON parser libraries react on deeply nested inputs. It turns out that this library segfaulted at a certain nesting depth. This bug was fixed with this release. Now the parsing is only bounded by the available memory. All changes are backward-compatible.</p>"},{"location":"home/releases/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fixed a bug that lead to stack overflow for deeply nested JSON values (objects, array) by changing the implementation of the destructor from a recursive to an iterative approach. #832, #1419, #1835</li> </ul>"},{"location":"home/releases/#further-changes","title":"Further Changes","text":"<ul> <li>Added WhiteStone Bolt. #1830</li> </ul>"},{"location":"home/releases/#deprecated-functions_1","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v371","title":"v3.7.1","text":"<p>Files</p> <ul> <li>include.zip (273 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (789 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2019-11-06 SHA-256: b5ba7228f3c22a882d379e93d08eab4349458ee16fbf45291347994eac7dc7ce (json.hpp), 77b9f54b34e7989e6f402afb516f7ff2830df551c3a36973085e2c7a6b1045fe (include.zip)</p>"},{"location":"home/releases/#summary_2","title":"Summary","text":"<p>This release fixes several small bugs in the library. All changes are backward-compatible.</p>"},{"location":"home/releases/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Fixed a segmentation fault when serializing <code>std::int64_t</code> minimum value. #1708 #1722</li> <li>Fixed the <code>contains()</code> function for JSON Pointers. #1727 #1741</li> <li>Fixed too lax SFINAE guard for conversion from <code>std::pair</code> and <code>std::tuple</code> to <code>json</code>. #1805 #1806 #1825 #1826</li> <li>Fixed some regressions detected by UBSAN. Updated CI to use Clang-Tidy 7.1.0. #1716 #1728</li> <li>Fixed integer truncation in <code>iteration_proxy</code>. #1797</li> <li>Updated Hedley to v11 to fix a E2512 error in MSVC. #1799</li> <li>Fixed a compile error in enum deserialization of non non-default-constructible types. #1647 #1821</li> <li>Fixed the conversion from <code>json</code> to <code>std::valarray</code>.</li> </ul>"},{"location":"home/releases/#improvements","title":"Improvements","text":"<ul> <li>The <code>items()</code> function can now be used with a custom string type. #1765</li> <li>Made <code>json_pointer::back</code> <code>const</code>. #1764 #1769</li> <li>Meson is part of the release archive. #1672 #1694 </li> <li>Improved documentation on the Meson and Spack package manager. #1694 #1720</li> </ul>"},{"location":"home/releases/#further-changes_1","title":"Further Changes","text":"<ul> <li>Added GitHub Workflow with <code>ubuntu-latest</code>/GCC 7.4.0 as CI step.</li> <li>Added GCC 9 to Travis CI to compile with C++20 support. #1724</li> <li>Added MSVC 2019 to the AppVeyor CI. #1780</li> <li>Added badge to fuzzing status.</li> <li>Fixed some cppcheck warnings. #1760</li> <li>Fixed several typos in the documentation. #1720 #1767 #1803</li> <li>Added documentation on the <code>JSON_THROW_USER</code>, <code>JSON_TRY_USER</code>, and <code>JSON_CATCH_USER</code> macros to control user-defined exception handling.</li> <li>Used GitHub's CODEOWNERS and SECURITY feature.</li> <li>Removed <code>GLOB</code> from CMake files. #1779</li> <li>Updated to Doctest 2.3.5.</li> </ul>"},{"location":"home/releases/#deprecated-functions_2","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v370","title":"v3.7.0","text":"<p>Files</p> <ul> <li>include.zip (143 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (782 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2019-07-28 SHA-256: a503214947952b69f0062f572cb74c17582a495767446347ce2e452963fc2ca4 (json.hpp), 541c34438fd54182e9cdc68dd20c898d766713ad6d901fb2c6e28ff1f1e7c10d (include.zip)</p>"},{"location":"home/releases/#summary_3","title":"Summary","text":"<p>This release introduces a few convenience functions and performs a lot of house keeping (bug fixes and small improvements). All changes are backward-compatible.</p>"},{"location":"home/releases/#new-features","title":"New Features","text":"<ul> <li>Add overload of the <code>contains</code> function to check if a JSON pointer is valid without throwing exceptions, just like its counterpart for object keys. #1600</li> <li>Add a function <code>to_string</code> to allow for generic conversion to strings. #916 #1585</li> <li>Add return value for the <code>emplace_back</code> function, returning a reference to the added element just like C++17 is introducing this for <code>std::vector</code>. #1609</li> <li>Add info how to use the library with the pacman package manager on MSYS2. #1670</li> </ul>"},{"location":"home/releases/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Fix an issue where typedefs with certain names yielded a compilation error. #1642 #1643</li> <li>Fix a conversion to <code>std::string_view</code> in the unit tests. #1634 #1639</li> <li>Fix MSVC Debug build. #1536 #1570 #1608</li> <li>Fix <code>get_to</code> method to clear existing content before writing. #1511 #1555</li> <li>Fix a <code>-Wc++17-extensions</code> warning. <code>nodiscard</code> attributes are now only used with Clang when <code>-std=c++17</code> is used. #1535 #1551</li> </ul>"},{"location":"home/releases/#improvements_1","title":"Improvements","text":"<ul> <li>Switch from Catch to doctest for the unit tests which speeds up compilation and runtime of the 112,112,308 tests.</li> <li>Add an explicit section to the README about the frequently addressed topics character encoding, comments in JSON, and the order of object keys.</li> </ul>"},{"location":"home/releases/#further-changes_2","title":"Further Changes","text":"<ul> <li>Use <code>GNUInstallDirs</code> to set library install directories. #1673</li> <li>Fix links in the README. #1620 #1621 #1622 #1623 #1625</li> <li>Mention <code>json</code> type on the documentation start page. #1616</li> <li>Complete documentation of <code>value()</code> function with respect to <code>type_error.302</code> exception. #1601</li> <li>Fix links in the documentation. #1598</li> <li>Add regression tests for MSVC. #1543 #1570</li> <li>Use CircleCI for continuous integration.</li> <li>Use Doozer for continuous integration on Linux (CentOS, Raspbian, Fedora)</li> <li>Add tests to check each CMake flag (<code>JSON_BuildTests</code>, <code>JSON_Install</code>, <code>JSON_MultipleHeaders</code>, <code>JSON_Sanitizer</code>, <code>JSON_Valgrind</code>, <code>JSON_NoExceptions</code>, <code>JSON_Coverage</code>).</li> <li>Use Hedley to avoid re-inventing several compiler-agnostic feature macros like <code>JSON_DEPRECATED</code>, <code>JSON_NODISCARD</code>, <code>JSON_LIKELY</code>, <code>JSON_UNLIKELY</code>, <code>JSON_HAS_CPP_14</code>, or <code>JSON_HAS_CPP_17</code>. Functions taking or returning pointers are annotated accordingly when a pointer will not be null.</li> <li>Build and run tests on AppVeyor in DEBUG and RELEASE mode.</li> </ul>"},{"location":"home/releases/#deprecated-functions_3","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v361","title":"v3.6.1","text":"<p>Files</p> <ul> <li>include.zip (136 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (711 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2019-03-20 SHA-256: d2eeb25d2e95bffeb08ebb7704cdffd2e8fca7113eba9a0b38d60a5c391ea09a (json.hpp), 69cc88207ce91347ea530b227ff0776db82dcb8de6704e1a3d74f4841bc651cf (include.zip)</p>"},{"location":"home/releases/#summary_4","title":"Summary","text":"<p>This release fixes a regression and a bug introduced by the earlier 3.6.0 release. All changes are backward-compatible.</p>"},{"location":"home/releases/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Fixed regression of #590 which could lead to compilation errors with GCC 7 and GCC 8. #1530</li> <li>Fixed a compilation error when <code>&lt;Windows.h&gt;</code> was included. #1531</li> </ul>"},{"location":"home/releases/#further-changes_3","title":"Further Changes","text":"<ul> <li>Fixed a warning for missing field initializers. #1527</li> </ul>"},{"location":"home/releases/#deprecated-functions_4","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v360","title":"v3.6.0","text":"<p>Files</p> <ul> <li>include.zip (136 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (711 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2019-03-20 SHA-256: ce9839370f28094c71107c405affb3b08c4a098154988014cbb0800b1c44a831 (json.hpp), 237c5e66e7f8186a02804ce9dbd5f69ce89fe7424ef84adf6142e973bd9532f4 (include.zip)</p> <p>\u2139\ufe0f This release introduced a regression. Please update to version 3.6.1!</p>"},{"location":"home/releases/#summary_5","title":"Summary","text":"<p>This release adds some convenience functions for JSON Pointers, introduces a <code>contains</code> function to check if a key is present in an object, and improves the performance of integer serialization. Furthermore, a lot of small bug fixes and improvements have been made. All changes are backward-compatible.</p>"},{"location":"home/releases/#new-features_1","title":"New Features","text":"<ul> <li>Overworked the public interface for JSON Pointers. The creation of JSON Pointers is simplified with <code>operator/</code> and <code>operator/=</code>. JSON Pointers can be inspected with <code>empty</code>, <code>back</code>,  and <code>parent_pointer</code>, and manipulated with <code>push_back</code> and <code>pop_back</code>. #1434</li> <li>Added a boolean method <code>contains</code> to check whether an element exists in a JSON object with a given key. Returns false when called on non-object types. #1471 #1474</li> </ul>"},{"location":"home/releases/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Fixed a compilation issues with libc 2.12. #1483 #1514</li> <li>Fixed endian conversion on PPC64. #1489</li> <li>Fixed library to compile with GCC 9. #1472 #1492</li> <li>Fixed a compilation issue with GCC 7 on CentOS. #1496</li> <li>Fixed an integer overflow. #1447</li> <li>Fixed buffer flushing in serializer. #1445 #1446</li> </ul>"},{"location":"home/releases/#improvements_2","title":"Improvements","text":"<ul> <li>The performance of dumping integers has been greatly improved. #1411</li> <li>Added CMake parameter <code>JSON_Install</code> to control whether the library should be installed (default: on). #1330</li> <li>Fixed a lot of compiler and linter warnings. #1400 #1435 #1502</li> <li>Reduced required CMake version from 3.8 to 3.1. #1409 #1428 #1441 #1498</li> <li>Added <code>nodiscard</code> attribute to <code>meta()</code>, <code>array()</code>, <code>object()</code>, <code>from_cbor</code>, <code>from_msgpack</code>, <code>from_ubjson</code>, <code>from_bson</code>, and <code>parse</code>. #1433</li> </ul>"},{"location":"home/releases/#further-changes_4","title":"Further Changes","text":"<ul> <li>Added missing headers. #1500</li> <li>Fixed typos and broken links in README. #1417 #1423 #1425 #1451 #1455 #1491</li> <li>Fixed documentation of parse function. #1473</li> <li>Suppressed warning that cannot be fixed inside the library. #1401 #1468</li> <li>Improved package manager suppert:<ul> <li>Updated Buckaroo instructions. #1495</li> <li>Improved Meson support. #1463</li> <li>Added Conda package manager documentation. #1430</li> <li>Added NuGet package manager documentation. #1132</li> </ul> </li> <li>Continuous Integration<ul> <li>Removed unstable or deprecated Travis builders (Xcode 6.4 - 8.2) and added Xcode 10.1 builder.</li> <li>Added Clang 7 to Travis CI.</li> <li>Fixed AppVeyor x64 builds. #1374 #1414</li> </ul> </li> <li>Updated thirdparty libraries:<ul> <li>Catch 1.12.0 -&gt; 1.12.2</li> <li>Google Benchmark 1.3.0 -&gt; 1.4.1</li> <li>Doxygen 1.8.15 -&gt; 1.8.16</li> </ul> </li> </ul>"},{"location":"home/releases/#deprecated-functions_5","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v350","title":"v3.5.0","text":"<p>Files</p> <ul> <li>include.zip (133 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (693 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2018-12-22 SHA-256: 8a6dbf3bf01156f438d0ca7e78c2971bca50eec4ca6f0cf59adf3464c43bb9d5 (json.hpp), 3564da9c5b0cf2e032f97c69baedf10ddbc98030c337d0327a215ea72259ea21 (include.zip)</p>"},{"location":"home/releases/#summary_6","title":"Summary","text":"<p>This release introduces the support for structured bindings and reading from <code>FILE*</code>. Besides, a few bugs have been fixed. All changes are backward-compatible.</p>"},{"location":"home/releases/#new-features_2","title":"New Features","text":"<ul> <li> <p>Structured bindings are now supported for JSON objects and arrays via the <code>items()</code> member function, so finally this code is possible:   <pre><code>for (auto&amp; [key, val] : j.items()) {\n    std::cout &lt;&lt; key &lt;&lt; ':' &lt;&lt; val &lt;&lt; '\\n';\n}\n</code></pre>   #1388 #1391</p> </li> <li> <p>Added support for reading from <code>FILE*</code> to support situations in which streams are nit available or would require too much RAM. #1370 #1392</p> </li> </ul>"},{"location":"home/releases/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>The <code>eofbit</code> was not set for input streams when the end of a stream was reached while parsing. #1340 #1343</li> <li>Fixed a bug in the SAX parser for BSON arrays.</li> </ul>"},{"location":"home/releases/#improvements_3","title":"Improvements","text":"<ul> <li>Added support for Clang 5.0.1 (PS4 version). #1341 #1342</li> </ul>"},{"location":"home/releases/#further-changes_5","title":"Further Changes","text":"<ul> <li>Added a warning for implicit conversions to the documentation: It is not recommended to use implicit conversions when reading from a JSON value. Details about this recommendation can be found here.  #1363</li> <li>Fixed typos in the documentation. #1329 #1380 #1382</li> <li>Fixed a C4800 warning. #1364</li> <li>Fixed a <code>-Wshadow</code> warning #1346</li> <li>Wrapped <code>std::snprintf</code> calls to avoid error in MSVC. #1337</li> <li>Added code to allow installation via Meson. #1345</li> </ul>"},{"location":"home/releases/#deprecated-functions_6","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v340","title":"v3.4.0","text":"<p>Files</p> <ul> <li>include.zip (132 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (689 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2018-10-30 SHA-256: 63da6d1f22b2a7bb9e4ff7d6b255cf691a161ff49532dcc45d398a53e295835f (json.hpp), bfec46fc0cee01c509cf064d2254517e7fa80d1e7647fea37cf81d97c5682bdc (include.zip)</p>"},{"location":"home/releases/#summary_7","title":"Summary","text":"<p>This release introduces three new features:</p> <ul> <li>BSON (Binary JSON) is next to CBOR, MessagePack, and UBJSON the fourth binary (de)serialization format supported by the library.</li> <li>Adjustable error handlers for invalid Unicode allows to specify the behavior when invalid byte sequences are serialized.</li> <li>Simplified enum/JSON mapping with a macro in case the default mapping to integers is not desired.</li> </ul> <p>Furthermore, some effort has been invested in improving the parse error messages. Besides, a few bugs have been fixed. All changes are backward-compatible.</p>"},{"location":"home/releases/#new-features_3","title":"New Features","text":"<ul> <li>The library can read and write a subset of BSON (Binary JSON). All data types known from JSON are supported, whereas other types more tied to MongoDB such as timestamps, object ids, or binary data are currently not implemented. See the README for examples. #1244 #1320</li> <li>The behavior when the library encounters an invalid Unicode sequence during serialization can now be controlled by defining one of three Unicode error handlers: (1) throw an exception (default behavior), (2) replace invalid sequences by the Unicode replacement character (U+FFFD), or (3) ignore/filter invalid sequences. See the documentation of the <code>dump</code> function for examples. #1198 #1314</li> <li>To easily specify a user-defined enum/JSON mapping, a macro <code>NLOHMANN_JSON_SERIALIZE_ENUM</code> has been introduced. See the README section for more information. #1208 #1323</li> </ul>"},{"location":"home/releases/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>fixed truncation #1286 #1315</li> <li>fixed an issue with std::pair #1299 #1301</li> <li>fixed an issue with std::variant #1292 #1294</li> <li>fixed a bug in the JSON Pointer parser</li> </ul>"},{"location":"home/releases/#improvements_4","title":"Improvements","text":"<ul> <li>The diagnosis messages for parse errors have been improved: error messages now indicated line/column positions where possible (in addition to a byte count) and also the context in which the error occurred (e.g., \"while parsing a JSON string\"). Example: error <code>parse error at 2: syntax error - invalid string: control character must be escaped; last read: '&lt;U+0009&gt;'</code> is now reported as <code>parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t; last read: '&lt;U+0009&gt;'</code>. #1280 #1288 #1303</li> </ul>"},{"location":"home/releases/#further-changes_6","title":"Further Changes","text":"<ul> <li>improved Meson documentation #1305</li> <li>fixed some more linter warnings #1280</li> <li>fixed Clang detection for third-party Google Benchmark library #1277</li> </ul>"},{"location":"home/releases/#deprecated-functions_7","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v330","title":"v3.3.0","text":"<p>Files</p> <ul> <li>include.zip (123 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (635 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2018-10-05 SHA-256: f1327bb60c58757a3dd2b0c9c45d49503d571337681d950ec621f8374bcc14d4 (json.hpp), 9588d63557333aaa485e92221ec38014a85a6134e7486fe3441e0541a5a89576 (include.zip)</p>"},{"location":"home/releases/#summary_8","title":"Summary","text":"<p>This release adds support for GCC 4.8. Furthermore, it adds a function <code>get_to</code> to write a JSON value to a passed reference. Another topic of this release was the CMake support which has been overworked and documented.</p> <p>Besides, a lot of bugs have been fixed and slight improvements have been made. All changes are backward-compatible.</p>"},{"location":"home/releases/#new-features_4","title":"New Features","text":"<ul> <li>The library can now also built with GCC 4.8. Though this compiler does not fully support C++11, it can successfully compile and run the test suite. Note that bug 57824 in GCC 4.8 still forbids to use multiline raw strings in arguments to macros. #1257</li> <li>Added new function <code>get_to</code> to write a JSON value to a passed reference. The destination type is automatically derived which allows more succinct code compared to the <code>get</code> function. #1227 #1231</li> </ul>"},{"location":"home/releases/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Fixed a bug in the CMake file that made <code>target_link_libraries</code> to not properly include <code>nlohmann_json</code>. #1243 #1245 #1260</li> <li>Fixed a warning in MSVC 2017 complaining about a constexpr if. #1204 #1268 #1272</li> <li>Fixed a bug that prevented compilation with ICPC. #755 #1222</li> <li>Improved the SFINAE correctness to fix a bug in the conversion operator. #1237 #1238</li> <li>Fixed a <code>-Wctor-dtor-privacy</code> warning. #1224</li> <li>Fixed a warning on a lambda in unevaluated context. #1225 #1230</li> <li>Fixed a bug introduced in version 3.2.0 where defining <code>JSON_CATCH_USER</code> led to duplicate macro definition of <code>JSON_INTERNAL_CATCH</code>. #1213 #1214</li> <li>Fixed a bug that prevented compilation with Clang 3.4.2 in RHEL 7. #1179 #1249</li> </ul>"},{"location":"home/releases/#improvements_5","title":"Improvements","text":"<ul> <li>Added documentation on CMake integration of the library. #1270</li> <li>Changed the CMake file to use <code>find_package(nlohmann_json)</code> without installing the library. #1202</li> <li>Improved error messages in case <code>operator[]</code> is used with the wrong combination (json.exception.type_error.305) of JSON container type and argument type. Example: \"cannot use operator[] with a string argument\". #1220 #1221</li> <li>Added a license and version information to the Meson build file. #1252</li> <li>Removed static assertions to indicated missing <code>to_json</code> or <code>from_json</code> functions as such assertions do not play well with SFINAE. These assertions also led to problems with GMock. #960 #1212 #1228</li> <li>The test suite now does not wait forever if run in a wrong directory and input files are not found. #1262</li> <li>The test suite does not show deprecation warnings for deprecated functions which frequently led to confusion. #1271</li> </ul>"},{"location":"home/releases/#further-changes_7","title":"Further Changes","text":"<ul> <li>GCC 4.8 and Xcode 10 were added to the continuous integration suite at Travis.</li> <li>Added lgtm checks to pull requests.</li> <li>Added tests for CMake integration. #1260</li> </ul>"},{"location":"home/releases/#deprecated-functions_8","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v320","title":"v3.2.0","text":"<p>Files</p> <ul> <li>include.zip (124 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (636 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2018-08-20 SHA-256: ce6b5610a051ec6795fa11c33854abebb086f0fd67c311f5921c3c07f9531b44 (json.hpp), 35ee642558b90e2f9bc758995c4788c4b4d4dec54eef95fb8f38cb4d49c8fc7c (include.zip)</p>"},{"location":"home/releases/#summary_9","title":"Summary","text":"<p>This release introduces a SAX interface to the library. While this may be a very special feature used by only few people, it allowed to unify all functions that consumed input and created some kind of JSON value. Internally, now all existing functions like <code>parse</code>, <code>accept</code>, <code>from_cbor</code>, <code>from_msgpack</code>, and <code>from_ubjson</code> use the SAX interface with different event processors. This allowed to separate the input processing from the value generation. Furthermore, throwing an exception in case of a parse error is now optional and up to the event processor. Finally, the JSON parser is now non-recursive (meaning it does not use the call stack, but <code>std::vector&lt;bool&gt;</code> to track the hierarchy of structured values) which allows to process nested input more efficiently.</p> <p>Furthermore, the library finally is able to parse from wide string types. This is the first step toward opening the library from UTF-8 to UTF-16 and UTF-32.</p> <p>This release further fixes several bugs in the library. All changes are backward-compatible.</p>"},{"location":"home/releases/#new-features_5","title":"New Features","text":"<ul> <li>added a parser with a SAX interface (#971, #1153)</li> <li>support to parse from wide string types <code>std::wstring</code>, <code>std::u16string</code>, and <code>std::u32string</code>; the input will be converted to UTF-8 (#1031)</li> <li>added support for <code>std::string_view</code> when using C++17 (#1028)</li> <li>allow to roundtrip <code>std::map</code> and <code>std::unordered_map</code> from JSON if key type is not convertible to string; in these cases, values are serialized to arrays of pairs (#1079, #1089, #1133, #1138)</li> </ul>"},{"location":"home/releases/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>allow to create <code>nullptr_t</code> from JSON allowing to properly roundtrip <code>null</code> values (#1169)</li> <li>allow compare user-defined string types (#1130)</li> <li>better support for algorithms using iterators from <code>items()</code> (#1045, #1134)</li> <li>added parameter to avoid compilation error with MSVC 2015 debug builds (#1114)</li> <li>re-added accidentally skipped unit tests (#1176)</li> <li>fixed MSVC issue with <code>std::swap</code> (#1168)</li> </ul>"},{"location":"home/releases/#improvements_6","title":"Improvements","text":"<ul> <li><code>key()</code> function for iterators returns a const reference rather than a string copy (#1098)</li> <li>binary formats CBOR, MessagePack, and UBJSON now supports <code>float</code> as type for floating-point numbers (#1021)</li> </ul>"},{"location":"home/releases/#further-changes_8","title":"Further Changes","text":"<ul> <li>changed issue templates</li> <li>improved continuous integration: added builders for Xcode 9.3 and 9.4, added builders for GCC 8 and Clang 6, added builder for MinGW, added builders for MSVC targeting x86</li> <li>required CMake version is now at least 3.8 (#1040)</li> <li>overworked CMake file wrt. packaging (#1048)</li> <li>added package managers: Spack (#1041) and CocoaPods (#1148)</li> <li>fixed Meson include directory (#1142)</li> <li>preprocessor macro <code>JSON_SKIP_UNSUPPORTED_COMPILER_CHECK</code> can skip the rejection of unsupported compilers - use at your own risk! (#1128)</li> <li>preprocessor macro <code>JSON_INTERNAL_CATCH</code>/<code>JSON_INTERNAL_CATCH_USER</code> allows to control the behavior of exception handling inside the library (#1187)</li> <li>added note on <code>char</code> to JSON conversion</li> <li>added note how to send security-related issue via encrypted email</li> <li>removed dependency to <code>std::stringstream</code> (#1117)</li> <li>added SPDX-License-Identifier</li> <li>added updated JSON Parsing Test Suite, described in Parsing JSON is a Minefield \ud83d\udca3</li> <li>updated to Catch 1.12.0</li> </ul>"},{"location":"home/releases/#deprecated-functions_9","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v312","title":"v3.1.2","text":"<p>Files</p> <ul> <li>include.zip (115 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (582 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2018-03-14 SHA-256: fbdfec4b4cf63b3b565d09f87e6c3c183bdd45c5be1864d3fcb338f6f02c1733 (json.hpp), 495362ee1b9d03d9526ba9ccf1b4a9c37691abe3a642ddbced13e5778c16660c (include.zip)</p>"},{"location":"home/releases/#summary_10","title":"Summary","text":"<p>This release fixes several bugs in the library. All changes are backward-compatible.</p>"},{"location":"home/releases/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>Fixed a memory leak occurring in the parser callback (#1001).</li> <li>Different specializations of <code>basic_json</code> (e.g., using different template arguments for strings or objects) can now be used in assignments (#972, #977, #986).</li> <li>Fixed a logical error in an iterator range check (#992).</li> </ul>"},{"location":"home/releases/#improvements_7","title":"Improvements","text":"<ul> <li>The parser and the serialization now support user-defined string types (#1006, #1009).</li> </ul>"},{"location":"home/releases/#further-changes_9","title":"Further Changes","text":"<ul> <li>Clang Analyzer is now used as additional static analyzer; see <code>make clang_analyze</code>.</li> <li>Overworked README by adding links to the documentation (#981).</li> </ul>"},{"location":"home/releases/#deprecated-functions_10","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v311","title":"v3.1.1","text":"<p>Files</p> <ul> <li>include.zip (114 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (577 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2018-02-13 SHA-256: e14ce5e33d6a2daf748026bd4947f3d9686ca4cfd53d10c3da46a0a9aceb7f2e (json.hpp), fde771d4b9e4f222965c00758a2bdd627d04fb7b59e09b7f3d1965abdc848505 (include.zip)</p>"},{"location":"home/releases/#summary_11","title":"Summary","text":"<p>This release fixes several bugs in the library. All changes are backward-compatible.</p>"},{"location":"home/releases/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>Fixed parsing of CBOR strings with indefinite length (#961). Earlier versions of this library misinterpreted the CBOR standard and rejected input with the <code>0x7F</code> start byte.</li> <li>Fixed user-defined conversion to vector type (#924, #969). A wrong SFINAE check rejected code though a user-defined conversion was provided.</li> <li>Fixed documentation of the parser behavior for objects with duplicate keys (#963). The exact behavior is not specified by RFC 8259 and the library now also provides no guarantee which object key is stored.</li> <li>Added check to detect memory overflow when parsing UBJSON containers (#962). The optimized UBJSON format allowed for specifying an array with billions of <code>null</code> elements with a few bytes and the library did not check whether this size exceeded <code>max_size()</code>.</li> </ul>"},{"location":"home/releases/#further-changes_10","title":"Further Changes","text":"<ul> <li>Code coverage is now calculated for the individual header files, allowing to find uncovered lines more quickly than by browsing through the single header version (#953, #957).</li> <li>A Makefile target <code>run_benchmarks</code> was added to quickly build and run the benchmark suite.</li> <li>The documentation was harmonized with respect to the header inclusion (#955). Now all examples and the README use <code>#include &lt;nlohmann/json.hpp&gt;</code> to allow for selecting <code>single_include</code> or <code>include</code> or whatever installation folder as include directory.</li> <li>Added note on how to use the library with the cget package manager (#954).</li> </ul>"},{"location":"home/releases/#deprecated-functions_11","title":"Deprecated functions","text":"<p>This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li>Function <code>iterator_wrapper</code> are deprecated. Please use the member function <code>items()</code> instead.</li> <li>Functions <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> and <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> are deprecated. Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</li> </ul>"},{"location":"home/releases/#v310","title":"v3.1.0","text":"<p>Files</p> <ul> <li>include.zip (114 KB)</li> <li>include.zip.asc (1 KB)</li> <li>json.hpp (577 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2018-02-01 SHA-256: d40f614d10a6e4e4e80dca9463da905285f20e93116c36d97d4dc1aa63d10ba4 (json.hpp), 2b7234fca394d1e27b7e017117ed80b7518fafbb4f4c13a7c069624f6f924673 (include.zip)</p>"},{"location":"home/releases/#summary_12","title":"Summary","text":"<p>This release adds support for the UBJSON format and JSON Merge Patch. It also contains some minor changes and bug fixes. All changes are backward-compatible.</p>"},{"location":"home/releases/#new-features_6","title":"New features","text":"<ul> <li>The library now supports UBJSON (Universal Binary JSON Specification) as binary format to read and write JSON values space-efficiently. See the documentation overview for a comparison of the different formats CBOR, MessagePack, and UBJSON.</li> <li>JSON Merge Patch (RFC 7386) offers an intuitive means to describe patches between JSON values (#876, #877). See the documentation of <code>merge_patch</code> for more information.</li> </ul>"},{"location":"home/releases/#improvements_8","title":"Improvements","text":"<ul> <li>The library now uses the Grisu2 algorithm for printing floating-point numbers (based on the reference implementation by Florian Loitsch) which produces a short representation which is guaranteed to round-trip (#360, #935, #936).</li> <li>The UTF-8 handling was further simplified by using the decoder of Bj\u00f6rn Hoehrmann in more scenarios.</li> </ul>"},{"location":"home/releases/#reorganization","title":"Reorganization","text":"<ul> <li>Though the library is released as a single header, its development got more and more complicated. With this release, the header is split into several files and the single-header file <code>json.hpp</code> can be generated from these development sources. In the repository, folder <code>include</code> contains the development sources and <code>single_include</code> contains the single <code>json.hpp</code> header (#700, #906, #907, #910, #911, #915, #920, #924, #925, #928, #944).</li> <li>The split further allowed for a forward declaration header <code>include/nlohmann/json_fwd.hpp</code> to speed up compilation times (#314).</li> </ul>"},{"location":"home/releases/#further-changes_11","title":"Further changes","text":"<ul> <li>Google Benchmark is now used for micro benchmarks (see <code>benchmarks</code> folder, #921).</li> <li>The serialization (JSON and binary formats) now properly work with the libraries string template parameter, allowing for optimized string implementations to be used in constraint environments such as embedded software (#941, #950).</li> <li>The exceptional behavior can now be overridden by defining macros <code>JSON_THROW_USER</code>, <code>JSON_TRY_USER</code>, and <code>JSON_CATCH_USER</code>, defining the behavior of <code>throw</code>, <code>try</code> and <code>catch</code>, respectively. This allows to switch off C++'s exception mechanism yet still execute user-defined code in case an error condition occurs (#938).</li> <li>To facilitate the interplay with flex and Bison, the library does not use the variable name <code>yytext</code> any more as it could clash with macro definitions (#933).</li> <li>The library now defines <code>NLOHMANN_JSON_VERSION_MAJOR</code>, <code>NLOHMANN_JSON_VERSION_MINOR</code>, and <code>NLOHMANN_JSON_VERSION_PATCH</code> to allow for conditional compilation based on the included library version (#943, #948).</li> <li>A compilation error with ICC has been fixed (#947).</li> <li>Typos and links in the documentation have been fixed (#900, #930).</li> <li>A compiler error related to incomplete types has been fixed (#919).</li> <li>The tests form the UTF-8 decoder stress test have been added to the test suite.</li> </ul>"},{"location":"home/releases/#deprecated-functions_12","title":"Deprecated functions","text":"<ul> <li>Function <code>iterator_wrapper</code> has been deprecated (#874). Since its introduction, the name was up for discussion, as it was too technical. We now introduced the member function <code>items()</code> with the same semantics. <code>iterator_wrapper</code> will be removed in the next major version (i.e., 4.0.0).</li> </ul> <p>Furthermore, the following functions are deprecated since version 3.0.0 and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li><code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code></li> <li><code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code></li> </ul> <p>Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</p>"},{"location":"home/releases/#v301","title":"v3.0.1","text":"<p>Files</p> <ul> <li>json.hpp (502 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2017-12-29 SHA-256: c9b3591f1bb94e723a0cd7be861733a3a555b234ef132be1e9027a0364118c4c</p>"},{"location":"home/releases/#summary_13","title":"Summary","text":"<p>This release fixes small issues in the implementation of JSON Pointer and JSON Patch. All changes are backward-compatible.</p>"},{"location":"home/releases/#changes","title":"Changes","text":"<ul> <li> The \"copy\" operation of JSON Patch (RFC 6902) requests that it is an error if the target path points into a non-existing array or object (see #894 for a detailed description). This release fixes the implementation to detect such invalid target paths and throw an exception.</li> <li> An array index in a JSON Pointer (RFC 6901) must be an integer. This release fixes the implementation to throw an exception in case invalid array indices such as <code>10e2</code> are used.</li> <li> Added the JSON Patch tests from Byron Ruth and Mike McCabe.</li> <li> Fixed the documentation of the <code>at(ptr)</code> function with JSON Pointers to list all possible exceptions (see #888).</li> <li> Updated the container overview documentation (see #883).</li> <li> The CMake files now respect the <code>BUILD_TESTING</code> option (see #846, #885)</li> <li> Fixed some compiler warnings (see #858, #882).</li> </ul>"},{"location":"home/releases/#deprecated-functions_13","title":"Deprecated functions","text":"<p> To unify the interfaces and to improve similarity with the STL, the following functions are deprecated since version 3.0.0 and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li><code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code></li> <li><code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code></li> </ul> <p>Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</p>"},{"location":"home/releases/#v300","title":"v3.0.0","text":"<p>Files</p> <ul> <li>json.hpp (501 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2017-12-17 SHA-256: 076d4a0cb890a3c3d389c68421a11c3d77c64bd788e85d50f1b77ed252f2a462</p>"},{"location":"home/releases/#summary_14","title":"Summary","text":"<p>After almost a year, here is finally a new release of JSON for Modern C++, and it is a major one! As we adhere to semantic versioning, this means the release includes some breaking changes, so please read the next section carefully before you update. But don't worry, we also added a few new features and put a lot of effort into fixing a lot of bugs and straighten out a few inconsistencies.</p>"},{"location":"home/releases/#breaking-changes","title":"Breaking changes","text":"<p>This section describes changes that change the public API of the library and may require changes in code using a previous version of the library. In section \"Moving from 2.x.x to 3.0.0\" at the end of the release notes, we describe in detail how existing code needs to be changed.</p> <ul> <li>The library now uses user-defined exceptions instead of reusing those defined in <code>&lt;stdexcept&gt;</code> (#244). This not only allows to add more information to the exceptions (every exception now has an identifier, and parse errors contain the position of the error), but also to easily catch all library exceptions with a single <code>catch(json::exception)</code>.</li> <li>When strings with a different encoding as UTF-8 were stored in JSON values, their serialization could not be parsed by the library itself, as only UTF-8 is supported. To enforce this library limitation and improve consistency, non-UTF-8 encoded strings now yield a <code>json::type_error</code> exception during serialization (#838). The check for valid UTF-8 is realized with code from Bj\u00f6rn Hoehrmann.</li> <li>NaN and infinity values can now be stored inside the JSON value without throwing an exception. They are, however, still serialized as <code>null</code> (#388).</li> <li>The library's iterator tag was changed from RandomAccessIterator to BidirectionalIterator (#593). Supporting RandomAccessIterator was incorrect as it assumed an ordering of values in a JSON objects which are unordered by definition.</li> <li>The library does not include the standard headers <code>&lt;iostream&gt;</code>, <code>&lt;ctype&gt;</code>, and <code>&lt;stdexcept&gt;</code> any more. You may need to add these headers to code relying on them.</li> <li>Removed constructor <code>explicit basic_json(std::istream&amp; i, const parser_callback_t cb = nullptr)</code> which was deprecated in version 2.0.0 (#480).</li> </ul>"},{"location":"home/releases/#deprecated-functions_14","title":"Deprecated functions","text":"<p>To unify the interfaces and to improve similarity with the STL, the following functions are now deprecated and will be removed in the next major version (i.e., 4.0.0):</p> <ul> <li><code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code></li> <li><code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code></li> </ul> <p>Please use <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> and <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</p>"},{"location":"home/releases/#new-features_7","title":"New features","text":"<p>With all this breaking and deprecation out of the way, let's talk about features!</p> <ul> <li>We improved the diagnostic information for syntax errors (#301). Now, an exception <code>json::parse_error</code> is thrown which contains a detailed message on the error, but also a member <code>byte</code> to indicate the byte offset in the input where the error occurred.</li> <li>We added a non-throwing syntax check (#458): The new <code>accept</code> function returns a Boolean indicating whether the input is proper JSON. We also added a Boolean parameter <code>allow_exceptions</code> to the existing <code>parse</code> functions to return a <code>discarded</code> value in case a syntax error occurs instead of throwing an exception.</li> <li>An <code>update</code> function was added to merge two JSON objects (#428). In case you are wondering: the name was inspired by Python.</li> <li>The <code>insert</code> function now also supports an iterator range to add elements to an object.</li> <li>The binary exchange formats CBOR and MessagePack can now be parsed from input streams and written to output streams (#477).</li> <li>Input streams are now only read until the end of a JSON value instead of the end of the input (#367).</li> <li>The serialization function <code>dump</code> now has two optional parameters <code>ensure_ascii</code> to escape all non-ASCII characters with <code>\\uxxxx</code> and an <code>indent_char</code> parameter to choose whether to indent with spaces or tabs (#654). </li> <li>Added built-in type support for C arrays (#502), <code>std::pair</code> and <code>std::tuple</code> (#563, #614), <code>enum</code> and <code>enum class</code> (#545), <code>std::vector&lt;bool&gt;</code> (#494). Fixed support for <code>std::valarray</code> (#702), <code>std::array</code> (#553), and <code>std::map&lt;std::string, std::string&gt;</code> (#600, #607).</li> </ul>"},{"location":"home/releases/#further-changes_12","title":"Further changes","text":"<p>Furthermore, there have been a lot of changes under the hood:</p> <ul> <li>Replaced the re2c generated scanner by a self-coded version which allows for a better modularization of the parser and better diagnostics. To test the new scanner, we added millions (8,860,608 to be exact) of unit tests to check all valid and invalid byte sequences of the Unicode standard.</li> <li>Google's OSS-Fuzz is still constantly fuzz-testing the library and found several issues that were fixed in this release (#497, #504, #514, #516, #518, #519, #575).</li> <li>We now also ignore UTF-8 byte order marks when parsing from an iterator range (#602).</li> <li>Values can be now moved from initializer lists (#663).</li> <li>Updated to Catch 1.9.7. Unfortunately, Catch2 currently has some performance issues.</li> <li>The non-exceptional paths of the library are now annotated with <code>__builtin_expect</code> to optimize branch prediction as long as no error occurs.</li> <li>MSVC now produces a stack trace in MSVC if a <code>from_json</code> or <code>to_json</code> function was not found for a user-defined type. We also added a debug visualizer <code>nlohmann_json.natvis</code> for better debugging in MSVC (#844).</li> <li>Overworked the documentation and added even more examples.</li> <li>The build workflow now relies on CMake and CTest. Special flags can be chosen with CMake, including coverage (<code>JSON_Coverage</code>), compilation without exceptions (<code>JSON_NoExceptions</code>), LLVM sanitizers (<code>JSON_Sanitizer</code>), or execution with Valgrind (<code>JSON_Valgrind</code>).</li> <li>Added support for package managers Meson (#576), Conan (#566), Hunter (#671, #829), and vcpkg (#753).</li> <li>Added CI builders: Xcode 8.3, 9.0, 9.1, and 9.2; GCC 7.2; Clang 3.8, 3.9, 4.0, and 5.0; Visual Studio 2017. The library is further built with C++17 settings on the latest Clang, GCC, and MSVC version to quickly detect new issues.</li> </ul>"},{"location":"home/releases/#moving-from-2xx-to-300","title":"Moving from 2.x.x to 3.0.0","text":""},{"location":"home/releases/#user-defined-exceptions","title":"User-defined Exceptions","text":"<p>There are five different exceptions inheriting from <code>json::exception</code>:</p> <ul> <li><code>json::parse_error</code> for syntax errors (including the binary formats),</li> <li><code>json::invalid_iterator</code> for errors related to iterators,</li> <li><code>json::type_error</code> for errors where functions were called with the wrong JSON type,</li> <li><code>json::out_of_range</code> for range errors, and</li> <li><code>json::other_error</code> for miscellaneous errors.</li> </ul> <p>To support these exception, the <code>try</code>/<code>catch</code> blocks of your code need to be adjusted:</p> new exception previous exception parse_error.101 invalid_argument parse_error.102 invalid_argument parse_error.103 invalid_argument parse_error.104 invalid_argument parse_error.105 invalid_argument parse_error.106 domain_error parse_error.107 domain_error parse_error.108 domain_error parse_error.109 invalid_argument parse_error.110 out_of_range parse_error.111 invalid_argument parse_error.112 invalid_argument invalid_iterator.201 domain_error invalid_iterator.202 domain_error invalid_iterator.203 domain_error invalid_iterator.204 out_of_range invalid_iterator.205 out_of_range invalid_iterator.206 domain_error invalid_iterator.207 domain_error invalid_iterator.208 domain_error invalid_iterator.209 domain_error invalid_iterator.210 domain_error invalid_iterator.211 domain_error invalid_iterator.212 domain_error invalid_iterator.213 domain_error invalid_iterator.214 out_of_range type_error.301 domain_error type_error.302 domain_error type_error.303 domain_error type_error.304 domain_error type_error.305 domain_error type_error.306 domain_error type_error.307 domain_error type_error.308 domain_error type_error.309 domain_error type_error.310 domain_error type_error.311 domain_error type_error.313 domain_error type_error.314 domain_error type_error.315 domain_error out_of_range.401 out_of_range out_of_range.402 out_of_range out_of_range.403 out_of_range out_of_range.404 out_of_range out_of_range.405 domain_error other_error.501 domain_error"},{"location":"home/releases/#handling-of-nan-and-inf","title":"Handling of NaN and INF","text":"<ul> <li> <p>If an overflow occurs during parsing a number from a JSON text, an exception <code>json::out_of_range</code> is thrown so that the overflow is detected early and roundtripping is guaranteed.</p> </li> <li> <p>NaN and INF floating-point values can be stored in a JSON value and are not replaced by null. That is, the basic_json class behaves like <code>double</code> in this regard (no exception occurs). However, NaN and INF are serialized to <code>null</code>.</p> </li> </ul>"},{"location":"home/releases/#removal-of-deprecated-functions","title":"Removal of deprecated functions","text":"<p>Function <code>explicit basic_json(std::istream&amp; i, const parser_callback_t cb = nullptr)</code> should be replaced by the <code>parse</code> function: Let <code>ss</code> be a stream and <code>cb</code> be a parse callback function.</p> <p>Old code:</p> <pre><code>json j(ss, cb);\n</code></pre> <p>New code:</p> <pre><code>json j = json::parse(ss, cb);\n</code></pre> <p>If no callback function is used, also the following code works:</p> <pre><code>json j;\nj &lt;&lt; ss;\n</code></pre> <p>or</p> <pre><code>json j;\nss &gt;&gt; j;\n</code></pre>"},{"location":"home/releases/#v211","title":"v2.1.1","text":"<p>Files</p> <ul> <li>json.hpp (437 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <p>Release date: 2017-02-25 SHA-256: faa2321beb1aa7416d035e7417fcfa59692ac3d8c202728f9bcc302e2d558f57</p>"},{"location":"home/releases/#summary_15","title":"Summary","text":"<p>This release fixes a locale-related bug in the parser. To do so, the whole number handling (lexer, parser, and also the serialization) have been overworked. Furthermore, a lot of small changes added up that were added to this release. All changes are backward-compatible.</p>"},{"location":"home/releases/#changes_1","title":"Changes","text":"<ul> <li> Locales that have a different character than <code>.</code> as decimal separator (e.g., the Norwegian locale <code>nb_NO.UTF-8</code>) led to truncated number parsing or parse errors. The library now has been fixed to work with any locale. Note that <code>.</code> is still the only valid decimal separator for JSON input.</li> <li> Numbers like <code>1.0</code> were correctly parsed as floating-point number, but serialized as integer (<code>1</code>). Now, floating-point numbers correctly round trip.</li> <li> Parsing incorrect JSON numbers with leading 0 (<code>0123</code>) could yield a buffer overflow. This is fixed now by detecting such errors directly by the lexer.</li> <li> Constructing a JSON value from a pointer was incorrectly interpreted as a Boolean; such code will now yield a compiler error.</li> <li> Comparing a JSON number with <code>0</code> led to a comparison with <code>null</code>. This is fixed now.</li> <li> All throw calls are now wrapped in macros.</li> <li> Starting during the preparation of this release (since 8 February 2017), commits and released files are cryptographically signed with this GPG key. Previous releases have also been signed.</li> <li> The parser for MessagePack and CBOR now supports an optional start index parameter to define a byte offset for the parser.</li> <li> Some more warnings have been fixed. With Clang, the code compiles without warnings with <code>-Weverything</code> (well, it needs <code>-Wno-documentation-unknown-command</code> and <code>-Wno-deprecated-declarations</code>, but you get the point).</li> <li> The code can be compiled easier with many Android NDKs by avoiding macros like <code>UINT8_MAX</code> which previously required defining a preprocessor macro for compilation.</li> <li> The unit tests now compile two times faster.</li> <li> Cotire is used to speed up the build.</li> <li> Fixed a lot of typos in the documentation.</li> <li> Added a section to the README file that lists all used third-party code/tools.</li> <li> Added a note on constructing a string value vs. parsing.</li> <li> The test suite now contains 11202597 unit tests.</li> <li> Improved the Doxygen documentation by shortening the template parameters of class <code>basic_json</code>.</li> <li> Removed Doozer.</li> <li> Added Codacity.</li> <li> Upgraded Catch to version 1.7.2.</li> </ul>"},{"location":"home/releases/#v210","title":"v2.1.0","text":"<p>Files</p> <ul> <li>json.hpp (426 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2017-01-28</li> <li>SHA-256: a571dee92515b685784fd527e38405cf3f5e13e96edbfe3f03d6df2e363a767b</li> </ul>"},{"location":"home/releases/#summary_16","title":"Summary","text":"<p>This release introduces a means to convert from/to user-defined types. The release is backwards compatible.</p> <p></p>"},{"location":"home/releases/#changes_2","title":"Changes","text":"<ul> <li> The library now offers an elegant way to convert from and to arbitrary value types. All you need to do is to implement two functions: <code>to_json</code> and <code>from_json</code>. Then, a conversion is as simple as putting a <code>=</code> between variables. See the README for more information and examples.</li> <li> Exceptions can now be switched off. This can be done by defining the preprocessor symbol <code>JSON_NOEXCEPTION</code> or by passing <code>-fno-exceptions</code> to your compiler. In case the code would usually thrown an exception, <code>abort()</code> is now called.</li> <li> Information on the library can be queried with the new (static) function <code>meta()</code> which returns a JSON object with information on the version, compiler, and platform. See the documentation for an example.</li> <li> A bug in the CBOR parser was fixed which led to a buffer overflow.</li> <li> The function <code>type_name()</code> is now public. It allows to query the type of a JSON value as string.</li> <li> Added the Big List of Naughty Strings as test case.</li> <li> Updated to Catch v1.6.0.</li> <li> Some typos in the documentation have been fixed.</li> </ul>"},{"location":"home/releases/#v2010","title":"v2.0.10","text":"<p>Files</p> <ul> <li>json.hpp (409 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2017-01-02</li> <li>SHA-256: ec27d4e74e9ce0f78066389a70724afd07f10761009322dc020656704ad5296d</li> </ul>"},{"location":"home/releases/#summary_17","title":"Summary","text":"<p>This release fixes several security-relevant bugs in the MessagePack and CBOR parsers. The fixes are backwards compatible.</p>"},{"location":"home/releases/#changes_3","title":"Changes","text":"<ul> <li> Fixed a lot of bugs in the CBOR and MesssagePack parsers. These bugs occurred if invalid input was parsed and then could lead in buffer overflows. These bugs were found with Google's OSS-Fuzz, see #405, #407, #408, #409, #411, and #412 for more information.</li> <li> We now also use the Doozer continuous integration platform.</li> <li> The complete test suite is now also run with Clang's address sanitizer and undefined-behavior sanitizer.</li> <li> Overworked fuzz testing; CBOR and MessagePack implementations are now fuzz-tested. Furthermore, all fuzz tests now include a round trip which ensures created output can again be properly parsed and yields the same JSON value.</li> <li> Clarified documentation of <code>find()</code> function to always return <code>end()</code> when called on non-object value types.</li> <li> Moved thirdparty test code to <code>test/thirdparty</code> directory.</li> </ul>"},{"location":"home/releases/#v209","title":"v2.0.9","text":"<p>Files</p> <ul> <li>json.hpp (406 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-12-16</li> <li>SHA-256: fbf3396f13e187d6c214c297bddc742d918ea9b55e10bfb3d9f458b9bfdc22e5</li> </ul>"},{"location":"home/releases/#summary_18","title":"Summary","text":"<p>This release implements with CBOR and MessagePack two binary serialization/deserialization formats. It further contains some small fixes and improvements. The fixes are backwards compatible.</p> <p></p>"},{"location":"home/releases/#changes_4","title":"Changes","text":"<ul> <li> The library can now read and write the binary formats CBOR (Concise Binary Object Representation) and MessagePack. Both formats are aimed to produce a very compact representation of JSON which can be parsed very efficiently. See the  README file for more information and examples.</li> <li> simplified the iteration implementation allowing to remove dozens of lines of code</li> <li> fixed an integer overflow error detected by Google's OSS-Fuzz</li> <li> suppressed documentation warnings inside the library to facilitate compilation with <code>-Wdocumentation</code></li> <li> fixed an overflow detection error in the number parser</li> <li> updated contribution guidelines to a list of frequentely asked features that will most likely be never added to the library</li> <li>  added a table of contents to the README file to add some structure</li> <li> mentioned the many examples and the documentation in the README file</li> <li> split unit tests into individual independent binaries to speed up compilation and testing</li> <li> the test suite now contains 11201886 tests</li> </ul>"},{"location":"home/releases/#v208","title":"v2.0.8","text":"<p>Files</p> <ul> <li>json.hpp (360 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-12-02</li> <li>SHA-256: b70db0ad34f8e0e61dc3f0cbab88099336c9674c193d8a3439d93d6aca2d7120</li> </ul>"},{"location":"home/releases/#summary_19","title":"Summary","text":"<p>This release combines a lot of small fixes and improvements. The fixes are backwards compatible.</p>"},{"location":"home/releases/#changes_5","title":"Changes","text":"<ul> <li> fixed a bug that froze the parser if a passed file was not found (now, <code>std::invalid_argument</code> is thrown)</li> <li> fixed a bug that lead to an error of a file at EOF was parsed again (now, <code>std::invalid_argument</code> is thrown)</li> <li> the well known functions <code>emplace</code> and <code>emplace_back</code> have been added to JSON values and work as expected</li> <li> improved the performance of the serialization (<code>dump</code> function)</li> <li> improved the performance of the deserialization (parser)</li> <li> some continuous integration images at Travis were added and retired; see here for the current continuous integration setup</li> <li> the Coverity scan works again</li> <li> the benchmarking code has been improved to produce more stable results</li> <li> the README file has been extended and includes more frequently asked examples</li> <li> the test suite now contains 8905518 tests</li> <li> updated Catch to version 1.5.8</li> </ul>"},{"location":"home/releases/#v207","title":"v2.0.7","text":"<p>Files</p> <ul> <li>json.hpp (355 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-11-02</li> <li>SHA-256: 5545c323670f8165bae90b9dc6078825e86ec310d96cc4e5b47233ea43715bbf</li> </ul>"},{"location":"home/releases/#summary_20","title":"Summary","text":"<p>This release fixes a few bugs in the JSON parser found in the Parsing JSON is a Minefield \ud83d\udca3 article. The fixes are backwards compatible.</p>"},{"location":"home/releases/#changes_6","title":"Changes","text":"<ul> <li>The article Parsing JSON is a Minefield \ud83d\udca3 discusses a lot of pitfalls of the JSON specification. When investigating the published test cases, a few bugs in the library were found and fixed:</li> <li>Files with less than 5 bytes can now be parsed without error.</li> <li>The library now properly rejects any file encoding other than UTF-8. Furthermore, incorrect surrogate pairs are properly detected and rejected.</li> <li>The library now accepts all but one \"yes\" test (y_string_utf16.json): UTF-16 is not supported.</li> <li>The library rejects all but one \"no\" test (n_number_then_00.json): Null bytes are treated as end of file instead of an error. This allows to parse input from null-terminated strings.</li> <li>The string length passed to a user-defined string literal is now exploited to choose a more efficient constructor.</li> <li>A few grammar mistakes in the README file have been fixed.</li> </ul>"},{"location":"home/releases/#v206","title":"v2.0.6","text":"<p>Files</p> <ul> <li>json.hpp (349 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-10-15</li> <li>SHA256: 459cc93d5e2f503e50c6d5876eb86bfea7daf405f5a567c5a2c9abc2383756ae</li> </ul>"},{"location":"home/releases/#summary_21","title":"Summary","text":"<p>This release fixes the semantics of <code>operator[]</code> for JSON Pointers (see below). This fix is backwards compatible.</p>"},{"location":"home/releases/#changes_7","title":"Changes","text":"<ul> <li><code>operator[]</code> for JSON Pointers now behaves like the other versions of <code>operator[]</code> and transforms <code>null</code> values into objects or arrays if required. This allows to created nested structures like <code>j[\"/foo/bar/2\"] = 17</code> (yielding <code>{\"foo\": \"bar\": [null, null, 17]}</code>) without problems.</li> <li>overworked a helper SFINAE function</li> <li>fixed some documentation issues</li> <li>fixed the CMake files to allow to run the test suite outside the main project directory</li> <li>restored test coverage to 100%.</li> </ul>"},{"location":"home/releases/#v205","title":"v2.0.5","text":"<p>Files</p> <ul> <li>json.hpp (347 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-09-14</li> <li>SHA-256: 8b7565263a44e2b7d3b89808bc73d2d639037ff0c1f379e3d56dbd77e00b98d9</li> </ul>"},{"location":"home/releases/#summary_22","title":"Summary","text":"<p>This release fixes a regression bug in the stream parser (function <code>parse()</code> and the <code>&lt;&lt;</code>/<code>&gt;&gt;</code> operators). This fix is backwards compatible.</p>"},{"location":"home/releases/#changes_8","title":"Changes","text":"<ul> <li>Bug fix: The end of a file stream was not detected properly which led to parse errors. This bug should have been fixed with 2.0.4, but there was still a flaw in the code.</li> </ul>"},{"location":"home/releases/#v204","title":"v2.0.4","text":"<p>Files</p> <ul> <li>json.hpp (347 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-09-11</li> <li>SHA-256: 632ceec4c25c4e2153f71470d3a2b992c8355f6d8b4d627d05dd16095cd3aeda</li> </ul>"},{"location":"home/releases/#summary_23","title":"Summary","text":"<p>This release fixes a bug in the stream parser (function <code>parse()</code> and the <code>&lt;&lt;</code>/<code>&gt;&gt;</code> operators). This fix is backwards compatible.</p>"},{"location":"home/releases/#changes_9","title":"Changes","text":"<ul> <li>Bug fix: The end of a file stream was not detected properly which led to parse errors.</li> <li>Fixed a compiler warning about an unused variable.</li> </ul>"},{"location":"home/releases/#v203","title":"v2.0.3","text":"<p>Files</p> <ul> <li>json.hpp (347 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-08-31</li> <li>SHA-256: 535b73efe5546fde9e763c14aeadfc7b58183c0b3cd43c29741025aba6cf6bd3</li> </ul>"},{"location":"home/releases/#summary_24","title":"Summary","text":"<p>This release combines a lot of small fixes and improvements. The release is backwards compatible.</p>"},{"location":"home/releases/#changes_10","title":"Changes","text":"<ul> <li>The parser/deserialization functions have been generalized to process any contiguous sequence of 1-byte elements (e.g., <code>char</code>, <code>unsigned char</code>, <code>uint8_t</code>). This includes all kind of string representations (string literals, char arrays, <code>std::string</code>, <code>const char*</code>), contiguous containers (C-style arrays, <code>std::vector</code>, <code>std::array</code>, <code>std::valarray</code>, <code>std::initializer_list</code>). User-defined containers providing random-access iterator access via <code>std::begin</code> and <code>std::end</code> can be used as well. See the documentation (1, 2, 3, 4) for more information. Note that contiguous storage cannot be checked at compile time; if any of the parse functions are called with a noncompliant container, the behavior is undefined and will most likely yield segmentation violation. The preconditions are enforced by an assertion unless the library is compiled with preprocessor symbol <code>NDEBUG</code>.</li> <li>As a general remark on assertions: The library uses assertions to preclude undefined behavior. A prominent example for this is the <code>operator[]</code> for const JSON objects. The behavior of this const version of the operator is undefined if the given key does not exist in the JSON object, because unlike the non-const version, it cannot add a <code>null</code> value at the given key. Assertions can be switched of by defining the preprocessor symbol <code>NDEBUG</code>. See the documentation of <code>assert</code> for more information.</li> <li>In the course of cleaning up the parser/deserialization functions, the constructor <code>basic_json(std::istream&amp;, const parser_callback_t)</code> has been deprecated and will be deleted with the next major release 3.0.0 to unify the interface of the library. Deserialization will be done by stream operators or by calling one of the <code>parse</code> functions. That is, calls like <code>json j(i);</code> for an input stream <code>i</code> need to be replaced by <code>json j = json::parse(i);</code>. Compilers will produce a deprecation warning if client code uses this function.</li> <li>Minor improvements:</li> <li>Improved the performance of the serialization by avoiding the re-creation of a locale object.</li> <li>Fixed two MSVC warnings. Compiling the test suite with <code>/Wall</code> now only warns about non-inlined functions (C4710) and the deprecation of the constructor from input-stream (C4996).</li> <li>Some project internals:</li> <li> The project has qualified for the Core Infrastructure Initiative Best Practices Badge. While most requirements where already satisfied, some led to more explicit documentation of quality-ensuring procedures. For instance, static analysis is now executed with every commit on the build server. Furthermore, the contribution guidelines document how to communicate security issues privately.</li> <li>The test suite has been overworked and split into several files to allow for faster compilation and analysis. The execute the test suite, simply execute <code>make check</code>.</li> <li>The continuous integration with Travis was extended with Clang versions 3.6.0 to 3.8.1 and now includes 18 different compiler/OS combinations.</li> <li>An 11-day run of American fuzzy lop checked 962 million inputs on the parser and found no issue.</li> </ul>"},{"location":"home/releases/#v202","title":"v2.0.2","text":"<p>Files</p> <ul> <li>json.hpp (338 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-07-31</li> <li>SHA-256: 8e97b7965b4594b00998d6704465412360e1a0ed927badb51ded8b82291a8f3d</li> </ul>"},{"location":"home/releases/#summary_25","title":"Summary","text":"<p>This release combines a lot of small fixes and improvements. The release is backwards compatible.</p>"},{"location":"home/releases/#changes_11","title":"Changes","text":"<ul> <li>The parser has been overworked, and a lot of small issues have been fixed:</li> <li>Improved parser performance by avoiding recursion and using move semantics for the return value.</li> <li>Unescaped control characters <code>\\x10</code>-<code>\\x1f</code> are not accepted any more.</li> <li>Fixed a bug in the parser when reading from an input stream.</li> <li>Improved test case coverage for UTF-8 parsing: now, all valid Unicode code points are tested both escaped and unescaped.</li> <li>The precision of output streams is now preserved by the parser.</li> <li>Started to check the code correctness by proving termination of important loops. Furthermore, individual assertions have been replaced by a more systematic function which checks the class invariants. Note that assertions should be switched off in production by defining the preprocessor macro <code>NDEBUG</code>, see the documentation of <code>assert</code>.</li> <li>A lot of code cleanup: removed unused headers, fixed some compiler warnings, and fixed a build error for Windows-based Clang builds.</li> <li>Added some compile-time checks:</li> <li>Unsupported compilers are rejected during compilation with an <code>#error</code> command.</li> <li>Static assertion prohibits code with incompatible pointer types used in <code>get_ptr()</code>.</li> <li>Improved the documentation, and adjusted the documentation script to choose the correct version of <code>sed</code>.</li> <li>Replaced a lot of \"raw loops\" by STL functions like <code>std::all_of</code>, <code>std::for_each</code>, or <code>std::accumulate</code>. This facilitates reasoning about termination of loops and sometimes allowed to simplify functions to a single return statement.</li> <li>Implemented a <code>value()</code> function for JSON pointers (similar to <code>at</code> function).</li> <li>The Homebrew formula (see Integration) is now tested for all Xcode builds (6.1 - 8.x) with Travis.</li> <li>Avoided output to <code>std::cout</code> in the test cases.</li> </ul>"},{"location":"home/releases/#v201","title":"v2.0.1","text":"<p>Files</p> <ul> <li>json.hpp (321 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-06-28</li> <li>SHA-256: ef550fcd7df572555bf068e9ec4e9d3b9e4cdd441cecb0dcea9ea7fd313f72dd</li> </ul>"},{"location":"home/releases/#summary_26","title":"Summary","text":"<p>This release fixes a performance regression in the JSON serialization (function <code>dump()</code>). This fix is backwards compatible.</p>"},{"location":"home/releases/#changes_12","title":"Changes","text":"<ul> <li>The locale of the output stream (or the internal string stream if a JSON value is serialized to a string) is now adjusted once for the whole serialization instead of for each floating-point number.</li> <li>The locale of an output stream is now correctly reset to the previous value by the JSON library.</li> </ul>"},{"location":"home/releases/#v200","title":"v2.0.0","text":"<p>Files</p> <ul> <li>json.hpp (321 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-06-24</li> <li>SHA-256: ac9e1fb25c2ac9ca5fc501fcd2fe3281fe04f07018a1b48820e7b1b11491bb6c</li> </ul>"},{"location":"home/releases/#summary_27","title":"Summary","text":"<p>This release adds several features such as JSON Pointers, JSON Patch, or support for 64 bit unsigned integers. Furthermore, several (subtle) bugs have been fixed.</p> <p>As <code>noexcept</code> and <code>constexpr</code> specifier have been added to several functions, the public API has effectively been changed in a (potential) non-backwards compatible manner. As we adhere to Semantic Versioning, this calls for a new major version, so say hello to 2\ufe0f\u20e3.0\ufe0f\u20e3.0\ufe0f\u20e3.</p>"},{"location":"home/releases/#changes_13","title":"Changes","text":"<ul> <li>\ud83d\udd1f A JSON value now uses <code>uint64_t</code> (default value for template parameter <code>NumberUnsignedType</code>) as data type for unsigned integer values. This type is used automatically when an unsigned number is parsed. Furthermore, constructors, conversion operators and an <code>is_number_unsigned()</code> test have been added.</li> <li>\ud83d\udc49 JSON Pointer (RFC 6901) support: A JSON Pointer is a string (similar to an XPath expression) to address a value inside a structured JSON value. JSON Pointers can be used in <code>at()</code> and <code>operator[]</code> functions. Furthermore, JSON values can be \u201cflattened\u201d to key/value pairs using <code>flatten()</code> where each key is a JSON Pointer. The original value can be restored by \u201cunflattening\u201d the flattened value using <code>unflatten()</code>.</li> <li>\ud83c\udfe5 JSON Patch (RFC 6902) support. A JSON Patch is a JSON value that describes the required edit operations (add, change, remove, \u2026) to transform a JSON value into another one. A JSON Patch can be created with function <code>diff(const basic_json&amp;)</code> and applied with <code>patch(const basic_json&amp;)</code>. Note the created patches use a rather primitive algorithm so far and leave room for improvement.</li> <li>\ud83c\uddea\ud83c\uddfa The code is now locale-independent: Floating-point numbers are always serialized with a period (<code>.</code>) as decimal separator and ignores different settings from the locale.</li> <li>\ud83c\udf7a Homebrew support: Install the library with <code>brew tap nlohmann/json &amp;&amp; brew install nlohmann_json</code>.</li> <li>Added constructor to create a JSON value by parsing a <code>std::istream</code> (e.g., <code>std::stringstream</code> or <code>std::ifstream</code>).</li> <li>Added <code>noexcept</code> specifier to <code>basic_json(boolean_t)</code>, <code>basic_json(const number_integer_t)</code>, <code>basic_json(const int)</code>, <code>basic_json(const number_float_t)</code>, iterator functions (<code>begin()</code>, <code>end()</code>, etc.)</li> <li>When parsing numbers, the sign of <code>0.0</code> (vs. <code>-0.0</code>) is preserved.</li> <li>Improved MSVC 2015, Android, and MinGW support. See README for more information.</li> <li>Improved test coverage (added 2,225,386 tests).</li> <li>Removed some misuses of <code>std::move</code>.</li> <li>Fixed several compiler warnings.</li> <li>Improved error messages from JSON parser.</li> <li>Updated to <code>re2c</code> to version 0.16 to use a minimal DFAs for the lexer.</li> <li>Updated test suite to use Catch version 1.5.6.</li> <li>Made type getters (<code>is_number</code>, etc.) and const value access <code>constexpr</code>.</li> <li>Functions <code>push_back</code> and <code>operator+=</code> now work with key/value pairs passed as initializer list, e.g. <code>j_object += {\"key\", 1}</code>.</li> <li>Overworked <code>CMakeLists.txt</code> to make it easier to integrate the library into other projects.</li> </ul>"},{"location":"home/releases/#notes","title":"Notes","text":"<ul> <li>Parser error messages are still very vague and contain no information on the error location.</li> <li>The implemented <code>diff</code> function is rather primitive and does not create minimal diffs.</li> <li>The name of function <code>iteration_wrapper</code> may change in the future and the function will be deprecated in the next release.</li> <li>Roundtripping (i.e., parsing a JSON value from a string, serializing it, and comparing the strings) of floating-point numbers is not 100% accurate. Note that RFC 8259 defines no format to internally represent numbers and states not requirement for roundtripping. Nevertheless, benchmarks like Native JSON Benchmark treat roundtripping deviations as conformance errors.</li> </ul>"},{"location":"home/releases/#v110","title":"v1.1.0","text":"<p>Files</p> <ul> <li>json.hpp (257 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2016-01-24</li> <li>SHA-256: c0cf0e3017798ca6bb18e757ebc570d21a3bdac877845e2b9e9573d183ed2f05</li> </ul>"},{"location":"home/releases/#summary_28","title":"Summary","text":"<p>This release fixes several small bugs and adds functionality in a backwards-compatible manner. Compared to the last version (1.0.0), the following changes have been made:</p>"},{"location":"home/releases/#changes_14","title":"Changes","text":"<ul> <li>Fixed: Floating-point numbers are now serialized and deserialized properly such that roundtripping works in more cases. [#185, #186, #190, #191, #194]</li> <li>Added: The code now contains assertions to detect undefined behavior during development. As the standard function <code>assert</code> is used, the assertions can be switched off by defining the preprocessor symbol <code>NDEBUG</code> during compilation. [#168]</li> <li>Added: It is now possible to get a reference to the stored values via the newly added function <code>get_ref()</code>. [#128, #184]</li> <li>Fixed: Access to object values via keys (<code>operator[]</code>) now works with all kind of string representations. [#171, #189]</li> <li>Fixed: The code now compiles again with Microsoft Visual Studio 2015. [#144, #167, #188]</li> <li>Fixed: All required headers are now included.</li> <li>Fixed: Typos and other small issues. [#162, #166,  #175, #177, #179, #180]</li> </ul>"},{"location":"home/releases/#notes_1","title":"Notes","text":"<p>There are still known open issues (#178, #187) which will be fixed in version 2.0.0. However, these fixes will require a small API change and will not be entirely backwards-compatible.</p>"},{"location":"home/releases/#v100","title":"v1.0.0","text":"<p>Files</p> <ul> <li>json.hpp (243 KB)</li> <li>json.hpp.asc (1 KB)</li> </ul> <ul> <li>Release date: 2015-12-28</li> <li>SHA-256: 767dc2fab1819d7b9e19b6e456d61e38d21ef7182606ecf01516e3f5230446de</li> </ul>"},{"location":"home/releases/#summary_29","title":"Summary","text":"<p>This is the first official release. Compared to the prerelease version 1.0.0-rc1, only a few minor improvements have been made:</p>"},{"location":"home/releases/#changes_15","title":"Changes","text":"<ul> <li>Changed: A UTF-8 byte order mark is silently ignored.</li> <li>Changed: <code>sprintf</code> is no longer used.</li> <li>Changed: <code>iterator_wrapper</code> also works for const objects; note: the name may change!</li> <li>Changed: Error messages during deserialization have been improved.</li> <li>Added: The <code>parse</code> function now also works with type <code>std::istream&amp;&amp;</code>.</li> <li>Added: Function <code>value(key, default_value)</code> returns either a copy of an object's element at the specified key or a given default value if no element with the key exists.</li> <li>Added: Public functions are tagged with the version they were introduced. This shall allow for better versioning in the future.</li> <li>Added: All public functions and types are documented (see http://nlohmann.github.io/json/doxygen/) including executable examples.</li> <li>Added: Allocation of all types (in particular arrays, strings, and objects) is now exception-safe.</li> <li>Added: They descriptions of thrown exceptions have been overworked and are part of the tests suite and documentation.</li> </ul>"},{"location":"home/sponsors/","title":"Sponsors","text":"<p>You can sponsor this library at GitHub Sponsors.</p>"},{"location":"home/sponsors/#priority-sponsor","title":"Priority Sponsor","text":"<ul> <li>Martti Laine</li> <li>Paul Harrington</li> </ul>"},{"location":"home/sponsors/#named-sponsors","title":"Named Sponsors","text":"<ul> <li>Michael Hartmann</li> <li>Stefan Hagen</li> <li>Steve Sperandeo</li> <li>Robert Jefe Lindst\u00e4dt</li> <li>Steve Wagner</li> <li>Lion Yang</li> </ul> <p>Thanks everyone!</p>"},{"location":"integration/","title":"Header only","text":"<p><code>json.hpp</code> is the single required file in <code>single_include/nlohmann</code> or released here. You need to add</p> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n\n// for convenience\nusing json = nlohmann::json;\n</code></pre> <p>to the files you want to process JSON and set the necessary switches to enable C++11 (e.g., <code>-std=c++11</code> for GCC and Clang).</p> <p>You can further use file <code>single_include/nlohmann/json_fwd.hpp</code> for forward declarations.</p>"},{"location":"integration/cmake/","title":"CMake","text":""},{"location":"integration/cmake/#integration","title":"Integration","text":"<p>You can use the <code>nlohmann_json::nlohmann_json</code> interface target in CMake. This target populates the appropriate usage requirements for <code>INTERFACE_INCLUDE_DIRECTORIES</code> to point to the appropriate include directories and <code>INTERFACE_COMPILE_FEATURES</code> for the necessary C++11 flags.</p>"},{"location":"integration/cmake/#external","title":"External","text":"<p>To use this library from a CMake project, you can locate it directly with <code>find_package()</code> and use the namespaced imported target from the generated package configuration:</p> <p>Example</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.5)\nproject(ExampleProject LANGUAGES CXX)\n\nfind_package(nlohmann_json 3.12.0 REQUIRED)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> <p>The package configuration file, <code>nlohmann_jsonConfig.cmake</code>, can be used either from an install tree or directly out of the build tree.</p>"},{"location":"integration/cmake/#embedded","title":"Embedded","text":"<p>To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call <code>add_subdirectory()</code> in your <code>CMakeLists.txt</code> file.</p> <p>Example</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.5)\nproject(ExampleProject LANGUAGES CXX)\n\n# If you only include this third party in PRIVATE source files, you do not need to install it\n# when your main project gets installed.\nset(JSON_Install OFF CACHE INTERNAL \"\")\n\nadd_subdirectory(nlohmann_json)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> <p>Note</p> <p>Do not use <code>include(nlohmann_json/CMakeLists.txt)</code>, since that carries with it unintended consequences that will break the build. It is generally discouraged (although not necessarily well documented as such) to use <code>include(...)</code> for pulling in other CMake projects anyways.</p>"},{"location":"integration/cmake/#supporting-both","title":"Supporting Both","text":"<p>To allow your project to support either an externally supplied or an embedded JSON library, you can use a pattern akin to the following.</p> <p>Example</p> CMakeLists.txt<pre><code>project(ExampleProject LANGUAGES CXX)\n\noption(EXAMPLE_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF)\n\nadd_subdirectory(thirdparty)\n\nadd_executable(example example.cpp)\n\n# Note that the namespaced target will always be available regardless of the import method\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> thirdparty/CMakeLists.txt<pre><code>if(EXAMPLE_USE_EXTERNAL_JSON)\n    find_package(nlohmann_json 3.12.0 REQUIRED)\nelse()\n    set(JSON_BuildTests OFF CACHE INTERNAL \"\")\n    add_subdirectory(nlohmann_json)\nendif()\n</code></pre> <p><code>thirdparty/nlohmann_json</code> is then a complete copy of this source tree.</p>"},{"location":"integration/cmake/#fetchcontent","title":"FetchContent","text":"<p>Since CMake v3.11, FetchContent can be used to automatically download a release as a dependency at configure time.</p> <p>Example</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.11)\nproject(ExampleProject LANGUAGES CXX)\n\ninclude(FetchContent)\n\nFetchContent_Declare(json URL https://github.com/nlohmann/json/releases/download/v3.12.0/json.tar.xz)\nFetchContent_MakeAvailable(json)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> <p>Note</p> <p>It is recommended to use the URL approach described above which is supported as of version 3.10.0. It is also possible to pass the Git repository like</p> <pre><code>FetchContent_Declare(json\n    GIT_REPOSITORY https://github.com/nlohmann/json\n    GIT_TAG v3.12.0\n)\n</code></pre> <p>However, the repository https://github.com/nlohmann/json download size is quite large.</p>"},{"location":"integration/cmake/#cmake-options","title":"CMake Options","text":""},{"location":"integration/cmake/#json_buildtests","title":"<code>JSON_BuildTests</code>","text":"<p>Build the unit tests when <code>BUILD_TESTING</code> is enabled. This option is <code>ON</code> by default if the library's CMake project is the top project. That is, when integrating the library as described above, the test suite is not built unless explicitly switched on with this option.</p>"},{"location":"integration/cmake/#json_ci","title":"<code>JSON_CI</code>","text":"<p>Enable CI build targets. The exact targets are used during the several CI steps and are subject to change without notice. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_diagnostics","title":"<code>JSON_Diagnostics</code>","text":"<p>Enable extended diagnostic messages by defining macro <code>JSON_DIAGNOSTICS</code>. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_diagnostic_positions","title":"<code>JSON_Diagnostic_Positions</code>","text":"<p>Enable position diagnostics by defining macro <code>JSON_DIAGNOSTIC_POSITIONS</code>. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_disableenumserialization","title":"<code>JSON_DisableEnumSerialization</code>","text":"<p>Disable default <code>enum</code> serialization by defining the macro <code>JSON_DISABLE_ENUM_SERIALIZATION</code>. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_fasttests","title":"<code>JSON_FastTests</code>","text":"<p>Skip expensive/slow test suites. This option is <code>OFF</code> by default. Depends on <code>JSON_BuildTests</code>.</p>"},{"location":"integration/cmake/#json_globaludls","title":"<code>JSON_GlobalUDLs</code>","text":"<p>Place user-defined string literals in the global namespace by defining the macro <code>JSON_USE_GLOBAL_UDLS</code>. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_implicitconversions","title":"<code>JSON_ImplicitConversions</code>","text":"<p>Enable implicit conversions by defining macro <code>JSON_USE_IMPLICIT_CONVERSIONS</code>. This option is <code>ON</code> by default.</p>"},{"location":"integration/cmake/#json_install","title":"<code>JSON_Install</code>","text":"<p>Install CMake targets during install step. This option is <code>ON</code> by default if the library's CMake project is the top project.</p>"},{"location":"integration/cmake/#json_legacydiscardedvaluecomparison","title":"<code>JSON_LegacyDiscardedValueComparison</code>","text":"<p>Enable the (incorrect) legacy comparison behavior of discarded JSON values by defining macro <code>JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON</code>. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_multipleheaders","title":"<code>JSON_MultipleHeaders</code>","text":"<p>Use the non-amalgamated version of the library. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_systeminclude","title":"<code>JSON_SystemInclude</code>","text":"<p>Treat the library headers like system headers (i.e., adding <code>SYSTEM</code> to the <code>target_include_directories</code> call) to check for this library by tools like Clang-Tidy. This option is <code>OFF</code> by default.</p>"},{"location":"integration/cmake/#json_valgrind","title":"<code>JSON_Valgrind</code>","text":"<p>Execute the test suite with Valgrind. This option is <code>OFF</code> by default. Depends on <code>JSON_BuildTests</code>.</p>"},{"location":"integration/migration_guide/","title":"Migration Guide","text":"<p>This page collects some guidelines on how to future-proof your code for future versions of this library.</p>"},{"location":"integration/migration_guide/#replace-deprecated-functions","title":"Replace deprecated functions","text":"<p>The following functions have been deprecated and will be removed in the next major version (i.e., 4.0.0). All deprecations are annotated with <code>HEDLEY_DEPRECATED_FOR</code> to report which function to use instead.</p>"},{"location":"integration/migration_guide/#parsing","title":"Parsing","text":"<ul> <li> <p>Function <code>friend std::istream&amp; operator&lt;&lt;(basic_json&amp;, std::istream&amp;)</code> is deprecated since 3.0.0. Please use   <code>friend std::istream&amp;  operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</code> instead.</p> DeprecatedFuture-proof <pre><code>nlohmann::json j;\nstd::stringstream ss(\"[1,2,3]\");\nj &lt;&lt; ss;\n</code></pre> <pre><code>nlohmann::json j;\nstd::stringstream ss(\"[1,2,3]\");\nss &gt;&gt; j;\n</code></pre> </li> <li> <p>Passing iterator pairs or pointer/length pairs to parsing functions (<code>parse</code>,   <code>accept</code>, <code>sax_parse</code>,   <code>from_cbor</code>, <code>from_msgpack</code>,   <code>from_ubjson</code>, and <code>from_bson</code> via initializer   lists is deprecated since 3.8.0. Instead, pass two iterators; for instance, call <code>from_cbor(ptr, ptr+len)</code> instead of   <code>from_cbor({ptr, len})</code>.</p> DeprecatedFuture-proof <pre><code>const char* s = \"[1,2,3]\";\nbool ok = nlohmann::json::accept({s, s + std::strlen(s)});\n</code></pre> <pre><code>const char* s = \"[1,2,3]\";\nbool ok = nlohmann::json::accept(s, s + std::strlen(s));\n</code></pre> </li> </ul>"},{"location":"integration/migration_guide/#json-pointers","title":"JSON Pointers","text":"<ul> <li> <p>Comparing JSON Pointers with strings via <code>operator==</code> and   <code>operator!=</code> is deprecated since 3.11.2. To compare a   <code>json_pointer</code> <code>p</code> with a string <code>s</code>, convert <code>s</code> to a <code>json_pointer</code> first and use   <code>json_pointer::operator==</code> or   <code>json_pointer::operator!=</code>.</p> DeprecatedFuture-proof <pre><code>nlohmann::json::json_pointer lhs(\"/foo/bar/1\");\nassert(lhs == \"/foo/bar/1\");\n</code></pre> <pre><code>nlohmann::json::json_pointer lhs(\"/foo/bar/1\");\nassert(lhs == nlohmann::json::json_pointer(\"/foo/bar/1\"));\n</code></pre> </li> <li> <p>The implicit conversion from JSON Pointers to string   (<code>json_pointer::operator string_t</code>) is deprecated since 3.11.0. Use   <code>json_pointer::to_string</code> instead.</p> DeprecatedFuture-proof <pre><code>nlohmann::json::json_pointer ptr(\"/foo/bar/1\");\nstd::string s = ptr;\n</code></pre> <pre><code>nlohmann::json::json_pointer ptr(\"/foo/bar/1\");\nstd::string s = ptr.to_string();\n</code></pre> </li> <li> <p>Passing a <code>basic_json</code> specialization as template parameter <code>RefStringType</code> to   <code>json_pointer</code> is deprecated since 3.11.0. The string type can now be directly   provided.</p> DeprecatedFuture-proof <pre><code>using my_json = nlohmann::basic_json&lt;std::map, std::vector, my_string_type&gt;;\nnlohmann::json_pointer&lt;my_json&gt; ptr(\"/foo/bar/1\");\n</code></pre> <pre><code>nlohmann::json_pointer&lt;my_string_type&gt; ptr(\"/foo/bar/1\");\n</code></pre> <p>Thereby, <code>nlohmann::my_json::json_pointer</code> is an alias for <code>nlohmann::json_pointer&lt;my_string_type&gt;</code> and is always an  alias to the <code>json_pointer</code> with the appropriate string type for all specializations of <code>basic_json</code>.</p> </li> </ul>"},{"location":"integration/migration_guide/#miscellaneous-functions","title":"Miscellaneous functions","text":"<ul> <li> <p>The function <code>iterator_wrapper</code> is deprecated since 3.1.0. Please use the member function   <code>items</code> instead.</p> DeprecatedFuture-proof <pre><code>for (auto &amp;x : nlohmann::json::iterator_wrapper(j))\n{\n    std::cout &lt;&lt; x.key() &lt;&lt; \":\" &lt;&lt; x.value() &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>for (auto &amp;x : j.items())\n{\n    std::cout &lt;&lt; x.key() &lt;&lt; \":\" &lt;&lt; x.value() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Function <code>friend std::ostream&amp; operator&gt;&gt;(const basic_json&amp;, std::ostream&amp;)</code> is deprecated since 3.0.0. Please use   <code>friend operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</code> instead.</p> DeprecatedFuture-proof <pre><code>j &gt;&gt; std::cout;\n</code></pre> <pre><code>std::cout &lt;&lt; j;\n</code></pre> </li> <li> <p>The legacy comparison behavior for discarded values is deprecated since 3.11.0. It is already disabled by default and   can still be enabled by defining   <code>JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON</code> to <code>1</code>.</p> DeprecatedFuture-proof <pre><code>#define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 1\n#include &lt;nlohmann/json.hpp&gt;\n</code></pre> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n</code></pre> </li> </ul>"},{"location":"integration/migration_guide/#replace-implicit-conversions","title":"Replace implicit conversions","text":"<p>Implicit conversions via <code>operator ValueType</code> will be switched off by default in the next major release of the library.</p> <p>You can prepare existing code by already defining <code>JSON_USE_IMPLICIT_CONVERSIONS</code> to <code>0</code> and replace any implicit conversions with calls to <code>get</code>, <code>get_to</code>, <code>get_ref</code>, or <code>get_ptr</code>.</p> DeprecatedFuture-proofFuture-proof (alternative) <pre><code>nlohmann::json j = \"Hello, world!\";\nstd::string s = j;\n</code></pre> <pre><code>nlohmann::json j = \"Hello, world!\";\nauto s = j.template get&lt;std::string&gt;();\n</code></pre> <pre><code>nlohmann::json j = \"Hello, world!\";\nstd::string s;\nj.get_to(s);\n</code></pre> <p>You can prepare existing code by already defining <code>JSON_USE_IMPLICIT_CONVERSIONS</code> to <code>0</code> and replace any implicit conversions with calls to <code>get</code>.</p>"},{"location":"integration/migration_guide/#import-namespace-literals-for-udls","title":"Import namespace <code>literals</code> for UDLs","text":"<p>The user-defined string literals <code>operator\"\"_json</code> and <code>operator\"\"_json_pointer</code> will be removed from the global namespace in the next major release of the library.</p> DeprecatedFuture-proof <pre><code>nlohmann::json j = \"[1,2,3]\"_json;\n</code></pre> <pre><code>using namespace nlohmann::literals;\nnlohmann::json j = \"[1,2,3]\"_json;\n</code></pre> <p>To prepare existing code, define <code>JSON_USE_GLOBAL_UDLS</code> to <code>0</code> and bring the string literals into scope where needed.</p>"},{"location":"integration/migration_guide/#do-not-hard-code-the-complete-library-namespace","title":"Do not hard-code the complete library namespace","text":"<p>The <code>nlohmann</code> namespace contains a sub-namespace to avoid problems when different versions or configurations of the library are used in the same project. Always use <code>nlohmann</code> as namespace or, when the exact version and configuration is relevant, use macro <code>NLOHMANN_JSON_NAMESPACE</code> to denote the namespace.</p> DangerousFuture-proofFuture-proof (alternative) <pre><code>void to_json(nlohmann::json_abi_v3_11_2::json&amp; j, const person&amp; p)\n{\n    j[\"age\"] = p.age;\n}\n</code></pre> <pre><code>void to_json(nlohmann::json&amp; j, const person&amp; p)\n{\n    j[\"age\"] = p.age;\n}\n</code></pre> <pre><code>void to_json(NLOHMANN_JSON_NAMESPACE::json&amp; j, const person&amp; p)\n{\n    j[\"age\"] = p.age;\n}\n</code></pre>"},{"location":"integration/migration_guide/#do-not-use-the-details-namespace","title":"Do not use the <code>details</code> namespace","text":"<p>The <code>details</code> namespace is not part of the public API of the library and can change in any version without an announcement. Do not rely on any function or type in the <code>details</code> namespace.</p>"},{"location":"integration/package_managers/","title":"Package Managers","text":"<p> Homebrew <code>nlohmann-json</code> Meson <code>nlohmann_json</code> Bazel <code>nlohmann_json</code> Conan <code>nlohmann_json</code> Spack <code>nlohmann-json</code> Hunter <code>nlohmann_json</code> vcpkg <code>nlohmann-json</code> cget <code>nlohmann/json</code> Swift Package Manager <code>nlohmann/json</code> NuGet <code>nlohmann.json</code> Conda <code>nlohmann_json</code> MacPorts <code>nlohmann-json</code> CPM.cmake <code>gh:nlohmann/json</code> xmake <code>nlohmann_json</code> </p>"},{"location":"integration/package_managers/#running-example","title":"Running example","text":"<p>Throughout this page, we will describe how to compile the example file <code>example.cpp</code> below.</p> <pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> <p>When executed, this program should create output similar to</p> <pre><code>{\n    \"compiler\": {\n        \"c++\": \"201103\",\n        \"family\": \"gcc\",\n        \"version\": \"12.4.0\"\n    },\n    \"copyright\": \"(C) 2013-2025 Niels Lohmann\",\n    \"name\": \"JSON for Modern C++\",\n    \"platform\": \"apple\",\n    \"url\": \"https://github.com/nlohmann/json\",\n    \"version\": {\n        \"major\": 3,\n        \"minor\": 12,\n        \"patch\": 0,\n        \"string\": \"3.12.0\"\n    }\n}\n</code></pre>"},{"location":"integration/package_managers/#homebrew","title":"Homebrew","text":"<p>Summary</p> <p>formula: <code>nlohmann-json</code></p> <ul> <li> Available versions: current version and development version (with <code>--HEAD</code> parameter)</li> <li> The formula is updated with every release.</li> <li> Maintainer: Niels Lohmann</li> <li> File issues at the Homebrew issue tracker</li> <li> Homebrew website</li> </ul> <p>If you are using Homebrew, you can install the library with</p> <pre><code>brew install nlohmann-json\n</code></pre> <p>The header can be used directly in your code or via CMake.</p> Example: Raw compilation <ol> <li> <p>Create the following file:</p> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>brew install nlohmann-json\n</code></pre> </li> <li> <p>Compile the code and pass the Homebrew prefix to the include path such that the library can be found:</p> <pre><code>c++ example.cpp -I$(brew --prefix nlohmann-json)/include -std=c++11 -o example\n</code></pre> </li> </ol> Example: CMake <ol> <li> <p>Create the following files:</p> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>brew install nlohmann-json\n</code></pre> </li> <li> <p>Compile the code and pass the Homebrew prefix to CMake to find installed packages via <code>find_package</code>:</p> <pre><code>CMAKE_PREFIX_PATH=$(brew --prefix) cmake -S . -B build\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#meson","title":"Meson","text":"<p>Summary</p> <p>wrap: <code>nlohmann_json</code></p> <ul> <li> Available versions: current version and select older versions (see   WrapDB)</li> <li> The package is update automatically from file   <code>meson.build</code>.</li> <li> File issues at the library issue tracker</li> <li> Meson website</li> </ul> <p>If you are using the Meson Build System, add this source tree as a meson subproject. You may also use the <code>include.zip</code> published in this project's Releases to reduce the size of the vendored source tree. Alternatively, you can get a wrap file by downloading it from Meson WrapDB, or use</p> <pre><code>meson wrap install nlohmann_json\n</code></pre> <p>Please see the Meson project for any issues regarding the packaging.</p> <p>The provided <code>meson.build</code> can also be used as an alternative to CMake for installing <code>nlohmann_json</code> system-wide in which case a pkg-config file is installed. To use it, have your build system require the <code>nlohmann_json</code> pkg-config dependency. In Meson, it is preferred to use the <code>dependency()</code> object with a subproject fallback, rather than using the subproject directly.</p> Example: Wrap <ol> <li> <p>Create the following files:</p> meson.build<pre><code>project('json_example', 'cpp',\n  version: '1.0',\n  default_options: ['cpp_std=c++11']\n)\n\ndependency_json = dependency('nlohmann_json', required: true)\n\nexecutable('json_example',\n  sources: ['example.cpp'],\n  dependencies: [dependency_json],\n  install: true\n)\n</code></pre> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Use the Meson WrapDB to fetch the nlohmann/json wrap:</p> <pre><code>mkdir subprojects\nmeson wrap install nlohmann_json\n</code></pre> </li> <li> <p>Build:</p> <pre><code>meson setup build\nmeson compile -C build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#bazel","title":"Bazel","text":"<p>Summary</p> <p>use <code>bazel_dep</code>, <code>git_override</code>, or <code>local_path_override</code></p> <ul> <li> Any version, that is available via Bazel Central Registry</li> <li> File issues at the library issue tracker</li> <li> Bazel website</li> </ul> <p>This repository provides a Bazel <code>MODULE.bazel</code> and a corresponding <code>BUILD.bazel</code> file. Therefore, this repository can be referenced within a <code>MODULE.bazel</code> by rules such as <code>archive_override</code>, <code>git_override</code>, or <code>local_path_override</code>. To use the library, you need to depend on the target <code>@nlohmann_json//:json</code> (i.e., via <code>deps</code> attribute).</p> Example <ol> <li> <p>Create the following files:</p> BUILD<pre><code>cc_binary(\n    name = \"main\",\n    srcs = [\"example.cpp\"],\n    deps = [\"@nlohmann_json//:json\"],\n)\n</code></pre> WORKSPACE<pre><code>bazel_dep(name = \"nlohmann_json\", version = \"3.11.3.bcr.1\")\n</code></pre> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Build and run:</p> <pre><code>bazel build //:main\nbazel run //:main\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#conan","title":"Conan","text":"<p>Summary</p> <p>recipe: <code>nlohmann_json</code></p> <ul> <li> Available versions: current version and older versions (see   Conan Center)</li> <li> The package is update automatically via   this recipe.</li> <li> File issues at the Conan Center issue tracker</li> <li> Conan website</li> </ul> <p>If you are using Conan to manage your dependencies, merely add <code>nlohmann_json/x.y.z</code> to your <code>conanfile</code>'s requires, where <code>x.y.z</code> is the release version you want to use.</p> Example <ol> <li> <p>Create the following files:</p> Conanfile.txt<pre><code>[requires]\nnlohmann_json/3.12.0\n\n[generators]\nCMakeToolchain\nCMakeDeps\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Call Conan:</p> <pre><code>conan install . --output-folder=build --build=missing\n</code></pre> </li> <li> <p>Build:</p> <pre><code>cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=\"conan_toolchain.cmake\" -DCMAKE_BUILD_TYPE=Release\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#spack","title":"Spack","text":"<p>Summary</p> <p>package: <code>nlohmann-json</code></p> <ul> <li> Available versions: current version and older versions (see   Spack package)</li> <li> The package is updated with every release.</li> <li> Maintainer: Axel Huebl</li> <li> File issues at the Spack issue tracker</li> <li> Spack website</li> </ul> <p>If you are using Spack to manage your dependencies, you can use the <code>nlohmann-json</code> package via</p> <pre><code>spack install nlohmann-json\n</code></pre> <p>Please see the Spack project for any issues regarding the packaging.</p> Example <ol> <li> <p>Create the following files:</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Install the library:</p> <pre><code>spack install nlohmann-json\n</code></pre> </li> <li> <p>Load the environment for your Spack-installed packages:</p> <pre><code>spack load nlohmann-json\n</code></pre> </li> <li> <p>Build the project with CMake:</p> <pre><code>cmake -S . -B build -DCMAKE_PREFIX_PATH=$(spack location -i nlohmann-json)\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#hunter","title":"Hunter","text":"<p>Summary</p> <p>package: <code>nlohmann_json</code></p> <ul> <li> Available versions: current version and older versions (see   Hunter package)</li> <li> The package is updated with every release.</li> <li> File issues at the Hunter issue tracker</li> <li> Hunter website</li> </ul> <p>If you are using Hunter on your project for external dependencies, then you can use the nlohmann_json package via</p> <pre><code>hunter_add_package(nlohmann_json)\n</code></pre> <p>Please see the Hunter project for any issues regarding the packaging.</p> Example <ol> <li> <p>Create the following files:</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\n\ninclude(\"cmake/HunterGate.cmake\")\nHunterGate(\n    URL \"https://github.com/cpp-pm/hunter/archive/v0.23.297.tar.gz\"\n    SHA1 \"3319fe6a3b08090df7df98dee75134d68e2ef5a3\"\n)\n\nproject(json_example)\n\nhunter_add_package(nlohmann_json)\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Download required files</p> <pre><code>mkdir cmake\nwget https://raw.githubusercontent.com/cpp-pm/gate/master/cmake/HunterGate.cmake -O cmake/HunterGate.cmake\n</code></pre> </li> <li> <p>Build the project with CMake:</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#vcpkg","title":"vcpkg","text":"<p>Summary</p> <p>package: <code>nlohmann-json</code></p> <ul> <li> Available versions: current version</li> <li> The package is updated with every release.</li> <li> File issues at the vcpkg issue tracker</li> <li> vcpkg website</li> </ul> <p>If you are using vcpkg on your project for external dependencies, then you can install the nlohmann-json package with</p> <pre><code>vcpkg install nlohmann-json\n</code></pre> <p>and follow the then displayed descriptions. Please see the vcpkg project for any issues regarding the packaging.</p> Example <ol> <li> <p>Create the following files:</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Install package:</p> <pre><code>vcpkg install nlohmann-json\n</code></pre> </li> <li> <p>Build:</p> <pre><code>cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#cget","title":"cget","text":"<p>Summary</p> <p>package: <code>nlohmann/json</code></p> <ul> <li> Available versions: current version and older versions</li> <li> The package is updated with every release.</li> <li> File issues at the cget issue tracker</li> <li> cget website</li> </ul> <p>If you are using cget, you can install the latest <code>master</code> version with</p> <pre><code>cget install nlohmann/json\n</code></pre> <p>A specific version can be installed with <code>cget install nlohmann/json@v3.12.0</code>. Also, the multiple header version can be installed by adding the <code>-DJSON_MultipleHeaders=ON</code> flag (i.e., <code>cget install nlohmann/json -DJSON_MultipleHeaders=ON</code>).</p> Example <ol> <li> <p>Create the following files:</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Initialize cget</p> <pre><code>cget init\n</code></pre> </li> <li> <p>Install the library</p> <pre><code>cget install nlohmann/json\n</code></pre> </li> <li> <p>Build</p> <pre><code>cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE=cget/cget/cget.cmake\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#swift-package-manager","title":"Swift Package Manager","text":"<p>Summary</p> <p>package: <code>nlohmann/json</code></p> <ul> <li> Available versions: current version and older versions</li> <li> The package is updated with every release.</li> <li> File issues at the library issue tracker</li> <li> Xcode documentation</li> </ul>"},{"location":"integration/package_managers/#nuget","title":"NuGet","text":"<p>Summary</p> <p>package: <code>nlohmann.json</code></p> <ul> <li> Available versions: current and previous versions</li> <li> The package is updated with every release.</li> <li> Maintainer: Hani Kaabi</li> <li> File issues at the maintainer's issue tracker</li> <li> NuGet website</li> </ul> <p>If you are using NuGet, you can use the package nlohmann.json with</p> <pre><code>dotnet add package nlohmann.json\n</code></pre> Example <p>Probably the easiest way to use NuGet packages is through Visual Studio graphical interface. Just right-click on a project (any C++ project would do) in \u201cSolution Explorer\u201d and select \u201cManage NuGet Packages\u2026\u201d</p> <p></p> <p>Now you can click on \u201cBrowse\u201d tab and find the package you like to install.</p> <p></p> <p>Most of the packages in NuGet gallery are .NET packages and would not be useful in a C++ project. Microsoft recommends adding \u201cnative\u201d and \u201cnativepackage\u201d tags to C++ NuGet packages to distinguish them, but even adding \u201cnative\u201d to search query would still show many .NET-only packages in the list.</p> <p>Nevertheless, after finding the package you want, click on \u201cInstall\u201d button and accept confirmation dialogs. After the package is successfully added to the projects, you should be able to build and execute the project without the need for making any more changes to build settings.</p> <p>Note</p> <p>A few notes:</p> <ul> <li>NuGet packages are installed per project and not system-wide. The header and binaries for the package are only   available to the project it is added to, and not other projects (obviously unless we add the package to those   projects as well)</li> <li>One of the many great things about your elegant work is that it is a header-only library, which makes   deployment very straightforward. In case of libraries which need binary deployment (<code>.lib</code>, <code>.dll</code> and <code>.pdb</code>   for debug info) the different binaries for each supported compiler version must be added to the NuGet package.   Some library creators cram binary versions for all supported Visual C++ compiler versions in the same package,   so a single package will support all compilers. Some others create a different package for each compiler   version (and you usually see things like \u201cv140\u201d or \u201cvc141\u201d in package name to clarify which VC++ compiler this   package supports).</li> <li>Packages can have dependency to other packages, and in this case, NuGet will install all dependencies as well   as the requested package recursively.</li> </ul> <p>What happens behind the scenes</p> <p>After you add a NuGet package, three changes occur in the project source directory. Of course, we could make these changes manually instead of using GUI:</p> <p></p> <ol> <li> <p>A <code>packages.config</code> file will be created (or updated to include the package name if one such file already    exists). This file contains a list of the packages required by this project (name and minimum version) and must    be added to the project source code repository, so if you move the source code to a new machine, MSBuild/NuGet    knows which packages it has to restore (which it does automatically before each build).</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;packages&gt;\n  &lt;package id=\"nlohmann.json\" version=\"3.5.0\" targetFramework=\"native\" /&gt;\n&lt;/packages&gt;\n</code></pre> </li> <li> <p>A <code>packages</code> folder which contains actual files in the packages (these are header and binary files required for    a successful build, plus a few metadata files). In case of this library for example, it contains <code>json.hpp</code>:</p> <p></p> <p>Note</p> <p>This directory should not be added to the project source code repository, as it will be restored before each build by MSBuild/NuGet. If you go ahead and delete this folder, then build the project again, it will magically re-appear!</p> </li> <li> <p>Project MSBuild makefile (which for Visual C++ projects has a .vcxproj extension) will be updated to include    settings from the package.</p> <p></p> <p>The important bit for us here is line 170, which tells MSBuild to import settings from <code>packages\\nlohmann.json.3.5.0\\build\\native\\nlohmann.json.targets</code> file. This is a file the package creator created and added to the package (you can see it is one of the two files I created in this repository, the other just contains package attributes like name and version number). What does it contain?</p> <p>For our header-only repository, the only setting we need is to add our include directory to the list of <code>AdditionalIncludeDirectories</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"&gt;\n    &lt;ItemDefinitionGroup&gt;\n        &lt;ClCompile&gt;\n            &lt;AdditionalIncludeDirectories&gt;$(MSBuildThisFileDirectory)include;%(AdditionalIncludeDirectories)&lt;/AdditionalIncludeDirectories&gt;\n        &lt;/ClCompile&gt;\n    &lt;/ItemDefinitionGroup&gt;\n&lt;/Project&gt;\n</code></pre> <p>For libraries with binary files, we will need to add <code>.lib</code> files to linker inputs and add settings to copy <code>.dll</code> and other redistributable files to output directory, if needed.</p> <p>There are other changes to the makefile as well:</p> <ul> <li> <p>Lines 165-167 add the <code>packages.config</code> as one of project files (so it is shown in Solution Explorer tree   view). It is added as None (no build action) and removing it wouldn\u2019t affect build.</p> </li> <li> <p>Lines 172-177 check to ensure the required packages are present. This will display a build error if package   directory is empty (for example when NuGet cannot restore packages because Internet connection is down).   Again, if you omit this section, the only change in build would be a more cryptic error message if build   fails.</p> </li> </ul> <p>Note</p> <p>Changes to .vcxproj makefile should also be added to project source code repository.</p> </li> </ol> <p>As you can see, the mechanism NuGet uses to modify project settings is through MSBuild makefiles, so using NuGet with other build systems and compilers (like CMake) as a dependency manager is either impossible or more problematic than useful.</p> <p>Please refer to this extensive description for more information.</p>"},{"location":"integration/package_managers/#conda","title":"Conda","text":"<p>Summary</p> <p>package: <code>nlohmann_json</code></p> <ul> <li> Available versions: current and previous versions</li> <li> The package is updated with every release.</li> <li> File issues at the feedstock's issue tracker</li> <li> Conda documentation</li> </ul> <p>If you are using conda, you can use the package nlohmann_json from conda-forge executing</p> <pre><code>conda install -c conda-forge nlohmann_json\n</code></pre> Example <ol> <li> <p>Create the following file:</p> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Create and activate an anvironment \"json`:</p> <pre><code>conda create -n json\nconda activate json\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>conda install -c conda-forge nlohmann_json\n</code></pre> </li> <li> <p>Build the code:</p> <pre><code>g++ -std=c++11 -I$(conda info --base)/envs/json/include example.cpp -o example\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#msys2","title":"MSYS2","text":"<p>If you are using MSYS2, you can use the mingw-w64-nlohmann-json package, type <code>pacman -S mingw-w64-i686-nlohmann-json</code> or <code>pacman -S mingw-w64-x86_64-nlohmann-json</code> for installation. Please file issues here if you experience problems with the packages.</p> <p> </p> <p> The package is updated automatically.</p>"},{"location":"integration/package_managers/#macports","title":"MacPorts","text":"<p>Summary</p> <p>port: <code>nlohmann-json</code></p> <ul> <li> Available versions: current version</li> <li> The port is updated with every release.</li> <li> File issues at the MacPorts issue tracker</li> <li> MacPorts website</li> </ul> <p>If you are using MacPorts, execute </p> <pre><code>sudo port install nlohmann-json\n</code></pre> <p>to install the nlohmann-json package.</p> Example: Raw compilation <ol> <li> <p>Create the following file:</p> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>sudo port install nlohmann-json\n</code></pre> </li> <li> <p>Compile the code and pass the Homebrew prefix to the include path such that the library can be found:</p> <pre><code>c++ example.cpp -I/opt/local/include -std=c++11 -o example\n</code></pre> </li> </ol> Example: CMake <ol> <li> <p>Create the following files:</p> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\nfind_package(nlohmann_json CONFIG REQUIRED)\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>sudo port install nlohmann-json\n</code></pre> </li> <li> <p>Compile the code:</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#build2","title":"build2","text":"<p>If you are using <code>build2</code>, you can use the <code>nlohmann-json</code> package from the public repository http://cppget.org or directly from the package's sources repository. In your project's <code>manifest</code> file, add <code>depends: nlohmann-json</code> (probably with some version constraints). If you are not familiar with using dependencies in <code>build2</code>, please read this introduction. Please file issues here if you experience problems with the packages.</p> <p> The package is updated automatically.</p> <pre><code>bdep new -t exe -l c++\n</code></pre>"},{"location":"integration/package_managers/#cpmcmake","title":"CPM.cmake","text":"<p>Summary</p> <p>package: <code>gh:nlohmann/json</code></p> <ul> <li> Available versions: current and previous versions</li> <li> The package is updated with every release.</li> <li> File issues at the CPM.cmake issue tracker</li> <li> CPM.cmake website</li> </ul> <p>If you are using <code>CPM.cmake</code>, add the CPM.cmake script and the following snippet to your CMake project:</p> <pre><code>CPMAddPackage(\"gh:nlohmann/json@3.12.0\")\n</code></pre> Example <ol> <li> <p>Create the following files:</p> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.15)\nproject(json_example)\n\ninclude(${CMAKE_SOURCE_DIR}/cmake/CPM.cmake)\n\nCPMAddPackage(\"gh:nlohmann/json@3.12.0\")\n\nadd_executable(json_example example.cpp)\ntarget_link_libraries(json_example PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> </li> <li> <p>Download CPM.cmake</p> <pre><code>mkdir -p cmake\nwget -O cmake/CPM.cmake https://github.com/cpm-cmake/CPM.cmake/releases/latest/download/get_cpm.cmake\n</code></pre> </li> <li> <p>Build</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#xmake","title":"xmake","text":"<p>Summary</p> <p>package: <code>nlohmann_json</code></p> <ul> <li> Available versions: current and previous versions</li> <li> The package is updated with every release.</li> <li> File issues at the xmake issue tracker</li> <li> xmake website</li> </ul> Example <ol> <li> <p>Create the following files:</p> example.cpp<pre><code>#include &lt;nlohmann/json.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing json = nlohmann::json;\n\nint main()\n{\n    std::cout &lt;&lt; std::setw(4) &lt;&lt; json::meta() &lt;&lt; std::endl;\n}\n</code></pre> xmake.lua<pre><code>add_requires(\"nlohmann_json\")\n\nadd_rules(\"mode.debug\", \"mode.release\")\ntarget(\"xm\")\n    set_kind(\"binary\")\n    add_files(\"example.cpp\")\n    add_packages(\"nlohmann_json\")\n    set_languages(\"cxx11\")\n</code></pre> </li> <li> <p>Build</p> <pre><code>xmake\n</code></pre> </li> <li> <p>Run</p> <pre><code>xmake run\n</code></pre> </li> </ol>"},{"location":"integration/package_managers/#other-package-managers","title":"Other package managers","text":"<p>The library is also contained in many other package repositories: </p> Package version overview <p></p>"},{"location":"integration/package_managers/#buckaroo","title":"Buckaroo","text":"<p>If you are using Buckaroo, you can install this library's module with <code>buckaroo add github.com/buckaroo-pm/nlohmann-json</code>. There is a demo repo here.</p> <p>Warning</p> <p>The module is outdated as the respective repository has not been updated in years.</p>"},{"location":"integration/package_managers/#cocoapods","title":"CocoaPods","text":"<p>If you are using CocoaPods, you can use the library by adding pod <code>\"nlohmann_json\", '~&gt;3.1.2'</code> to your podfile (see an example). Please file issues here.</p> <p></p> <p>Warning</p> <p>The module is outdated as the respective pod has not been updated in years.</p>"},{"location":"integration/pkg-config/","title":"Pkg-config","text":"<p>If you are using bare Makefiles, you can use <code>pkg-config</code> to generate the include flags that point to where the library is installed:</p> <pre><code>pkg-config nlohmann_json --cflags\n</code></pre> <p>Users of the Meson build system will also be able to use a system-wide library, which will be found by <code>pkg-config</code>:</p> <pre><code>json = dependency('nlohmann_json', required: true)\n</code></pre>"}]}